<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "<infomsg>bitotal is defined</infomsg>	";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "<infomsg>Interactive Module CumulativeHierarchy started</infomsg>	";
            responses[i]=data;
          

            i = 32;
            data = "<infomsg>V is defined</infomsg>	";
            responses[i]=data;
          

            i = 33;
            data = "<infomsg>setext is declared</infomsg>	";
            responses[i]=data;
          

            i = 34;
            data = "<infomsg>is0trunc_V is declared</infomsg>	";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>V_ind is defined</infomsg>	<infomsg>V_ind is recursively defined (guarded on 5th argument)</infomsg>	";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "<infomsg>Module CumulativeHierarchy is defined</infomsg>	";
            responses[i]=data;
          

            i = 42;
            data = "1 goal (ID 75)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	             (bitot_R : bitotal R)	             (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0),	                    P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	                  (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  ============================	  apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)	";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "";
            responses[i]=data;
          

            i = 48;
            data = "";
            responses[i]=data;
          

            i = 49;
            data = "";
            responses[i]=data;
          

            i = 50;
            data = "1 goal (ID 132)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  ============================	  V -> P	";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "1 goal (ID 152)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 53;
            data = "1 goal (ID 158)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 54;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "1 goal (ID 215)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  ============================	  ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)	";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "<infomsg>equal_img is defined</infomsg>	";
            responses[i]=data;
          

            i = 68;
            data = "1 goal (ID 234)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "1 goal (ID 256)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 71;
            data = "1 goal (ID 262)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  h := SPushout_rec (fun (a : A) (b : B) => R a b) V f g	         (fun (x : A) (y : B) => idmap)	   : SPushout (fun (a : A) (b : B) => R a b) -> V	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 72;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "1 goal (ID 247)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  V -> P	";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "1 goal (ID 254)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp),	  bitotal R ->	  forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	  H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 77;
            data = "1 goal (ID 260)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 78;
            data = "2 goals (ID 261)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))		goal 2 (ID 262) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 79;
            data = "1 goal (ID 261)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	2 goals (ID 264)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))		goal 2 (ID 265) is:	 forall b : B,	 hexists	   (fun a : A =>	    h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 80;
            data = "1 goal (ID 264)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 goal (ID 266)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 81;
            data = "1 goal (ID 269)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 82;
            data = "1 goal (ID 272)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  {b : B & R a b} ->	  {b : B &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 83;
            data = "1 goal (ID 277)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	";
            responses[i]=data;
          

            i = 84;
            data = "1 goal (ID 279)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 85;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 265) is:	 forall b : B,	 hexists	   (fun a : A =>	    h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    h (spushr (fun (x : A) (x0 : B) => R x x0) b))	goal 2 (ID 262) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 86;
            data = "1 goal (ID 265)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 goal (ID 290)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 293)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 88;
            data = "1 goal (ID 296)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  {a : A & R a b} ->	  {a : A &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 89;
            data = "1 goal (ID 301)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 90;
            data = "1 goal (ID 303)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 91;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 262) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 92;
            data = "1 goal (ID 262)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	2 goals (ID 315)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))		goal 2 (ID 316) is:	 forall b : B,	 hexists	   (fun a : A =>	    H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 93;
            data = "1 goal (ID 315)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 goal (ID 317)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 94;
            data = "1 goal (ID 320)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 95;
            data = "1 goal (ID 323)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  {b : B & R a b} ->	  {b : B &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 96;
            data = "1 goal (ID 328)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	";
            responses[i]=data;
          

            i = 97;
            data = "1 goal (ID 330)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 98;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 316) is:	 forall b : B,	 hexists	   (fun a : A =>	    H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 99;
            data = "1 goal (ID 316)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 goal (ID 341)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 344)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 101;
            data = "1 goal (ID 347)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  {a : A & R a b} ->	  {a : A &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 102;
            data = "1 goal (ID 352)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 103;
            data = "1 goal (ID 354)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 104;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "1 goal (ID 287)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall v : V, P v	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "1 goal (ID 290)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 113;
            data = "1 goal (ID 296)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 114;
            data = "1 goal (ID 308)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 115;
            data = "1 goal (ID 320)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 116;
            data = "1 goal (ID 326)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 117;
            data = "1 goal (ID 332)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 118;
            data = "2 goals (ID 336)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g		goal 2 (ID 337) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 119;
            data = "1 goal (ID 336)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g	2 goals (ID 339)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		goal 2 (ID 340) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 120;
            data = "1 goal (ID 339)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 goal (ID 341)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 121;
            data = "1 goal (ID 344)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => R a b) -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 122;
            data = "1 goal (ID 347)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  {b : B & R a b} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 123;
            data = "1 goal (ID 352)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 124;
            data = "1 goal (ID 354)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 125;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 340) is:	 forall b : B, hexists (fun a : A => f a = g b)	goal 2 (ID 337) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 126;
            data = "1 goal (ID 340)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 goal (ID 365)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 127;
            data = "1 goal (ID 368)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => R a b) -> hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 128;
            data = "1 goal (ID 371)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  {a : A & R a b} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 129;
            data = "1 goal (ID 376)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A & f a0 = g b}	";
            responses[i]=data;
          

            i = 130;
            data = "1 goal (ID 378)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 131;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 337) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 132;
            data = "1 goal (ID 337)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	2 goals (ID 444)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)))		goal 2 (ID 445) is:	 transport P	   (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	   (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 133;
            data = "1 goal (ID 444)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)))	1 goal (ID 472)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  setext R bitot_R h =	  setext' (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) eq_img	";
            responses[i]=data;
          

            i = 134;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 445) is:	 transport P	   (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	   (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	1 goal (ID 445)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	1 goal (ID 491)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  (forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	  (forall b : B,	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)))	";
            responses[i]=data;
          

            i = 135;
            data = "2 goals (ID 493)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		goal 2 (ID 494) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 136;
            data = "1 goal (ID 493)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	1 goal (ID 495)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 137;
            data = "1 goal (ID 499)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 138;
            data = "1 goal (ID 500)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 139;
            data = "1 goal (ID 503)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  {b : B & R a b} ->	  {b : B & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}	";
            responses[i]=data;
          

            i = 140;
            data = "1 goal (ID 508)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {b0 : B & hexists (fun p : f a = g b0 => transport P p (H_f a) = H_g b0)}	";
            responses[i]=data;
          

            i = 141;
            data = "1 goal (ID 510)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)	";
            responses[i]=data;
          

            i = 142;
            data = "1 goal (ID 513)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}	";
            responses[i]=data;
          

            i = 143;
            data = "1 goal (ID 525)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  H_g b	";
            responses[i]=data;
          

            i = 144;
            data = "1 goal (ID 548)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a))	";
            responses[i]=data;
          

            i = 145;
            data = "1 goal (ID 552)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 146;
            data = "1 goal (ID 553)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 494) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 148;
            data = "1 goal (ID 494)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	1 goal (ID 558)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 149;
            data = "1 goal (ID 562)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 150;
            data = "1 goal (ID 563)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 151;
            data = "1 goal (ID 566)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  {a : A & R a b} ->	  {a : A & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}	";
            responses[i]=data;
          

            i = 152;
            data = "1 goal (ID 571)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {a0 : A & hexists (fun p : f a0 = g b => transport P p (H_f a0) = H_g b)}	";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 573)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)	";
            responses[i]=data;
          

            i = 154;
            data = "1 goal (ID 576)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}	";
            responses[i]=data;
          

            i = 155;
            data = "1 goal (ID 588)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  H_g b	";
            responses[i]=data;
          

            i = 156;
            data = "1 goal (ID 611)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a))	";
            responses[i]=data;
          

            i = 157;
            data = "1 goal (ID 615)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 158;
            data = "1 goal (ID 616)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 159;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 160;
            data = "";
            responses[i]=data;
          

            i = 161;
            data = "";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "1 goal (ID 292)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall v : V, P v	";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "1 goal (ID 311)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 168;
            data = "1 goal (ID 317)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 169;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "";
            responses[i]=data;
          

            i = 172;
            data = "<infomsg>ua is declared</infomsg>	";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "1 goal (ID 294)	  	  ua : Univalence	  x : V	  ============================	  V -> hProp	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "2 goals (ID 300)	  	  ua : Univalence	  x : V	  ============================	  forall A : Type, (A -> V) -> (A -> hProp) -> hProp		goal 2 (ID 302) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g -> ?H_set A f H_f = ?H_set B g H_g	";
            responses[i]=data;
          

            i = 183;
            data = "1 goal (ID 300)	  	  ua : Univalence	  x : V	  ============================	  forall A : Type, (A -> V) -> (A -> hProp) -> hProp	1 goal (ID 307)	  	  ua : Univalence	  x : V	  A : Type	  f : A -> V	  ============================	  hProp	";
            responses[i]=data;
          

            i = 184;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 302) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	  hexists (fun a : A0 => f0 a = x)) A f H_f =	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	  hexists (fun a : A0 => f0 a = x)) B g H_g	";
            responses[i]=data;
          

            i = 185;
            data = "1 goal (ID 302)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) A f H_f =	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) B g H_g	1 goal (ID 311)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)	";
            responses[i]=data;
          

            i = 186;
            data = "1 goal (ID 322)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)	";
            responses[i]=data;
          

            i = 187;
            data = "2 goals (ID 328)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Tr (-1) {a : A & f a = x} -> Tr (-1) {a : B & g a = x}		goal 2 (ID 329) is:	 Tr (-1) {a : B & g a = x} -> Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 188;
            data = "1 goal (ID 328)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Tr (-1) {a : A & f a = x} -> Tr (-1) {a : B & g a = x}	1 goal (ID 330)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  ============================	  Tr (-1) {a : B & g a = x}	";
            responses[i]=data;
          

            i = 189;
            data = "1 goal (ID 336)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  ============================	  {a : A & f a = x} -> Tr (-1) {a : B & g a = x}	";
            responses[i]=data;
          

            i = 190;
            data = "1 goal (ID 341)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  Tr (-1) {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 191;
            data = "1 goal (ID 344)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  hexists (fun b : B => f a = g b) -> Tr (-1) {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 192;
            data = "1 goal (ID 347)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  {b : B & f a = g b} -> {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 193;
            data = "1 goal (ID 352)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 194;
            data = "1 goal (ID 354)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  g b = x	";
            responses[i]=data;
          

            i = 195;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 329) is:	 Tr (-1) {a : B & g a = x} -> Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 196;
            data = "1 goal (ID 329)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Tr (-1) {a : B & g a = x} -> Tr (-1) {a : A & f a = x}	1 goal (ID 370)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  ============================	  Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 197;
            data = "1 goal (ID 376)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  ============================	  {a : B & g a = x} -> Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 198;
            data = "1 goal (ID 381)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 199;
            data = "1 goal (ID 384)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  hexists (fun a : A => f a = g b) -> Tr (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 200;
            data = "1 goal (ID 387)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  {a : A & f a = g b} -> {a : A & f a = x}	";
            responses[i]=data;
          

            i = 201;
            data = "1 goal (ID 392)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = x}	";
            responses[i]=data;
          

            i = 202;
            data = "1 goal (ID 394)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Tr (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  f a = x	";
            responses[i]=data;
          

            i = 203;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "";
            responses[i]=data;
          

            i = 208;
            data = "";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "";
            responses[i]=data;
          

            i = 215;
            data = "<infomsg>subset is defined</infomsg>	";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "1 goal (ID 360)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  V -> hProp	";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "2 goals (ID 456)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  IsHSet hProp		goal 2 (ID 457) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	";
            responses[i]=data;
          

            i = 227;
            data = "1 goal (ID 456)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  IsHSet hProp	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 457) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	";
            responses[i]=data;
          

            i = 228;
            data = "1 goal (ID 457)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	  equal_img f0 g ->	  forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	  equal_img H_f0 H_g ->	  BuildhProp	    ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	     (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	  BuildhProp	    ((forall a : A, hexists (fun b : B => H_f a (g b))) *	     (forall b : B, hexists (fun a : A => H_f a (g b))))	1 goal (ID 514)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  BuildhProp	    ((forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	     (forall b : B, Tr (-1) {a : A & H_f a (g b)})) =	  BuildhProp	    ((forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	     (forall b : B', Tr (-1) {a : A & H_f a (g' b)}))	";
            responses[i]=data;
          

            i = 229;
            data = "2 goals (ID 520)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Tr (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Tr (-1) {a : A & H_f a (g' b)})		goal 2 (ID 521) is:	 (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Tr (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Tr (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 230;
            data = "1 goal (ID 520)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Tr (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Tr (-1) {a : A & H_f a (g' b)})	2 goals (ID 528)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Tr (-1) {b : B' & H_f a (g' b)}		goal 2 (ID 529) is:	 forall b : B', Tr (-1) {a : A & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 231;
            data = "1 goal (ID 528)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	1 goal (ID 530)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  Tr (-1) {b : B' & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 232;
            data = "1 goal (ID 536)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  {b : B & H_f a (g b)} -> Tr (-1) {b : B' & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 233;
            data = "1 goal (ID 541)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  Tr (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 234;
            data = "1 goal (ID 544)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  hexists (fun b0 : B' => g b = g' b0) -> Tr (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 235;
            data = "1 goal (ID 545)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  merely {b0 : B' & g b = g' b0} -> Tr (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 236;
            data = "1 goal (ID 552)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  {b0 : B' & g b = g' b0} -> {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 237;
            data = "1 goal (ID 557)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 238;
            data = "1 goal (ID 559)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  H_f a (g' b')	";
            responses[i]=data;
          

            i = 239;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 529) is:	 forall b : B', Tr (-1) {a : A & H_f a (g' b)}	goal 2 (ID 521) is:	 (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Tr (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Tr (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 240;
            data = "1 goal (ID 529)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  ============================	  forall b : B', Tr (-1) {a : A & H_f a (g' b)}	1 goal (ID 564)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  Tr (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 241;
            data = "1 goal (ID 574)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  {a : B & g a = g' b'} -> Tr (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 242;
            data = "1 goal (ID 579)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Tr (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 243;
            data = "1 goal (ID 580)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Tr (-1) {a : A & H_f a (g b)} -> Tr (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 244;
            data = "1 goal (ID 583)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  {a : A & H_f a (g b)} -> {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 245;
            data = "1 goal (ID 588)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  {a0 : A & H_f a0 (g' b')}	";
            responses[i]=data;
          

            i = 246;
            data = "1 goal (ID 590)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Tr (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  H_f a (g' b')	";
            responses[i]=data;
          

            i = 247;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 521) is:	 (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Tr (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Tr (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 248;
            data = "1 goal (ID 521)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Tr (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Tr (-1) {a : A & H_f a (g' b)}) ->	  (forall a : A, Tr (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Tr (-1) {a : A & H_f a (g b)})	2 goals (ID 601)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Tr (-1) {b : B & H_f a (g b)}		goal 2 (ID 602) is:	 forall b : B, Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 249;
            data = "1 goal (ID 601)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Tr (-1) {b : B & H_f a (g b)}	1 goal (ID 603)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  Tr (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 250;
            data = "1 goal (ID 609)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  {b : B' & H_f a (g' b)} -> Tr (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 251;
            data = "1 goal (ID 614)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  Tr (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 252;
            data = "1 goal (ID 617)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  hexists (fun a0 : B => g a0 = g' b') -> Tr (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 253;
            data = "1 goal (ID 620)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  {a0 : B & g a0 = g' b'} -> {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 254;
            data = "1 goal (ID 625)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  {b0 : B & H_f a (g b0)}	";
            responses[i]=data;
          

            i = 255;
            data = "1 goal (ID 627)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  H_f a (g b)	";
            responses[i]=data;
          

            i = 256;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 602) is:	 forall b : B, Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 257;
            data = "1 goal (ID 602)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  ============================	  forall b : B, Tr (-1) {a : A & H_f a (g b)}	1 goal (ID 635)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 258;
            data = "1 goal (ID 645)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  {b0 : B' & g b = g' b0} -> Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 259;
            data = "1 goal (ID 650)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 260;
            data = "1 goal (ID 651)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Tr (-1) {a : A & H_f a (g' b')} -> Tr (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 261;
            data = "1 goal (ID 654)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  {a : A & H_f a (g' b')} -> {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 262;
            data = "1 goal (ID 659)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  {a0 : A & H_f a0 (g b)}	";
            responses[i]=data;
          

            i = 263;
            data = "1 goal (ID 661)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Tr (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Tr (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  H_f a (g b)	";
            responses[i]=data;
          

            i = 264;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 265;
            data = "";
            responses[i]=data;
          

            i = 266;
            data = "1 goal (ID 361)	  	  ua : Univalence	  ============================	  V -> V -> hProp	";
            responses[i]=data;
          

            i = 267;
            data = "";
            responses[i]=data;
          

            i = 268;
            data = "1 goal (ID 409)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V -> hProp) (H_g : B -> V -> hProp),	  equal_img H_f H_g -> bisim_aux A f H_f = bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 269;
            data = "1 goal (ID 417)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f = bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 270;
            data = "1 goal (ID 424)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f == bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 271;
            data = "1 goal (ID 460)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, bisim_aux A f H_f (f0 a) = bisim_aux B g H_g (f0 a)) ->	  bisim_aux A f H_f (set f0) = bisim_aux B g H_g (set f0)	";
            responses[i]=data;
          

            i = 272;
            data = "1 goal (ID 465)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  bisim_aux A f H_f (set h) = bisim_aux B g H_g (set h)	";
            responses[i]=data;
          

            i = 273;
            data = "2 goals (ID 473)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Tr (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Tr (-1) {a : B & H_g a (h b)})		goal 2 (ID 476) is:	 (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Tr (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Tr (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 274;
            data = "1 goal (ID 473)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Tr (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Tr (-1) {a : B & H_g a (h b)})	2 goals (ID 483)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Tr (-1) {b : C & H_g a (h b)}		goal 2 (ID 484) is:	 forall b : C, Tr (-1) {a : B & H_g a (h b)}	";
            responses[i]=data;
          

            i = 275;
            data = "1 goal (ID 483)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Tr (-1) {b : C & H_g a (h b)}	1 goal (ID 485)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  Tr (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 276;
            data = "1 goal (ID 495)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  {a : A & H_f a = H_g b} -> Tr (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 277;
            data = "1 goal (ID 500)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Tr (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 278;
            data = "1 goal (ID 501)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Tr (-1) {b0 : C & H_f a (h b0)} -> Tr (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 279;
            data = "1 goal (ID 504)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  {b0 : C & H_f a (h b0)} -> {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 280;
            data = "1 goal (ID 509)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 281;
            data = "1 goal (ID 511)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  H_g b (h c)	";
            responses[i]=data;
          

            i = 282;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 484) is:	 forall b : C, Tr (-1) {a : B & H_g a (h b)}	goal 2 (ID 476) is:	 (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Tr (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Tr (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 283;
            data = "1 goal (ID 484)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  ============================	  forall b : C, Tr (-1) {a : B & H_g a (h b)}	1 goal (ID 521)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  Tr (-1) {a : B & H_g a (h c)}	";
            responses[i]=data;
          

            i = 284;
            data = "1 goal (ID 527)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  {a : A & H_f a (h c)} -> Tr (-1) {a : B & H_g a (h c)}	";
            responses[i]=data;
          

            i = 285;
            data = "1 goal (ID 532)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  Tr (-1) {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 286;
            data = "1 goal (ID 535)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  hexists (fun b : B => H_f a = H_g b) -> Tr (-1) {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 287;
            data = "1 goal (ID 538)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  {b : B & H_f a = H_g b} -> {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 288;
            data = "1 goal (ID 543)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 289;
            data = "1 goal (ID 545)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Tr (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Tr (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  H_g b (h c)	";
            responses[i]=data;
          

            i = 290;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 476) is:	 (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Tr (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Tr (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 291;
            data = "1 goal (ID 476)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : B, Tr (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Tr (-1) {a : B & H_g a (h b)}) ->	  (forall a : A, Tr (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Tr (-1) {a : A & H_f a (h b)})	2 goals (ID 561)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Tr (-1) {b : C & H_f a (h b)}		goal 2 (ID 562) is:	 forall b : C, Tr (-1) {a : A & H_f a (h b)}	";
            responses[i]=data;
          

            i = 292;
            data = "1 goal (ID 561)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Tr (-1) {b : C & H_f a (h b)}	1 goal (ID 563)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  Tr (-1) {b : C & H_f a (h b)}	";
            responses[i]=data;
          

            i = 293;
            data = "1 goal (ID 573)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  {b : B & H_f a = H_g b} -> Tr (-1) {b : C & H_f a (h b)}	";
            responses[i]=data;
          

            i = 294;
            data = "1 goal (ID 578)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Tr (-1) {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 295;
            data = "1 goal (ID 579)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Tr (-1) {b0 : C & H_g b (h b0)} -> Tr (-1) {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 296;
            data = "1 goal (ID 582)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  {b0 : C & H_g b (h b0)} -> {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 297;
            data = "1 goal (ID 587)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 298;
            data = "1 goal (ID 589)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  H_f a (h c)	";
            responses[i]=data;
          

            i = 299;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 562) is:	 forall b : C, Tr (-1) {a : A & H_f a (h b)}	";
            responses[i]=data;
          

            i = 300;
            data = "1 goal (ID 562)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  ============================	  forall b : C, Tr (-1) {a : A & H_f a (h b)}	1 goal (ID 602)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  Tr (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 301;
            data = "1 goal (ID 608)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  {a : B & H_g a (h c)} -> Tr (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 302;
            data = "1 goal (ID 613)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  Tr (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 303;
            data = "1 goal (ID 616)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  hexists (fun a : A => H_f a = H_g b) -> Tr (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 304;
            data = "1 goal (ID 619)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  {a : A & H_f a = H_g b} -> {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 305;
            data = "1 goal (ID 624)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  {a0 : A & H_f a0 (h c)}	";
            responses[i]=data;
          

            i = 306;
            data = "1 goal (ID 626)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Tr (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Tr (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  H_f a (h c)	";
            responses[i]=data;
          

            i = 307;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "";
            responses[i]=data;
          

            i = 310;
            data = "1 goal (ID 363)	  	  ua : Univalence	  ============================	  Reflexive (fun x x0 : V => x ~~ x0)	";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "1 goal (ID 386)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, f a ~~ f a) -> set f ~~ set f	";
            responses[i]=data;
          

            i = 313;
            data = "";
            responses[i]=data;
          

            i = 314;
            data = "1 goal (ID 392)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  (forall a : A,	   Tr (-1)	     {b : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	          (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	        path_forall	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (bisim_aux B	             (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	              bisim_aux B	                (fun x : B =>	                 h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : B =>	                 H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0	                       (fun x : A0 =>	                        h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : A0 =>	                        H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0) =	                     bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Tr (-1)	                          {b0 : C &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Tr (-1)	                          {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun	                       X0 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (spushl (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                       =>	                       (X1.1;	                       transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {b0 : B & R X0.1 b0} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (fst bitot_R X0.1))) (snd X c)))	                (fun	                   X : (forall a0 : B,	                        Tr (-1)	                          {b0 : C &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Tr (-1)	                          {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun	                       X0 : {b0 : B &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (spushr (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b0)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X0.2)^ (h0 X1.1))	                          X1.2)) (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : B &	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0	                   (fun x : A0 =>	                    h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : A0 =>	                    H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	                (bisim_aux B	                   (fun x : B =>	                    h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : B =>	                    H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	       (f a) (f b)}) *	  (forall b : A,	   Tr (-1)	     {a : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	          (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	        path_forall	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (bisim_aux B	             (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	              bisim_aux B	                (fun x : B =>	                 h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : B =>	                 H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0	                       (fun x : A0 =>	                        h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : A0 =>	                        H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0) =	                     bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Tr (-1)	                          {b0 : C &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Tr (-1)	                          {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun	                       X0 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (spushl (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                       =>	                       (X1.1;	                       transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {b0 : B & R X0.1 b0} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (fst bitot_R X0.1))) (snd X c)))	                (fun	                   X : (forall a0 : B,	                        Tr (-1)	                          {b0 : C &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Tr (-1)	                          {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun	                       X0 : {b0 : B &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (spushr (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b0)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X0.2)^ (h0 X1.1))	                          X1.2)) (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : B &	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0	                   (fun x : A0 =>	                    h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : A0 =>	                    H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	                (bisim_aux B	                   (fun x : B =>	                    h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : B =>	                    H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	       (f a) (f b)})	2 goals (ID 394)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Tr (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}		goal 2 (ID 395) is:	 forall b : A,	 Tr (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	        (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	      path_forall	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (bisim_aux B	           (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0	              (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : A0 =>	               H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	            bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : B =>	               H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0	                     (fun x : A0 =>	                      h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : A0 =>	                      H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0) =	                   bisim_aux B	                     (fun x : B =>	                      h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : B =>	                      H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Tr (-1)	                        {b0 : C &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Tr (-1)	                        {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B & R X0.1 b0} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (fst bitot_R X0.1))) (snd X c)))	              (fun	                 X : (forall a0 : B,	                      Tr (-1)	                        {b0 : C &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Tr (-1)	                        {a0 : B &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun	                     X0 : {b0 : B &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b0)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h	                              (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                     =>	                     (X1.1;	                     transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0	                 (fun x : A0 =>	                  h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : A0 =>	                  H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	     (f a) (f b)}	";
            responses[i]=data;
          

            i = 315;
            data = "1 goal (ID 394)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Tr (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 395) is:	 forall b : A,	 Tr (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	        (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	      path_forall	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (bisim_aux B	           (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0	              (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : A0 =>	               H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	            bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : B =>	               H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0	                     (fun x : A0 =>	                      h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : A0 =>	                      H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0) =	                   bisim_aux B	                     (fun x : B =>	                      h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : B =>	                      H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Tr (-1)	                        {b0 : C &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Tr (-1)	                        {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B & R X0.1 b0} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (fst bitot_R X0.1))) (snd X c)))	              (fun	                 X : (forall a0 : B,	                      Tr (-1)	                        {b0 : C &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Tr (-1)	                        {a0 : B &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun	                     X0 : {b0 : B &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b0)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h	                              (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                     =>	                     (X1.1;	                     transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0	                 (fun x : A0 =>	                  h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : A0 =>	                  H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	     (f a) (f b)}	";
            responses[i]=data;
          

            i = 316;
            data = "1 goal (ID 395)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall b : A,	  Tr (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}	No more goals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "1 goal (ID 366)	  	  ua : Univalence	  ============================	  forall u v : V, u = v <~> u ~~ v	";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "1 goal (ID 368)	  	  ua : Univalence	  u, v : V	  ============================	  u = v <~> u ~~ v	";
            responses[i]=data;
          

            i = 321;
            data = "2 goals (ID 393)	  	  ua : Univalence	  u, v : V	  ============================	  u = v -> u ~~ v		goal 2 (ID 394) is:	 u ~~ v -> u = v	";
            responses[i]=data;
          

            i = 322;
            data = "1 goal (ID 393)	  	  ua : Univalence	  u, v : V	  ============================	  u = v -> u ~~ v	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 394) is:	 u ~~ v -> u = v	";
            responses[i]=data;
          

            i = 323;
            data = "1 goal (ID 394)	  	  ua : Univalence	  u, v : V	  ============================	  u ~~ v -> u = v	1 goal (ID 400)	  	  ua : Univalence	  u, v : V	  ============================	  forall u0 v0 : V, u0 ~~ v0 -> u0 = v0	";
            responses[i]=data;
          

            i = 324;
            data = "1 goal (ID 495)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  ============================	  forall v0 : V, set f ~~ v0 -> set f = v0	";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "1 goal (ID 561)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  ============================	  set f ~~ set g -> set f = set g	";
            responses[i]=data;
          

            i = 327;
            data = "1 goal (ID 569)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  set f = set g	1 goal (ID 572)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 328;
            data = "2 goals (ID 574)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		goal 2 (ID 575) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 329;
            data = "1 goal (ID 574)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 goal (ID 576)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 330;
            data = "1 goal (ID 577)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  Tr (-1)	    {b : B &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (bisim_aux B0	            (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : B0 =>	             H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	             bisim_aux B0	               (fun x : B0 =>	                h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : B0 =>	                H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B0	                      (fun x : B0 =>	                       h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : B0 =>	                       H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B0 & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : B0 &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B0 &	                          H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	               (bisim_aux B0	                  (fun x : B0 =>	                   h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : B0 =>	                   H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	      (f a) (g b)} -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 331;
            data = "1 goal (ID 580)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  {b : B &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	       (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	     path_forall	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (bisim_aux B0	          (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : B0 => H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	           bisim_aux B0	             (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : B0 =>	              H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0	                    (fun x : A0 =>	                     h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : A0 =>	                     H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0) =	                  bisim_aux B0	                    (fun x : B0 =>	                     h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : B0 =>	                     H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Tr (-1)	                       {b0 : C &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Tr (-1)	                       {a0 : A0 &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b1)} =>	                     (X1.1;	                     transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {b0 : B0 & R X0.1 b0} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (fst bitot_R X0.1))) (snd X c)))	             (fun	                X : (forall a0 : B0,	                     Tr (-1)	                       {b0 : C &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Tr (-1)	                       {a0 : B0 &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun	                    X0 : {b0 : B0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b0)} =>	                     (X1.1;	                     transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : B0 &	                        H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h	                             (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)}	                    =>	                    (X1.1;	                    transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	             (bisim_aux B0	                (fun x : B0 =>	                 h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : B0 =>	                 H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	    (f a) (g b)} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 332;
            data = "1 goal (ID 585)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  b : B	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	           (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	         path_forall	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	               bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A	                        (fun x : A =>	                         h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : A =>	                         H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a) =	                      bisim_aux B	                        (fun x : B =>	                         h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : B =>	                         H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Tr (-1)	                           {b : C &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Tr (-1)	                           {a : A &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun	                        X0 : {a : A &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b0)} =>	                         (X1.1;	                         transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : A &	                            H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0)	                                    X0.1) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                        =>	                        (X1.1;	                        transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b : B & R X0.1 b} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (fst bitot_R X0.1))) (snd X c)))	                 (fun	                    X : (forall a : B,	                         Tr (-1)	                           {b : C &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Tr (-1)	                           {a : B &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun	                        X0 : {b : B &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b)} =>	                         (X1.1;	                         transport trunctype_type 	                           (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : B &	                            H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0)	                                    X0.1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a : A & R a X0.1} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	        (f a) (g b)	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 333;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 575) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 334;
            data = "1 goal (ID 575)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 goal (ID 588)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 335;
            data = "1 goal (ID 589)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  Tr (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (bisim_aux B0	            (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : B0 =>	             H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	             bisim_aux B0	               (fun x : B0 =>	                h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : B0 =>	                H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B0	                      (fun x : B0 =>	                       h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : B0 =>	                       H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B0 & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B0,	                       Tr (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Tr (-1)	                         {a0 : B0 &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B0 &	                          H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	               (bisim_aux B0	                  (fun x : B0 =>	                   h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : B0 =>	                   H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	      (f a) (g b)} -> hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 336;
            data = "1 goal (ID 592)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  {a : A &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	       (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	     path_forall	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (bisim_aux B0	          (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : B0 => H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	           bisim_aux B0	             (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : B0 =>	              H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0	                    (fun x : A0 =>	                     h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : A0 =>	                     H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0) =	                  bisim_aux B0	                    (fun x : B0 =>	                     h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : B0 =>	                     H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Tr (-1)	                       {b0 : C &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Tr (-1)	                       {a0 : A0 &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b1)} =>	                     (X1.1;	                     transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {b0 : B0 & R X0.1 b0} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (fst bitot_R X0.1))) (snd X c)))	             (fun	                X : (forall a0 : B0,	                     Tr (-1)	                       {b0 : C &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Tr (-1)	                       {a0 : B0 &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun	                    X0 : {b0 : B0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b0)} =>	                     (X1.1;	                     transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : B0 &	                        H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h	                             (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)}	                    =>	                    (X1.1;	                    transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	             (bisim_aux B0	                (fun x : B0 =>	                 h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : B0 =>	                 H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	    (f a) (g b)} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 337;
            data = "1 goal (ID 597)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Tr (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Tr (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Tr (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Tr (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  a : A	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	           (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	         path_forall	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	               bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A	                        (fun x : A =>	                         h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : A =>	                         H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a) =	                      bisim_aux B	                        (fun x : B =>	                         h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : B =>	                         H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Tr (-1)	                           {b : C &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Tr (-1)	                           {a : A &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun	                        X0 : {a : A &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b0)} =>	                         (X1.1;	                         transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : A &	                            H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0)	                                    X0.1) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                        =>	                        (X1.1;	                        transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b : B & R X0.1 b} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (fst bitot_R X0.1))) (snd X c)))	                 (fun	                    X : (forall a : B,	                         Tr (-1)	                           {b : C &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Tr (-1)	                           {a : B &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun	                        X0 : {b : B &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b)} =>	                         (X1.1;	                         transport trunctype_type 	                           (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : B &	                            H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0)	                                    X0.1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a : A & R a X0.1} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	        (f a) (g b)	  ============================	  {a0 : A & f a0 = g b}	";
            responses[i]=data;
          

            i = 338;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 339;
            data = "";
            responses[i]=data;
          

            i = 340;
            data = "";
            responses[i]=data;
          

            i = 341;
            data = "";
            responses[i]=data;
          

            i = 342;
            data = "";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "";
            responses[i]=data;
          

            i = 349;
            data = "<infomsg>ker_bisim is defined</infomsg>	";
            responses[i]=data;
          

            i = 350;
            data = "1 goal (ID 374)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall x y : A, f x = f y <~> ker_bisim f x y	";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "";
            responses[i]=data;
          

            i = 359;
            data = "<infomsg>u is declared</infomsg>	<infomsg>Au is declared</infomsg>	<infomsg>Au' is declared</infomsg>	<infomsg>h is declared</infomsg>	<infomsg>h' is declared</infomsg>	<infomsg>mu is declared</infomsg>	<infomsg>mono is declared</infomsg>	<infomsg>mu' is declared</infomsg>	<infomsg>mono' is declared</infomsg>	<infomsg>p is declared</infomsg>	<infomsg>p' is declared</infomsg>	";
            responses[i]=data;
          

            i = 360;
            data = "1 goal (ID 391)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  (forall a : Au, {a' : Au' & mu' a' = mu a}) *	  (forall a' : Au', {a : Au & mu a = mu' a'})	";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "2 goals (ID 393)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a : Au, {a' : Au' & mu' a' = mu a}		goal 2 (ID 394) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 363;
            data = "1 goal (ID 393)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a : Au, {a' : Au' & mu' a' = mu a}	1 goal (ID 395)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a : Au	  ============================	  {a' : Au' & mu' a' = mu a}	";
            responses[i]=data;
          

            i = 364;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 394) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 365;
            data = "1 goal (ID 394)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a' : Au', {a : Au & mu a = mu' a'}	1 goal (ID 418)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a' : Au'	  ============================	  {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 366;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 367;
            data = "";
            responses[i]=data;
          

            i = 368;
            data = "<infomsg>e is defined</infomsg>	";
            responses[i]=data;
          

            i = 369;
            data = "<infomsg>inv_e is defined</infomsg>	";
            responses[i]=data;
          

            i = 370;
            data = "1 goal (ID 414)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	  e o inv_e == idmap	";
            responses[i]=data;
          

            i = 371;
            data = "";
            responses[i]=data;
          

            i = 372;
            data = "1 goal (ID 416)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  e (inv_e a') = a'	";
            responses[i]=data;
          

            i = 373;
            data = "1 goal (ID 419)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu' a'	";
            responses[i]=data;
          

            i = 374;
            data = "2 goals (ID 432)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu (inv_e a')		goal 2 (ID 433) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 375;
            data = "1 goal (ID 432)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu (inv_e a')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 433) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 376;
            data = "1 goal (ID 433)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu (inv_e a') = mu' a'	No more goals.	";
            responses[i]=data;
          

            i = 377;
            data = "";
            responses[i]=data;
          

            i = 378;
            data = "1 goal (ID 427)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  ============================	  inv_e o e == idmap	";
            responses[i]=data;
          

            i = 379;
            data = "";
            responses[i]=data;
          

            i = 380;
            data = "1 goal (ID 429)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  a : Au	  ============================	  inv_e (e a) = a	";
            responses[i]=data;
          

            i = 381;
            data = "1 goal (ID 432)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  a : Au	  ============================	  mu (inv_e (e a)) = mu a	";
            responses[i]=data;
          

            i = 382;
            data = "2 goals (ID 445)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  a : Au	  ============================	  mu (inv_e (e a)) = mu' (e a)		goal 2 (ID 446) is:	 mu' (e a) = mu a	";
            responses[i]=data;
          

            i = 383;
            data = "1 goal (ID 445)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  a : Au	  ============================	  mu (inv_e (e a)) = mu' (e a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 446) is:	 mu' (e a) = mu a	";
            responses[i]=data;
          

            i = 384;
            data = "1 goal (ID 446)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  a : Au	  ============================	  mu' (e a) = mu a	No more goals.	";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "1 goal (ID 430)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  ============================	  Au' = Au	";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "1 goal (ID 434)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  ============================	  Au' <~> Au	";
            responses[i]=data;
          

            i = 389;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "1 goal (ID 439)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'	";
            responses[i]=data;
          

            i = 392;
            data = "";
            responses[i]=data;
          

            i = 393;
            data = "1 goal (ID 446)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu == mu'	";
            responses[i]=data;
          

            i = 394;
            data = "1 goal (ID 448)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' = mu' a'	";
            responses[i]=data;
          

            i = 395;
            data = "2 goals (ID 477)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' =	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))		goal 2 (ID 478) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	";
            responses[i]=data;
          

            i = 396;
            data = "1 goal (ID 477)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' =	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 478) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	";
            responses[i]=data;
          

            i = 397;
            data = "1 goal (ID 478)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu' a'	2 goals (ID 505)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu (transport idmap (path^)^ a')		goal 2 (ID 506) is:	 mu (transport idmap (path^)^ a') = mu' a'	";
            responses[i]=data;
          

            i = 398;
            data = "1 goal (ID 505)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu (transport idmap (path^)^ a')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 506) is:	 mu (transport idmap (path^)^ a') = mu' a'	";
            responses[i]=data;
          

            i = 399;
            data = "1 goal (ID 506)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu' a'	2 goals (ID 523)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')		goal 2 (ID 524) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 400;
            data = "1 goal (ID 523)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')	";
            responses[i]=data;
          

            i = 401;
            data = "1 goal (ID 535)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = inv_e a'	";
            responses[i]=data;
          

            i = 402;
            data = "2 goals (ID 552)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = transport idmap path a'		goal 2 (ID 553) is:	 transport idmap path a' = inv_e a'	";
            responses[i]=data;
          

            i = 403;
            data = "1 goal (ID 552)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = transport idmap path a'	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 553) is:	 transport idmap path a' = inv_e a'	";
            responses[i]=data;
          

            i = 404;
            data = "1 goal (ID 553)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap path a' = inv_e a'	No more goals.	";
            responses[i]=data;
          

            i = 405;
            data = "";
            responses[i]=data;
          

            i = 406;
            data = "1 goal (ID 467)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  (Au; mu; (h, mono, p)) = (Au'; mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 407;
            data = "";
            responses[i]=data;
          

            i = 408;
            data = "1 goal (ID 470)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  {p0 : Au = Au' &	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    p0 (mu; (h, mono, p)) = (mu'; (h', mono', p'))}	";
            responses[i]=data;
          

            i = 409;
            data = "1 goal (ID 475)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 410;
            data = "2 goals (ID 517)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) =	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p))		goal 2 (ID 518) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 411;
            data = "1 goal (ID 517)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) =	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 518) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 412;
            data = "1 goal (ID 518)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p)) = (mu'; (h', mono', p'))	1 goal (ID 642)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : e o inv_e == idmap	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : inv_e o e == idmap	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'	";
            responses[i]=data;
          

            i = 413;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "";
            responses[i]=data;
          

            i = 416;
            data = "";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 goal (ID 382)	  	  ua : Univalence	  ============================	  forall u : V,	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}	";
            responses[i]=data;
          

            i = 421;
            data = "";
            responses[i]=data;
          

            i = 422;
            data = "2 goals (ID 383)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		goal 2 (ID 384) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 423;
            data = "1 goal (ID 383)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}	1 goal (ID 388)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}	";
            responses[i]=data;
          

            i = 424;
            data = "1 goal (ID 423)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  {Au0 : Type &	  {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (set f = set m)}}	";
            responses[i]=data;
          

            i = 425;
            data = "1 goal (ID 427)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  IsHSet Au * IsEmbedding mu * (set f = set mu)	";
            responses[i]=data;
          

            i = 426;
            data = "1 goal (ID 430)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  set f = set mu	";
            responses[i]=data;
          

            i = 427;
            data = "2 goals (ID 437)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)		goal 2 (ID 438) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	";
            responses[i]=data;
          

            i = 428;
            data = "1 goal (ID 437)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)	1 goal (ID 439)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  hexists (fun b : Au => f a = mu b)	";
            responses[i]=data;
          

            i = 429;
            data = "1 goal (ID 444)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  f a = mu (eu a)	";
            responses[i]=data;
          

            i = 430;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 438) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	goal 2 (ID 384) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 431;
            data = "1 goal (ID 438)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall b : Au, hexists (fun a : A => f a = mu b)	1 goal (ID 449)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  hexists (fun a : A => f a = mu a')	";
            responses[i]=data;
          

            i = 432;
            data = "1 goal (ID 450)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  IsConnected (Tr (-1)) (hfiber eu a') -> hexists (fun a : A => f a = mu a')	";
            responses[i]=data;
          

            i = 433;
            data = "1 goal (ID 468)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  ============================	  hfiber eu a' -> {a : A & f a = mu a'}	";
            responses[i]=data;
          

            i = 434;
            data = "1 goal (ID 473)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  {a0 : A & f a0 = mu a'}	";
            responses[i]=data;
          

            i = 435;
            data = "1 goal (ID 475)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu a'	";
            responses[i]=data;
          

            i = 436;
            data = "2 goals (ID 488)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu (eu a)		goal 2 (ID 489) is:	 mu (eu a) = mu a'	";
            responses[i]=data;
          

            i = 437;
            data = "1 goal (ID 488)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu (eu a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 489) is:	 mu (eu a) = mu a'	goal 2 (ID 384) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 438;
            data = "1 goal (ID 489)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsConnMap (Tr (-1)) eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : IsConnected (Tr (-1)) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  mu (eu a) = mu a'	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 384) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 439;
            data = "1 goal (ID 384)	  	  ua : Univalence	  ============================	  forall v : V,	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	1 goal (ID 498)	  	  ua : Univalence	  v : V	  ============================	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 440;
            data = "1 goal (ID 499)	  	  ua : Univalence	  v : V	  ============================	  forall	  x y : {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}},	  x = y	";
            responses[i]=data;
          

            i = 441;
            data = "1 goal (ID 516)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  ============================	  forall	  y : {Au0 : Type &	      {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (v = set m)}},	  (Au; mu; (hset, mono, p)) = y	";
            responses[i]=data;
          

            i = 442;
            data = "1 goal (ID 533)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  Au' : Type	  mu' : Au' -> V	  hset' : IsHSet Au'	  mono' : IsEmbedding mu'	  p' : v = set mu'	  ============================	  (Au; mu; (hset, mono, p)) = (Au'; mu'; (hset', mono', p'))	";
            responses[i]=data;
          

            i = 443;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "<infomsg>type_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 446;
            data = "";
            responses[i]=data;
          

            i = 447;
            data = "<infomsg>func_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 448;
            data = "<infomsg>is_hset_typeofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 449;
            data = "<infomsg>IsEmbedding_funcofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 450;
            data = "<infomsg>is_valid_presentation is defined</infomsg>	";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "";
            responses[i]=data;
          

            i = 455;
            data = "";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "1 goal (ID 420)	  	  ua : Univalence	  ============================	  forall x y : V, x ⊆ y * y ⊆ x <-> x = y	";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "1 goal (ID 587)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall (a : A) (y : V), f a ⊆ y * y ⊆ f a <-> f a = y) ->	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y	";
            responses[i]=data;
          

            i = 461;
            data = "1 goal (ID 591)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y	";
            responses[i]=data;
          

            i = 462;
            data = "1 goal (ID 728)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, set f ⊆ f0 a * f0 a ⊆ set f <-> set f = f0 a) ->	  set f ⊆ set f0 * set f0 ⊆ set f <-> set f = set f0	";
            responses[i]=data;
          

            i = 463;
            data = "1 goal (ID 732)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f <-> set f = set g	";
            responses[i]=data;
          

            i = 464;
            data = "2 goals (ID 734)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g		goal 2 (ID 735) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 465;
            data = "1 goal (ID 734)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g	1 goal (ID 740)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 466;
            data = "1 goal (ID 743)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 467;
            data = "2 goals (ID 745)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		goal 2 (ID 746) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 468;
            data = "1 goal (ID 745)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 goal (ID 747)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 469;
            data = "1 goal (ID 764)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  {a0 : B & g a0 = f a} -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 470;
            data = "1 goal (ID 769)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  hexists (fun b0 : B => f a = g b0)	";
            responses[i]=data;
          

            i = 471;
            data = "1 goal (ID 772)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 472;
            data = "1 goal (ID 774)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 473;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 746) is:	 forall b : B, hexists (fun a : A => f a = g b)	goal 2 (ID 735) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 474;
            data = "1 goal (ID 746)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 goal (ID 778)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 475;
            data = "1 goal (ID 779)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  g b ∈ set g	";
            responses[i]=data;
          

            i = 476;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 735) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 477;
            data = "1 goal (ID 735)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f = set g -> set f ⊆ set g * set g ⊆ set f	2 goals (ID 788)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g		goal 2 (ID 789) is:	 set g ⊆ set f	";
            responses[i]=data;
          

            i = 478;
            data = "1 goal (ID 788)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g	1 goal (ID 792)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set f	  ============================	  z ∈ set g	";
            responses[i]=data;
          

            i = 479;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 789) is:	 set g ⊆ set f	";
            responses[i]=data;
          

            i = 480;
            data = "1 goal (ID 789)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set g ⊆ set f	1 goal (ID 799)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set g	  ============================	  z ∈ set f	";
            responses[i]=data;
          

            i = 481;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "1 goal (ID 425)	  	  ua : Univalence	  C : V -> hProp	  ============================	  (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v	";
            responses[i]=data;
          

            i = 484;
            data = "";
            responses[i]=data;
          

            i = 485;
            data = "1 goal (ID 426)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall v : V, C v	";
            responses[i]=data;
          

            i = 486;
            data = "1 goal (ID 449)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall (A : Type) (f : A -> V), (forall a : A, C (f a)) -> C (set f)	";
            responses[i]=data;
          

            i = 487;
            data = "1 goal (ID 452)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  C (set f)	";
            responses[i]=data;
          

            i = 488;
            data = "1 goal (ID 453)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  forall x : V, x ∈ set f -> C x	";
            responses[i]=data;
          

            i = 489;
            data = "1 goal (ID 455)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  C x	";
            responses[i]=data;
          

            i = 490;
            data = "1 goal (ID 465)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  {a : A & f a = x} -> C x	";
            responses[i]=data;
          

            i = 491;
            data = "1 goal (ID 470)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  a : A	  p : f a = x	  ============================	  C x	";
            responses[i]=data;
          

            i = 492;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "";
            responses[i]=data;
          

            i = 497;
            data = "";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "";
            responses[i]=data;
          

            i = 501;
            data = "1 goal (ID 427)	  	  ua : Univalence	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)	";
            responses[i]=data;
          

            i = 502;
            data = "";
            responses[i]=data;
          

            i = 503;
            data = "2 goals (ID 430)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)		goal 2 (ID 431) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	";
            responses[i]=data;
          

            i = 504;
            data = "1 goal (ID 430)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	1 goal (ID 432)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	";
            responses[i]=data;
          

            i = 505;
            data = "1 goal (ID 433)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (~ v ∈ v)	";
            responses[i]=data;
          

            i = 506;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 431) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	1 goal (ID 431)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)	1 goal (ID 473)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  forall v : V, (forall x : V, x ∈ v -> ~ x ∈ x) -> ~ v ∈ v	";
            responses[i]=data;
          

            i = 507;
            data = "1 goal (ID 475)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  ============================	  ~ v ∈ v	";
            responses[i]=data;
          

            i = 508;
            data = "1 goal (ID 477)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  Hv : v ∈ v	  ============================	  Empty	";
            responses[i]=data;
          

            i = 509;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 510;
            data = "";
            responses[i]=data;
          

            i = 511;
            data = "1 goal (ID 441)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	  set f = set g -> equal_img f g	";
            responses[i]=data;
          

            i = 512;
            data = "";
            responses[i]=data;
          

            i = 513;
            data = "1 goal (ID 442)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 514;
            data = "2 goals (ID 444)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		goal 2 (ID 445) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 515;
            data = "1 goal (ID 444)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 goal (ID 446)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 516;
            data = "2 goals (ID 448)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g		goal 2 (ID 449) is:	 hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 517;
            data = "1 goal (ID 448)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g	1 goal (ID 457)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set f	";
            responses[i]=data;
          

            i = 518;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 449) is:	 hexists (fun b : B => f a = g b)	goal 2 (ID 445) is:	 forall b : B, hexists (fun a : A => f a = g b)	1 goal (ID 449)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  hexists (fun b : B => f a = g b)	1 goal (ID 467)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  {a0 : B & g a0 = f a} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 519;
            data = "1 goal (ID 472)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  b : B	  p' : g b = f a	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 520;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 445) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 521;
            data = "1 goal (ID 445)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 goal (ID 478)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 522;
            data = "2 goals (ID 480)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f		goal 2 (ID 481) is:	 hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 523;
            data = "1 goal (ID 480)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f	1 goal (ID 492)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set g	";
            responses[i]=data;
          

            i = 524;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 481) is:	 hexists (fun a : A => f a = g b)	1 goal (ID 481)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  hexists (fun a : A => f a = g b)	1 goal (ID 502)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  {a : A & f a = g b} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 525;
            data = "1 goal (ID 507)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = g b}	";
            responses[i]=data;
          

            i = 526;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 527;
            data = "";
            responses[i]=data;
          

            i = 528;
            data = "";
            responses[i]=data;
          

            i = 529;
            data = "";
            responses[i]=data;
          

            i = 530;
            data = "";
            responses[i]=data;
          

            i = 531;
            data = "";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "<infomsg>V_empty is defined</infomsg>	";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "<infomsg>V_singleton is defined</infomsg>	";
            responses[i]=data;
          

            i = 543;
            data = "1 goal (ID 454)	  	  ua : Univalence	  u, v : V	  ============================	  IsEquiv (ap V_singleton)	";
            responses[i]=data;
          

            i = 544;
            data = "";
            responses[i]=data;
          

            i = 545;
            data = "1 goal (ID 462)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v	";
            responses[i]=data;
          

            i = 546;
            data = "1 goal (ID 462)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v	1 goal (ID 611)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  u = v	";
            responses[i]=data;
          

            i = 547;
            data = "1 goal (ID 616)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  equal_img (Unit_ind u) (Unit_ind v) -> u = v	";
            responses[i]=data;
          

            i = 548;
            data = "1 goal (ID 622)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  u = v	";
            responses[i]=data;
          

            i = 549;
            data = "1 goal (ID 646)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  {b : Unit & Unit_ind u tt = Unit_ind v b} -> u = v	";
            responses[i]=data;
          

            i = 550;
            data = "1 goal (ID 651)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  t : Unit	  p : Unit_ind u tt = Unit_ind v t	  ============================	  u = v	";
            responses[i]=data;
          

            i = 551;
            data = "No more goals.	No more goals.	";
            responses[i]=data;
          

            i = 552;
            data = "";
            responses[i]=data;
          

            i = 553;
            data = "";
            responses[i]=data;
          

            i = 554;
            data = "";
            responses[i]=data;
          

            i = 555;
            data = "";
            responses[i]=data;
          

            i = 556;
            data = "<infomsg>V_pair is defined</infomsg>	";
            responses[i]=data;
          

            i = 557;
            data = "1 goal (ID 466)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	  (u = u') * (v = v') -> V_pair u v = V_pair u' v'	";
            responses[i]=data;
          

            i = 558;
            data = "";
            responses[i]=data;
          

            i = 559;
            data = "1 goal (ID 471)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  V_pair u v = V_pair u' v'	";
            responses[i]=data;
          

            i = 560;
            data = "1 goal (ID 474)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  equal_img (fun b : Bool => if b then u else v)	    (fun b : Bool => if b then u' else v')	";
            responses[i]=data;
          

            i = 561;
            data = "2 goals (ID 476)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		goal 2 (ID 477) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 562;
            data = "1 goal (ID 476)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))	2 goals (ID 478)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => u = (if b then u' else v'))		goal 2 (ID 479) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 563;
            data = "1 goal (ID 478)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => u = (if b then u' else v'))	1 goal (ID 484)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  u = u'	";
            responses[i]=data;
          

            i = 564;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 479) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	goal 2 (ID 477) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 565;
            data = "1 goal (ID 479)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => v = (if b then u' else v'))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 477) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 566;
            data = "1 goal (ID 477)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall b : Bool,	  hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	2 goals (ID 490)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = u')		goal 2 (ID 491) is:	 hexists (fun a : Bool => (if a then u else v) = v')	";
            responses[i]=data;
          

            i = 567;
            data = "1 goal (ID 490)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = u')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 491) is:	 hexists (fun a : Bool => (if a then u else v) = v')	";
            responses[i]=data;
          

            i = 568;
            data = "1 goal (ID 491)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = v')	No more goals.	";
            responses[i]=data;
          

            i = 569;
            data = "";
            responses[i]=data;
          

            i = 570;
            data = "1 goal (ID 476)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w <-> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 571;
            data = "";
            responses[i]=data;
          

            i = 572;
            data = "2 goals (ID 478)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)		goal 2 (ID 479) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 573;
            data = "1 goal (ID 478)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)	1 goal (ID 480)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 574;
            data = "1 goal (ID 490)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 575;
            data = "1 goal (ID 550)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  {b : Unit & u = Unit_ind w b} -> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 576;
            data = "1 goal (ID 561)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 577;
            data = "1 goal (ID 621)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  {b : Unit & v = Unit_ind w b} -> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 578;
            data = "1 goal (ID 632)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  p' : v = Unit_ind w tt	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 579;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 479) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 580;
            data = "1 goal (ID 479)	  	  ua : Univalence	  u, v, w : V	  ============================	  (u = w) * (v = w) -> V_pair u v = V_singleton w	1 goal (ID 640)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 581;
            data = "2 goals (ID 645)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall a : Bool,	  hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)		goal 2 (ID 646) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	";
            responses[i]=data;
          

            i = 582;
            data = "1 goal (ID 645)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall a : Bool,	  hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	1 goal (ID 652)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  a : Bool	  ============================	  (if a then u else v) = Unit_ind w tt	";
            responses[i]=data;
          

            i = 583;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 646) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	";
            responses[i]=data;
          

            i = 584;
            data = "1 goal (ID 646)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall b : Unit,	  hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	1 goal (ID 663)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  t : Unit	  ============================	  u = Unit_ind w t	";
            responses[i]=data;
          

            i = 585;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 586;
            data = "";
            responses[i]=data;
          

            i = 587;
            data = "";
            responses[i]=data;
          

            i = 588;
            data = "";
            responses[i]=data;
          

            i = 589;
            data = "";
            responses[i]=data;
          

            i = 590;
            data = "";
            responses[i]=data;
          

            i = 591;
            data = "<infomsg>V_pair_ord is defined</infomsg>	";
            responses[i]=data;
          

            i = 592;
            data = "";
            responses[i]=data;
          

            i = 593;
            data = "1 goal (ID 487)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] <-> (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "2 goals (ID 489)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)		goal 2 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 596;
            data = "1 goal (ID 489)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)	1 goal (ID 491)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 597;
            data = "2 goals (ID 494)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c		goal 2 (ID 495) is:	 (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 598;
            data = "1 goal (ID 494)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c	2 goals (ID 496)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]		goal 2 (ID 497) is:	 a = c	";
            responses[i]=data;
          

            i = 599;
            data = "1 goal (ID 496)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]	1 goal (ID 505)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [a, b]	";
            responses[i]=data;
          

            i = 600;
            data = "1 goal (ID 507)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  Tr (-1)	    {a0 : Bool & (if a0 then V_singleton a else V_pair a b) = V_singleton a}	";
            responses[i]=data;
          

            i = 601;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 497) is:	 a = c	goal 2 (ID 495) is:	 (a = c) * (b = d)	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 goal (ID 497)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  a = c	1 goal (ID 538)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_singleton a} ->	  a = c	";
            responses[i]=data;
          

            i = 602;
            data = "2 goals (ID 552)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	  a = c		goal 2 (ID 553) is:	 a = c	";
            responses[i]=data;
          

            i = 603;
            data = "1 goal (ID 552)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 553) is:	 a = c	goal 2 (ID 495) is:	 (a = c) * (b = d)	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 604;
            data = "1 goal (ID 553)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_pair c d = V_singleton a	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 495) is:	 (a = c) * (b = d)	goal 2 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 605;
            data = "1 goal (ID 495)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  (a = c) * (b = d)	2 goals (ID 585)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  a = c		goal 2 (ID 586) is:	 b = d	";
            responses[i]=data;
          

            i = 606;
            data = "1 goal (ID 585)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 586) is:	 b = d	goal 2 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 607;
            data = "1 goal (ID 586)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = d	2 goals (ID 591)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = c \/ b = d		goal 2 (ID 592) is:	 b = d	";
            responses[i]=data;
          

            i = 608;
            data = "1 goal (ID 591)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = c \/ b = d	2 goals (ID 593)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]		goal 2 (ID 594) is:	 b = c \/ b = d	";
            responses[i]=data;
          

            i = 609;
            data = "1 goal (ID 593)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]	1 goal (ID 602)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [a, b]	";
            responses[i]=data;
          

            i = 610;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 594) is:	 b = c \/ b = d	goal 2 (ID 592) is:	 b = d	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 goal (ID 594)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  b = c \/ b = d	1 goal (ID 616)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_pair a b} ->	  b = c \/ b = d	";
            responses[i]=data;
          

            i = 611;
            data = "2 goals (ID 630)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c \/ b = d		goal 2 (ID 631) is:	 b = c \/ b = d	";
            responses[i]=data;
          

            i = 612;
            data = "1 goal (ID 630)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c \/ b = d	1 goal (ID 636)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c	";
            responses[i]=data;
          

            i = 613;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 631) is:	 b = c \/ b = d	goal 2 (ID 592) is:	 b = d	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 614;
            data = "1 goal (ID 631)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  ============================	  b = c \/ b = d	1 goal (ID 658)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  b = c \/ b = d	";
            responses[i]=data;
          

            i = 615;
            data = "1 goal (ID 662)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  {a0 : Bool & (if a0 then c else d) = b} -> (b = c) + (b = d)	";
            responses[i]=data;
          

            i = 616;
            data = "2 goals (ID 676)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	  (b = c) + (b = d)		goal 2 (ID 677) is:	 (b = c) + (b = d)	";
            responses[i]=data;
          

            i = 617;
            data = "1 goal (ID 676)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	  (b = c) + (b = d)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 677) is:	 (b = c) + (b = d)	goal 2 (ID 592) is:	 b = d	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 618;
            data = "1 goal (ID 677)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : d = b	  ============================	  (b = c) + (b = d)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 592) is:	 b = d	goal 2 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 goal (ID 592)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  ============================	  b = d	1 goal (ID 711)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  ============================	  (b = c) + (b = d) -> b = d	";
            responses[i]=data;
          

            i = 619;
            data = "2 goals (ID 718)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  b = d		goal 2 (ID 719) is:	 b = d	";
            responses[i]=data;
          

            i = 620;
            data = "1 goal (ID 718)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  b = d	";
            responses[i]=data;
          

            i = 621;
            data = "2 goals (ID 722)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)		goal 2 (ID 723) is:	 b = d	";
            responses[i]=data;
          

            i = 622;
            data = "1 goal (ID 722)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)	1 goal (ID 729)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  (V_singleton a = V_singleton b) * (V_pair a b = V_singleton b)	";
            responses[i]=data;
          

            i = 623;
            data = "2 goals (ID 731)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_singleton a = V_singleton b		goal 2 (ID 732) is:	 V_pair a b = V_singleton b	";
            responses[i]=data;
          

            i = 624;
            data = "1 goal (ID 731)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_singleton a = V_singleton b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 732) is:	 V_pair a b = V_singleton b	goal 2 (ID 723) is:	 b = d	goal 3 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 625;
            data = "1 goal (ID 732)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_pair a b = V_singleton b	1 goal (ID 748)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  (a = b) * (b = b)	";
            responses[i]=data;
          

            i = 626;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 723) is:	 b = d	goal 2 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 627;
            data = "1 goal (ID 723)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  ============================	  b = d	1 goal (ID 763)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  H'' : V_pair c d = V_singleton b	  ============================	  b = d	";
            responses[i]=data;
          

            i = 628;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 490) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 629;
            data = "1 goal (ID 490)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  (a = c) * (b = d) -> [a, b] = [c, d]	1 goal (ID 803)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 630;
            data = "1 goal (ID 808)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (V_singleton a = V_singleton c) * (V_pair a b = V_pair c d)	";
            responses[i]=data;
          

            i = 631;
            data = "2 goals (ID 810)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_singleton a = V_singleton c		goal 2 (ID 811) is:	 V_pair a b = V_pair c d	";
            responses[i]=data;
          

            i = 632;
            data = "1 goal (ID 810)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_singleton a = V_singleton c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 811) is:	 V_pair a b = V_pair c d	";
            responses[i]=data;
          

            i = 633;
            data = "1 goal (ID 811)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_pair a b = V_pair c d	1 goal (ID 819)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 634;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 635;
            data = "";
            responses[i]=data;
          

            i = 636;
            data = "";
            responses[i]=data;
          

            i = 637;
            data = "";
            responses[i]=data;
          

            i = 638;
            data = "";
            responses[i]=data;
          

            i = 639;
            data = "";
            responses[i]=data;
          

            i = 640;
            data = "<infomsg>V_cart_prod is defined</infomsg>	";
            responses[i]=data;
          

            i = 641;
            data = "";
            responses[i]=data;
          

            i = 642;
            data = "";
            responses[i]=data;
          

            i = 643;
            data = "";
            responses[i]=data;
          

            i = 644;
            data = "";
            responses[i]=data;
          

            i = 645;
            data = "";
            responses[i]=data;
          

            i = 646;
            data = "";
            responses[i]=data;
          

            i = 647;
            data = "";
            responses[i]=data;
          

            i = 648;
            data = "";
            responses[i]=data;
          

            i = 649;
            data = "";
            responses[i]=data;
          

            i = 650;
            data = "";
            responses[i]=data;
          

            i = 651;
            data = "<infomsg>V_func is defined</infomsg>	";
            responses[i]=data;
          

            i = 652;
            data = "";
            responses[i]=data;
          

            i = 653;
            data = "";
            responses[i]=data;
          

            i = 654;
            data = "";
            responses[i]=data;
          

            i = 655;
            data = "";
            responses[i]=data;
          

            i = 656;
            data = "<infomsg>V_union is defined</infomsg>	";
            responses[i]=data;
          

            i = 657;
            data = "";
            responses[i]=data;
          

            i = 658;
            data = "";
            responses[i]=data;
          

            i = 659;
            data = "";
            responses[i]=data;
          

            i = 660;
            data = "";
            responses[i]=data;
          

            i = 661;
            data = "1 goal (ID 507)	  	  ua : Univalence	  ============================	  V -> V	";
            responses[i]=data;
          

            i = 662;
            data = "";
            responses[i]=data;
          

            i = 663;
            data = "2 goals (ID 513)	  	  ua : Univalence	  ============================	  forall A : Type, (A -> V) -> (A -> V) -> V		goal 2 (ID 515) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g -> ?H_set A f H_f = ?H_set B g H_g	";
            responses[i]=data;
          

            i = 664;
            data = "1 goal (ID 513)	  	  ua : Univalence	  ============================	  forall A : Type, (A -> V) -> (A -> V) -> V	1 goal (ID 519)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  V	";
            responses[i]=data;
          

            i = 665;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 515) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 _ : A0 -> V) =>	  set	    (fun x : A0 + Unit => match x with	                          | inl a => f0 a	                          | inr tt => set f0	                          end)) A f H_f =	 (fun (A0 : Type) (f0 _ : A0 -> V) =>	  set	    (fun x : A0 + Unit => match x with	                          | inl a => f0 a	                          | inr tt => set f0	                          end)) B g H_g	";
            responses[i]=data;
          

            i = 666;
            data = "1 goal (ID 515)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V) (H_g : B -> V),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) A f H_f =	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) B g H_g	1 goal (ID 533)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set (fun x : A + Unit => match x with	                           | inl a => f a	                           | inr tt => set f	                           end) =	  set (fun x : B + Unit => match x with	                           | inl a => g a	                           | inr tt => set g	                           end)	";
            responses[i]=data;
          

            i = 667;
            data = "1 goal (ID 536)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  equal_img	    (fun x : A + Unit => match x with	                         | inl a => f a	                         | inr tt => set f	                         end)	    (fun x : B + Unit => match x with	                         | inl a => g a	                         | inr tt => set g	                         end)	";
            responses[i]=data;
          

            i = 668;
            data = "2 goals (ID 538)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		goal 2 (ID 539) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 669;
            data = "1 goal (ID 538)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 goal (ID 540)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A + Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 670;
            data = "2 goals (ID 546)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		goal 2 (ID 547) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 671;
            data = "1 goal (ID 546)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 goal (ID 550)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists (fun b : B => f a = g b) ->	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 672;
            data = "1 goal (ID 553)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  {b : B & f a = g b} ->	  {b : B + Unit & f a = match b with	                        | inl a0 => g a0	                        | inr tt => set g	                        end}	";
            responses[i]=data;
          

            i = 673;
            data = "1 goal (ID 558)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  b : B	  p : f a = g b	  ============================	  {b0 : B + Unit &	  f a = match b0 with	        | inl a0 => g a0	        | inr tt => set g	        end}	";
            responses[i]=data;
          

            i = 674;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 547) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	goal 2 (ID 539) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 675;
            data = "1 goal (ID 547)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match u with	     | tt => set f	     end = match b with	           | inl a => g a	           | inr tt => set g	           end)	1 goal (ID 569)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  match u with	  | tt => set f	  end = set g	";
            responses[i]=data;
          

            i = 676;
            data = "1 goal (ID 572)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 677;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 539) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 678;
            data = "1 goal (ID 539)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall b : B + Unit,	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 goal (ID 576)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B + Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 679;
            data = "2 goals (ID 582)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)		goal 2 (ID 583) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	";
            responses[i]=data;
          

            i = 680;
            data = "1 goal (ID 582)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)	1 goal (ID 586)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists (fun a : A => f a = g b) ->	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)	";
            responses[i]=data;
          

            i = 681;
            data = "1 goal (ID 589)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  {a : A & f a = g b} ->	  {a : A + Unit & match a with	                  | inl a0 => f a0	                  | inr tt => set f	                  end = g b}	";
            responses[i]=data;
          

            i = 682;
            data = "1 goal (ID 594)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  a : A	  p : f a = g b	  ============================	  {a0 : A + Unit &	  match a0 with	  | inl a1 => f a1	  | inr tt => set f	  end = g b}	";
            responses[i]=data;
          

            i = 683;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 583) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	";
            responses[i]=data;
          

            i = 684;
            data = "1 goal (ID 583)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match u with	           | tt => set g	           end)	1 goal (ID 605)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  set f = match u with	          | tt => set g	          end	";
            responses[i]=data;
          

            i = 685;
            data = "1 goal (ID 608)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 686;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 687;
            data = "";
            responses[i]=data;
          

            i = 688;
            data = "";
            responses[i]=data;
          

            i = 689;
            data = "";
            responses[i]=data;
          

            i = 690;
            data = "";
            responses[i]=data;
          

            i = 691;
            data = "";
            responses[i]=data;
          

            i = 692;
            data = "<infomsg>V_omega is defined</infomsg>	";
            responses[i]=data;
          

            i = 693;
            data = "";
            responses[i]=data;
          

            i = 694;
            data = "";
            responses[i]=data;
          

            i = 695;
            data = "";
            responses[i]=data;
          

            i = 696;
            data = "";
            responses[i]=data;
          

            i = 697;
            data = "";
            responses[i]=data;
          

            i = 698;
            data = "";
            responses[i]=data;
          

            i = 699;
            data = "";
            responses[i]=data;
          

            i = 700;
            data = "1 goal (ID 512)	  	  ua : Univalence	  ============================	  forall x : V, ~ x ∈ V_empty	";
            responses[i]=data;
          

            i = 701;
            data = "";
            responses[i]=data;
          

            i = 702;
            data = "1 goal (ID 515)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  Empty	";
            responses[i]=data;
          

            i = 703;
            data = "1 goal (ID 525)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  {a : Empty & Empty_ind (fun _ : Empty => V) a = x} -> Empty	";
            responses[i]=data;
          

            i = 704;
            data = "1 goal (ID 531)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ff : Empty	  ============================	  Empty	";
            responses[i]=data;
          

            i = 705;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 706;
            data = "";
            responses[i]=data;
          

            i = 707;
            data = "1 goal (ID 522)	  	  ua : Univalence	  ============================	  forall u v : V,	  hexists (fun w : V => forall x : V, x ∈ w <-> x = u \/ x = v)	";
            responses[i]=data;
          

            i = 708;
            data = "";
            responses[i]=data;
          

            i = 709;
            data = "1 goal (ID 524)	  	  ua : Univalence	  u, v : V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> x = u \/ x = v)	";
            responses[i]=data;
          

            i = 710;
            data = "1 goal (ID 527)	  	  ua : Univalence	  u, v : V	  ============================	  {w : V & forall x : V, x ∈ w <-> x = u \/ x = v}	";
            responses[i]=data;
          

            i = 711;
            data = "1 goal (ID 529)	  	  ua : Univalence	  u, v : V	  ============================	  forall x : V, x ∈ V_pair u v <-> x = u \/ x = v	";
            responses[i]=data;
          

            i = 712;
            data = "2 goals (ID 536)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		goal 2 (ID 539) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	";
            responses[i]=data;
          

            i = 713;
            data = "1 goal (ID 536)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 539) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	";
            responses[i]=data;
          

            i = 714;
            data = "1 goal (ID 539)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	No more goals.	";
            responses[i]=data;
          

            i = 715;
            data = "";
            responses[i]=data;
          

            i = 716;
            data = "1 goal (ID 524)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)	";
            responses[i]=data;
          

            i = 717;
            data = "";
            responses[i]=data;
          

            i = 718;
            data = "2 goals (ID 526)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega		goal 2 (ID 527) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 719;
            data = "1 goal (ID 526)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 527) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 720;
            data = "1 goal (ID 527)	  	  ua : Univalence	  ============================	  forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	1 goal (ID 533)	  	  ua : Univalence	  x : V	  ============================	  x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 721;
            data = "1 goal (ID 536)	  	  ua : Univalence	  x : V	  ============================	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = x} ->	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = V_succ x}	";
            responses[i]=data;
          

            i = 722;
            data = "1 goal (ID 541)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  {a : nat &	  (fix I (n0 : nat) : V :=	     match n0 with	     | 0 => V_empty	     | n1.+1 => V_succ (I n1)	     end) a = V_succ x}	";
            responses[i]=data;
          

            i = 723;
            data = "1 goal (ID 543)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  V_succ	    ((fix I (n0 : nat) : V :=	        match n0 with	        | 0 => V_empty	        | n1.+1 => V_succ (I n1)	        end) n) = V_succ x	";
            responses[i]=data;
          

            i = 724;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 725;
            data = "";
            responses[i]=data;
          

            i = 726;
            data = "";
            responses[i]=data;
          

            i = 727;
            data = "";
            responses[i]=data;
          

            i = 728;
            data = "";
            responses[i]=data;
          

            i = 729;
            data = "";
            responses[i]=data;
          

            i = 730;
            data = "";
            responses[i]=data;
          

            i = 731;
            data = "";
            responses[i]=data;
          

            i = 732;
            data = "";
            responses[i]=data;
          

            i = 733;
            data = "";
            responses[i]=data;
          

            i = 734;
            data = "";
            responses[i]=data;
          

            i = 735;
            data = "";
            responses[i]=data;
          

            i = 736;
            data = "";
            responses[i]=data;
          

            i = 737;
            data = "";
            responses[i]=data;
          

            i = 738;
            data = "";
            responses[i]=data;
          

            i = 739;
            data = "";
            responses[i]=data;
          

            i = 740;
            data = "";
            responses[i]=data;
          

            i = 741;
            data = "";
            responses[i]=data;
          

            i = 742;
            data = "";
            responses[i]=data;
          

            i = 743;
            data = "";
            responses[i]=data;
          

            i = 744;
            data = "";
            responses[i]=data;
          

            i = 745;
            data = "";
            responses[i]=data;
          

            i = 746;
            data = "";
            responses[i]=data;
          

            i = 747;
            data = "";
            responses[i]=data;
          

            i = 748;
            data = "";
            responses[i]=data;
          

            i = 749;
            data = "";
            responses[i]=data;
          

            i = 750;
            data = "";
            responses[i]=data;
          

            i = 751;
            data = "";
            responses[i]=data;
          

            i = 752;
            data = "";
            responses[i]=data;
          

            i = 753;
            data = "";
            responses[i]=data;
          

            i = 754;
            data = "";
            responses[i]=data;
          

            i = 755;
            data = "";
            responses[i]=data;
          

            i = 756;
            data = "";
            responses[i]=data;
          

            i = 757;
            data = "";
            responses[i]=data;
          

            i = 758;
            data = "";
            responses[i]=data;
          

            i = 759;
            data = "";
            responses[i]=data;
          

            i = 760;
            data = "";
            responses[i]=data;
          

            i = 761;
            data = "";
            responses[i]=data;
          

            i = 762;
            data = "";
            responses[i]=data;
          

            i = 763;
            data = "";
            responses[i]=data;
          

            i = 764;
            data = "";
            responses[i]=data;
          

            i = 765;
            data = "";
            responses[i]=data;
          

            i = 766;
            data = "";
            responses[i]=data;
          

            i = 767;
            data = "";
            responses[i]=data;
          

            i = 768;
            data = "";
            responses[i]=data;
          

            i = 769;
            data = "";
            responses[i]=data;
          

            i = 770;
            data = "";
            responses[i]=data;
          

            i = 771;
            data = "";
            responses[i]=data;
          

            i = 772;
            data = "";
            responses[i]=data;
          

            i = 773;
            data = "";
            responses[i]=data;
          

            i = 774;
            data = "";
            responses[i]=data;
          

            i = 775;
            data = "";
            responses[i]=data;
          

            i = 776;
            data = "";
            responses[i]=data;
          

            i = 777;
            data = "";
            responses[i]=data;
          

            i = 778;
            data = "";
            responses[i]=data;
          

            i = 779;
            data = "";
            responses[i]=data;
          

            i = 780;
            data = "";
            responses[i]=data;
          

            i = 781;
            data = "";
            responses[i]=data;
          

            i = 782;
            data = "";
            responses[i]=data;
          

            i = 783;
            data = "";
            responses[i]=data;
          

            i = 784;
            data = "";
            responses[i]=data;
          

            i = 785;
            data = "";
            responses[i]=data;
          

            i = 786;
            data = "";
            responses[i]=data;
          

            i = 787;
            data = "";
            responses[i]=data;
          

            i = 788;
            data = "";
            responses[i]=data;
          

            i = 789;
            data = "";
            responses[i]=data;
          

            i = 790;
            data = "";
            responses[i]=data;
          

            i = 791;
            data = "";
            responses[i]=data;
          

            i = 792;
            data = "";
            responses[i]=data;
          

            i = 793;
            data = "";
            responses[i]=data;
          

            i = 794;
            data = "";
            responses[i]=data;
          

            i = 795;
            data = "";
            responses[i]=data;
          

            i = 796;
            data = "";
            responses[i]=data;
          

            i = 797;
            data = "";
            responses[i]=data;
          

            i = 798;
            data = "";
            responses[i]=data;
          

            i = 799;
            data = "";
            responses[i]=data;
          

            i = 800;
            data = "";
            responses[i]=data;
          

            i = 801;
            data = "";
            responses[i]=data;
          

            i = 802;
            data = "";
            responses[i]=data;
          

            i = 803;
            data = "";
            responses[i]=data;
          

            i = 804;
            data = "";
            responses[i]=data;
          

            i = 805;
            data = "";
            responses[i]=data;
          

            i = 806;
            data = "";
            responses[i]=data;
          

            i = 807;
            data = "";
            responses[i]=data;
          

            i = 808;
            data = "";
            responses[i]=data;
          

            i = 809;
            data = "";
            responses[i]=data;
          

            i = 810;
            data = "";
            responses[i]=data;
          

            i = 811;
            data = "";
            responses[i]=data;
          

            i = 812;
            data = "";
            responses[i]=data;
          

            i = 813;
            data = "";
            responses[i]=data;
          

            i = 814;
            data = "";
            responses[i]=data;
          

            i = 815;
            data = "";
            responses[i]=data;
          

            i = 816;
            data = "";
            responses[i]=data;
          

            i = 817;
            data = "";
            responses[i]=data;
          

            i = 818;
            data = "";
            responses[i]=data;
          

            i = 819;
            data = "";
            responses[i]=data;
          

            i = 820;
            data = "";
            responses[i]=data;
          

            i = 821;
            data = "";
            responses[i]=data;
          

            i = 822;
            data = "";
            responses[i]=data;
          

            i = 823;
            data = "";
            responses[i]=data;
          

            i = 824;
            data = "";
            responses[i]=data;
          

            i = 825;
            data = "";
            responses[i]=data;
          

            i = 826;
            data = "";
            responses[i]=data;
          

            i = 827;
            data = "";
            responses[i]=data;
          

            i = 828;
            data = "";
            responses[i]=data;
          

            i = 829;
            data = "";
            responses[i]=data;
          

            i = 830;
            data = "";
            responses[i]=data;
          

            i = 831;
            data = "";
            responses[i]=data;
          

            i = 832;
            data = "";
            responses[i]=data;
          

            i = 833;
            data = "";
            responses[i]=data;
          

            i = 834;
            data = "";
            responses[i]=data;
          

            i = 835;
            data = "";
            responses[i]=data;
          

            i = 836;
            data = "";
            responses[i]=data;
          

            i = 837;
            data = "";
            responses[i]=data;
          

            i = 838;
            data = "";
            responses[i]=data;
          

            i = 839;
            data = "";
            responses[i]=data;
          

            i = 840;
            data = "";
            responses[i]=data;
          

            i = 841;
            data = "";
            responses[i]=data;
          

            i = 842;
            data = "";
            responses[i]=data;
          

            i = 843;
            data = "";
            responses[i]=data;
          

            i = 844;
            data = "";
            responses[i]=data;
          

            i = 845;
            data = "";
            responses[i]=data;
          

            i = 846;
            data = "";
            responses[i]=data;
          

            i = 847;
            data = "";
            responses[i]=data;
          

            i = 848;
            data = "";
            responses[i]=data;
          

            i = 849;
            data = "";
            responses[i]=data;
          

            i = 850;
            data = "";
            responses[i]=data;
          

            i = 851;
            data = "";
            responses[i]=data;
          

            i = 852;
            data = "";
            responses[i]=data;
          

            i = 853;
            data = "";
            responses[i]=data;
          

            i = 854;
            data = "";
            responses[i]=data;
          

            i = 855;
            data = "";
            responses[i]=data;
          

            i = 856;
            data = "";
            responses[i]=data;
          

            i = 857;
            data = "";
            responses[i]=data;
          

            i = 858;
            data = "";
            responses[i]=data;
          

            i = 859;
            data = "";
            responses[i]=data;
          

            i = 860;
            data = "";
            responses[i]=data;
          

            i = 861;
            data = "";
            responses[i]=data;
          

            i = 862;
            data = "1 goal (ID 529)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall a : V, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ a * C x)	";
            responses[i]=data;
          

            i = 863;
            data = "";
            responses[i]=data;
          

            i = 864;
            data = "1 goal (ID 548)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ f a * C x)) ->	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)	";
            responses[i]=data;
          

            i = 865;
            data = "1 goal (ID 552)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)	";
            responses[i]=data;
          

            i = 866;
            data = "1 goal (ID 555)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  {w : V & forall x : V, x ∈ w <-> x ∈ set f * C x}	";
            responses[i]=data;
          

            i = 867;
            data = "1 goal (ID 561)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  forall x : V,	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) <-> x ∈ set f * C x	";
            responses[i]=data;
          

            i = 868;
            data = "2 goals (ID 564)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> (x ∈ set f * C x)%type		goal 2 (ID 565) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 869;
            data = "1 goal (ID 564)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> (x ∈ set f * C x)%type	1 goal (ID 594)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  {a : {a : A & C (f a)} & f a.1 = x} -> (x ∈ set f * C x)%type	";
            responses[i]=data;
          

            i = 870;
            data = "1 goal (ID 603)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f * C x	";
            responses[i]=data;
          

            i = 871;
            data = "2 goals (ID 605)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f		goal 2 (ID 606) is:	 C x	1 goal (ID 605)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 606) is:	 C x	goal 2 (ID 565) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	1 goal (ID 606)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  C x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 565) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 872;
            data = "1 goal (ID 565)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	1 goal (ID 619)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 873;
            data = "1 goal (ID 620)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set f -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 874;
            data = "1 goal (ID 623)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  {a : A & f a = x} -> {a : {a : A & C (f a)} & f a.1 = x}	";
            responses[i]=data;
          

            i = 875;
            data = "1 goal (ID 628)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  {a0 : {a0 : A & C (f a0)} & f a0.1 = x}	";
            responses[i]=data;
          

            i = 876;
            data = "1 goal (ID 639)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  f (a; transport (fun x0 : V => C x0) p^ H2).1 = x	";
            responses[i]=data;
          

            i = 877;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 878;
            data = "";
            responses[i]=data;
          

            i = 879;
            data = "";
            responses[i]=data;
          

            i = 880;
            data = "";
            responses[i]=data;
          

            i = 881;
            data = "";
            responses[i]=data;
          

            i = 882;
            data = "";
            responses[i]=data;
          

            i = 883;
            data = "";
            responses[i]=data;
          

            i = 884;
            data = "";
            responses[i]=data;
          

            i = 885;
            data = "";
            responses[i]=data;
          

            i = 886;
            data = "";
            responses[i]=data;
          

            i = 887;
            data = "";
            responses[i]=data;
          

            i = 888;
            data = "";
            responses[i]=data;
          

            i = 889;
            data = "";
            responses[i]=data;
          

            i = 890;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.HIT.V</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<br>
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a id="lab468"></a><h1 class="section">The cumulative hierarchy <span class="inlinecode"><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a></span>.</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Basics.Utf8.html#"><span class="id" title="library">HoTT.Basics.Utf8</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" title="library">HSet</span></a> <a class="idref" href="HoTT.TruncType.html#"><span class="id" title="library">TruncType</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.SpanPushout.html#"><span class="id" title="library">Colimits.SpanPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Truncations.html#"><span class="id" title="library">HoTT.Truncations</span></a> <a class="idref" href="HoTT.Colimits.Quotient.html#"><span class="id" title="library">Colimits.Quotient</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Bitotal relation 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(23, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="bitotal" class="idref" href="#bitotal"><span class="id" title="definition">bitotal</span></a> {<a id="A:1" class="idref" href="#A:1"><span class="id" title="binder">A</span></a> <a id="B:2" class="idref" href="#B:2"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>} (<a id="R:3" class="idref" href="#R:3"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:1"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:2"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) :=<br>
   <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:4" class="idref" href="#a:4"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:1"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="b:5" class="idref" href="#b:5"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:2"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R:3"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a:4"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b:5"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:6" class="idref" href="#b:6"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:2"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="a:7" class="idref" href="#a:7"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:1"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R:3"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a:7"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b:6"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(24, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
<a id="lab469"></a><h2 class="section">The cumulative hierarchy V</h2>
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(31, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a id="CumulativeHierarchy" class="idref" href="#CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(32, '0_3_15');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a id="CumulativeHierarchy.V" class="idref" href="#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U'</span>} :=<br>
| <a id="CumulativeHierarchy.set" class="idref" href="#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> {<a id="A:10" class="idref" href="#A:10"><span class="id" title="binder">A</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U</span>}} (<a id="f:11" class="idref" href="#f:11"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:10"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V:8"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V:8"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(33, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a id="CumulativeHierarchy.setext" class="idref" href="#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">{</span></a><a id="A:12" class="idref" href="#A:12"><span class="id" title="binder">A</span></a> <a id="B:13" class="idref" href="#B:13"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>} (<a id="R:14" class="idref" href="#R:14"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:12"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:13"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<a id="bitot_R:15" class="idref" href="#bitot_R:15"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:14"><span class="id" title="variable">R</span></a>) (<a id="h:16" class="idref" href="#h:16"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:14"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:16"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:14"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:16"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:14"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(34, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a id="CumulativeHierarchy.is0trunc_V" class="idref" href="#CumulativeHierarchy.is0trunc_V"><span class="id" title="axiom">is0trunc_V</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(35, '0_3_15');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">is0trunc_V</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(36, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Fixpoint</span> <a id="CumulativeHierarchy.V_ind" class="idref" href="#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> (<a id="P:19" class="idref" href="#P:19"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:21" class="idref" href="#H_0trunc:21"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:20" class="idref" href="#v:20"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:20"><span class="id" title="variable">v</span></a>))<br>
  (<a id="H_set:26" class="idref" href="#H_set:26"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:22" class="idref" href="#A:22"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:23" class="idref" href="#f:23"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:22"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<a id="H_f:25" class="idref" href="#H_f:25"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:24" class="idref" href="#a:24"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:22"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:23"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:24"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:23"><span class="id" title="variable">f</span></a>))<br>
  (<a id="H_setext:34" class="idref" href="#H_setext:34"><span class="id" title="binder">H_setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:27" class="idref" href="#A:27"><span class="id" title="binder">A</span></a> <a id="B:28" class="idref" href="#B:28"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:29" class="idref" href="#R:29"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:28"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:30" class="idref" href="#bitot_R:30"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a>)<br>
    (<a id="h:31" class="idref" href="#h:31"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<a id="H_h:33" class="idref" href="#H_h:33"><span class="id" title="binder">H_h</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:32" class="idref" href="#x:32"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:31"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x:32"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:30"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:31"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:26"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:27"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:31"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:33"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:26"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:28"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:31"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:33"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:29"><span class="id" title="variable">R</span></a>) )<br>
  (<a id="v:35" class="idref" href="#v:35"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:35"><span class="id" title="variable">v</span></a><br>
:= (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#v:35"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br>
     | <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#H_set:26"><span class="id" title="variable">H_set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <a id="a:38" class="idref" href="#a:38"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_ind:36"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P:19"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:21"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:26"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:34"><span class="id" title="variable">H_setext</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a:38"><span class="id" title="variable">a</span></a>))<br>
    <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.HIT.V.html#H_setext:34"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:21"><span class="id" title="variable">H_0trunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(37, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncation 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(41, '0_3_19');
      ">
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(42, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="V_comp_setext" class="idref" href="#V_comp_setext"><span class="id" title="definition">V_comp_setext</span></a> (<a id="P:39" class="idref" href="#P:39"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:41" class="idref" href="#H_0trunc:41"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:40" class="idref" href="#v:40"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:40"><span class="id" title="variable">v</span></a>))<br>
  (<a id="H_set:46" class="idref" href="#H_set:46"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:42" class="idref" href="#A:42"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:43" class="idref" href="#f:43"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:42"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_f:45" class="idref" href="#H_f:45"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:44" class="idref" href="#a:44"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:42"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:43"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:44"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:43"><span class="id" title="variable">f</span></a>))<br>
  (<a id="H_setext:54" class="idref" href="#H_setext:54"><span class="id" title="binder">H_setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a> <a id="B:48" class="idref" href="#B:48"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:49" class="idref" href="#R:49"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:47"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:48"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:50" class="idref" href="#bitot_R:50"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a>)<br>
    (<a id="h:51" class="idref" href="#h:51"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_h:53" class="idref" href="#H_h:53"><span class="id" title="binder">H_h</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:52" class="idref" href="#x:52"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:51"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x:52"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:50"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:51"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:46"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:47"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:51"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:53"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:46"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:48"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:51"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:53"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:49"><span class="id" title="variable">R</span></a>) )<br>
  (<a id="A:55" class="idref" href="#A:55"><span class="id" title="binder">A</span></a> <a id="B:56" class="idref" href="#B:56"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:57" class="idref" href="#R:57"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:55"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:56"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:58" class="idref" href="#bitot_R:58"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:57"><span class="id" title="variable">R</span></a>) (<a id="h:59" class="idref" href="#h:59"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:57"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:41"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:46"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:54"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R:57"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:58"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:59"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:54"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A:55"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B:56"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R:57"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:58"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:59"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P:39"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:41"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:46"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:54"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#h:59"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(43, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(44, '0_3_19');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(45, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(46, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
The non-dependent eliminator 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(50, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="V_rec" class="idref" href="#V_rec"><span class="id" title="definition">V_rec</span></a> (<a id="P:60" class="idref" href="#P:60"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:61" class="idref" href="#H_0trunc:61"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P:60"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_set:63" class="idref" href="#H_set:63"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:62" class="idref" href="#A:62"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:62"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:62"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:60"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:60"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_setext:70" class="idref" href="#H_setext:70"><span class="id" title="binder">H_setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:64" class="idref" href="#A:64"><span class="id" title="binder">A</span></a> <a id="B:65" class="idref" href="#B:65"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:66" class="idref" href="#R:66"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:64"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:65"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:67" class="idref" href="#bitot_R:67"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a>)<br>
    (<a id="h:68" class="idref" href="#h:68"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_h:69" class="idref" href="#H_h:69"><span class="id" title="binder">H_h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:60"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set:63"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:64"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:68"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:69"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:63"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:65"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:68"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:69"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:66"><span class="id" title="variable">R</span></a>) )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:60"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(51, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(52, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(53, '0_3_23');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(54, '0_3_23');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">H_setext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(55, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(56, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="V_comp_nd_setext" class="idref" href="#V_comp_nd_setext"><span class="id" title="definition">V_comp_nd_setext</span></a> (<a id="P:71" class="idref" href="#P:71"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:72" class="idref" href="#H_0trunc:72"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_set:74" class="idref" href="#H_set:74"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:73" class="idref" href="#A:73"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:73"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:73"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_setext:81" class="idref" href="#H_setext:81"><span class="id" title="binder">H_setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:75" class="idref" href="#A:75"><span class="id" title="binder">A</span></a> <a id="B:76" class="idref" href="#B:76"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:77" class="idref" href="#R:77"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:75"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:76"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:78" class="idref" href="#bitot_R:78"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a>)<br>
    (<a id="h:79" class="idref" href="#h:79"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_h:80" class="idref" href="#H_h:80"><span class="id" title="binder">H_h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set:74"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:75"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:79"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:80"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:74"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:76"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h:79"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h:80"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R:77"><span class="id" title="variable">R</span></a>) )<br>
  (<a id="A:82" class="idref" href="#A:82"><span class="id" title="binder">A</span></a> <a id="B:83" class="idref" href="#B:83"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="R:84" class="idref" href="#R:84"><span class="id" title="binder">R</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:82"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B:83"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<a id="bitot_R:85" class="idref" href="#bitot_R:85"><span class="id" title="binder">bitot_R</span></a> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R:84"><span class="id" title="variable">R</span></a>) (<a id="h:86" class="idref" href="#h:86"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R:84"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:72"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:74"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:81"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R:84"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:85"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:86"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:81"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A:82"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B:83"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R:84"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R:85"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h:86"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P:71"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc:72"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set:74"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext:81"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#h:86"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(57, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(58, '0_3_23');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(59, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(60, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
<a id="lab470"></a><h2 class="section">Alternative induction principle (This is close to the one from the book)</h2>
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(67, '0_3_27');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="equal_img" class="idref" href="#equal_img"><span class="id" title="definition">equal_img</span></a> {<a id="A:87" class="idref" href="#A:87"><span class="id" title="binder">A</span></a> <a id="B:88" class="idref" href="#B:88"><span class="id" title="binder">B</span></a> <a id="C:89" class="idref" href="#C:89"><span class="id" title="binder">C</span></a> : <span class="id" title="keyword">Type</span>} (<a id="f:90" class="idref" href="#f:90"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:87"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C:89"><span class="id" title="variable">C</span></a>) (<a id="g:91" class="idref" href="#g:91"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:88"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C:89"><span class="id" title="variable">C</span></a>) :=<br>
   <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:92" class="idref" href="#a:92"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:87"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="b:93" class="idref" href="#b:93"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:88"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f:90"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:92"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g:91"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:93"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:94" class="idref" href="#b:94"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:88"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="a:95" class="idref" href="#a:95"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:87"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f:90"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:95"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g:91"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:94"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(68, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="setext'" class="idref" href="#setext'"><span class="id" title="definition">setext'</span></a> {<a id="A:96" class="idref" href="#A:96"><span class="id" title="binder">A</span></a> <a id="B:97" class="idref" href="#B:97"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>} (<a id="f:98" class="idref" href="#f:98"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:96"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="g:99" class="idref" href="#g:99"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:97"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="eq_img:100" class="idref" href="#eq_img:100"><span class="id" title="binder">eq_img</span></a> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f:98"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g:99"><span class="id" title="variable">g</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:98"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g:99"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(69, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(70, '0_3_27');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">R</span> := <span class="id" title="keyword">fun</span> <a id="a:103" class="idref" href="#a:103"><span class="id" title="binder">a</span></a> <a id="b:104" class="idref" href="#b:104"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a:101"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b:102"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(71, '0_3_27');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout_rec"><span class="id" title="definition">SPushout_rec</span></a> <span class="id" title="var">R</span> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a id="r:106" class="idref" href="#r:106"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#r:105"><span class="id" title="variable">r</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(72, '0_3_27');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <span class="id" title="var">R</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(73, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(74, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="V_rec'" class="idref" href="#V_rec'"><span class="id" title="definition">V_rec'</span></a> (<a id="P:107" class="idref" href="#P:107"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:108" class="idref" href="#H_0trunc:108"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_set:110" class="idref" href="#H_set:110"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:109" class="idref" href="#A:109"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:109"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A:109"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a>)<br>
  (<a id="H_setext':117" class="idref" href="#H_setext':117"><span class="id" title="binder">H_setext'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:111" class="idref" href="#A:111"><span class="id" title="binder">A</span></a> <a id="B:112" class="idref" href="#B:112"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:113" class="idref" href="#f:113"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:111"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="g:114" class="idref" href="#g:114"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:112"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f:113"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g:114"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="H_f:115" class="idref" href="#H_f:115"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:111"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a>) (<a id="H_g:116" class="idref" href="#H_g:116"><span class="id" title="binder">H_g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:112"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f:115"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g:116"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:110"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:111"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f:113"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f:115"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:110"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:112"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g:114"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g:116"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P:107"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(75, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(76, '0_3_27');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(77, '0_3_27');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(78, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <span class="id" title="var">H_setext'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(79, '0_3_27');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(80, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(81, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(82, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(89, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(90, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(91, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(92, '0_3_27');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(93, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(94, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(95, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(96, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(97, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(99, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(100, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(101, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(102, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(103, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(104, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(105, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(106, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(110, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_ind'" class="idref" href="#V_ind'"><span class="id" title="definition">V_ind'</span></a> (<a id="P:118" class="idref" href="#P:118"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_0trunc:120" class="idref" href="#H_0trunc:120"><span class="id" title="binder">H_0trunc</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:119" class="idref" href="#v:119"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:119"><span class="id" title="variable">v</span></a>))<br>
  (<a id="H_set:125" class="idref" href="#H_set:125"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:121" class="idref" href="#A:121"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:122" class="idref" href="#f:122"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:121"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_f:124" class="idref" href="#H_f:124"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:123" class="idref" href="#a:123"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:121"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:122"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:123"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:122"><span class="id" title="variable">f</span></a>))<br>
  (<a id="H_setext':142" class="idref" href="#H_setext':142"><span class="id" title="binder">H_setext'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:126" class="idref" href="#A:126"><span class="id" title="binder">A</span></a> <a id="B:127" class="idref" href="#B:127"><span class="id" title="binder">B</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:128" class="idref" href="#f:128"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:126"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="g:129" class="idref" href="#g:129"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:127"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
    (<a id="eq_img:130" class="idref" href="#eq_img:130"><span class="id" title="binder">eq_img</span></a>: <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a>)<br>
    (<a id="H_f:132" class="idref" href="#H_f:132"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:131" class="idref" href="#a:131"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:126"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:131"><span class="id" title="variable">a</span></a>)) (<a id="H_g:134" class="idref" href="#H_g:134"><span class="id" title="binder">H_g</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:133" class="idref" href="#b:133"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:127"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:133"><span class="id" title="variable">b</span></a>))<br>
    (<a id="H_eqimg:141" class="idref" href="#H_eqimg:141"><span class="id" title="binder">H_eqimg</span></a> : <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:135" class="idref" href="#a:135"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:126"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="b:136" class="idref" href="#b:136"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:127"><span class="id" title="variable">B</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="p:137" class="idref" href="#p:137"><span class="id" title="binder">p</span></a>:<a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:135"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:136"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p:137"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f:132"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:135"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g:134"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:136"><span class="id" title="variable">b</span></a>))<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
             <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:138" class="idref" href="#b:138"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:127"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="a:139" class="idref" href="#a:139"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:126"><span class="id" title="variable">A</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<a id="p:140" class="idref" href="#p:140"><span class="id" title="binder">p</span></a>:<a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:139"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:138"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p:140"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f:132"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:139"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g:134"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:138"><span class="id" title="variable">b</span></a>))<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> <a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img:130"><span class="id" title="variable">eq_img</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:125"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A:126"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f:128"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f:132"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set:125"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B:127"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g:129"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g:134"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a><br>
  )<br>
: <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:143" class="idref" href="#v:143"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:118"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:143"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(111, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(112, '0_3_31');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">H_set</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(113, '0_3_31');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(114, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">f</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(115, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(116, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_f</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:145" class="idref" href="#a:145"><span class="id" title="binder">a</span></a> : <span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a:144"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(117, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_g</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:147" class="idref" href="#b:147"><span class="id" title="binder">b</span></a> : <span class="id" title="var">B</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b:146"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(118, '0_3_31');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(119, '0_3_31');
      "><br>
  { <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(120, '0_3_31');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(121, '0_3_31');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(122, '0_3_31');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(123, '0_3_31');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(124, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(125, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(126, '0_3_31');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(127, '0_3_31');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(128, '0_3_31');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(129, '0_3_31');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(130, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(131, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(132, '0_3_31');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span>) <span class="id" title="var">eq_img</span>)<br>
      (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(133, '0_3_31');
      "><br>
  { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="p:149" class="idref" href="#p:149"><span class="id" title="binder">p</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> <a class="idref" href="HoTT.HIT.V.html#p:148"><span class="id" title="variable">p</span></a> (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'oD'_x"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(134, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
  <span class="id" title="tactic">apply</span> (<span class="id" title="var">H_setext'</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(135, '0_3_31');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(136, '0_3_31');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(137, '0_3_31');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">truncb</span> := <a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(138, '0_3_31');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">truncb</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(139, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(140, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(141, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(142, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(143, '0_3_31');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(144, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(145, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(146, '0_3_31');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(147, '0_3_31');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(148, '0_3_31');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(149, '0_3_31');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">trunca</span> := <a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(150, '0_3_31');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">trunca</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(151, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(152, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(153, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(154, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(155, '0_3_31');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(156, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(157, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(158, '0_3_31');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(159, '0_3_31');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(160, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(161, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
Simpler induction principle when the goal is an hprop 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(165, '0_3_35');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="V_ind_hprop" class="idref" href="#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> (<a id="P:150" class="idref" href="#P:150"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<a id="H_set:155" class="idref" href="#H_set:155"><span class="id" title="binder">H_set</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="A:151" class="idref" href="#A:151"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:152" class="idref" href="#f:152"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:151"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_f:154" class="idref" href="#H_f:154"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:153" class="idref" href="#a:153"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:151"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:150"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:152"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a:153"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P:150"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:152"><span class="id" title="variable">f</span></a>))<br>
  (<a id="isHProp_P:157" class="idref" href="#isHProp_P:157"><span class="id" title="binder">isHProp_P</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:156" class="idref" href="#v:156"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.HIT.V.html#P:150"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:156"><span class="id" title="variable">v</span></a>))<br>
  : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:158" class="idref" href="#v:158"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P:150"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v:158"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(166, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(167, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(168, '0_3_35');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(169, '0_3_35');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(170, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(171, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a id="AssumingUA" class="idref" href="#AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(172, '0_3_35');
      "><br>
<span class="id" title="keyword">Context</span> `{<a id="ua:159" class="idref" href="#ua:159"><span class="id" title="binder">ua</span></a> : <a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(173, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
<a id="lab471"></a><h2 class="section">Membership relation</h2>
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="mem" class="idref" href="#mem"><span class="id" title="definition">mem</span></a> (<a id="x:160" class="idref" href="#x:160"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="a:162" class="idref" href="#a:162"><span class="id" title="binder">a</span></a> : <span class="id" title="var">A</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a:161"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
  - <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eqimg</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(204, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(205, '0_3_39');
      "><br>
<br>
<span class="id" title="var">Declare</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(206, '0_3_39');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="f1e0358be34e82c32d105a13122b22b3" class="idref" href="#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">"</span></a>x ∈ v" := (<a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a> <span class="id" title="var">x</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(207, '0_3_39');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(208, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
<a id="lab472"></a><h2 class="section">Subset relation</h2>
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(215, '0_3_43');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="subset" class="idref" href="#subset"><span class="id" title="definition">subset</span></a> (<a id="x:163" class="idref" href="#x:163"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="y:164" class="idref" href="#y:164"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a><br>
:= <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="z:165" class="idref" href="#z:165"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z:165"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:163"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#z:165"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y:164"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(216, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="148945668c671cfec4e39166c697f7ca" class="idref" href="#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">"</span></a>x ⊆ y" := (<a class="idref" href="HoTT.HIT.V.html#subset"><span class="id" title="definition">subset</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(217, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
<a id="lab473"></a><h2 class="section">Bisimulation relation</h2>
 The equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in hProp_U : Type{U'}, hence the codomain is hProp@{U}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(224, '0_3_47');
      ">
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="bisim_aux" class="idref" href="#bisim_aux"><span class="id" title="definition">bisim_aux</span></a> (<a id="A:166" class="idref" href="#A:166"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="f:167" class="idref" href="#f:167"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:166"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="H_f:168" class="idref" href="#H_f:168"><span class="id" title="binder">H_f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:166"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(225, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(226, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="keyword">with</span><br>
    (<span class="id" title="keyword">fun</span> <a id="B:175" class="idref" href="#B:175"><span class="id" title="binder">B</span></a> <a id="g:176" class="idref" href="#g:176"><span class="id" title="binder">g</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> ( <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:177" class="idref" href="#a:177"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="b:178" class="idref" href="#b:178"><span class="id" title="binder">b</span></a> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a:171"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g:170"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:172"><span class="id" title="variable">b</span></a>))<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
                               <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:179" class="idref" href="#b:179"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="a:180" class="idref" href="#a:180"><span class="id" title="binder">a</span></a> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a:174"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g:170"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b:173"><span class="id" title="variable">b</span></a>)) )<br>
    ).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(227, '0_3_47');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(228, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">B'</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_g'</span> <span class="id" title="var">H_img</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(229, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(230, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(231, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(232, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(233, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(234, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(235, '0_3_47');
      "><br>
        <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      "><span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1) <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="b0:183" class="idref" href="#b0:183"><span class="id" title="binder">b0</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">g'</span> <a class="idref" href="HoTT.HIT.V.html#b0:181"><span class="id" title="variable">b0</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="b0:184" class="idref" href="#b0:184"><span class="id" title="binder">b0</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g'</span> <a class="idref" href="HoTT.HIT.V.html#b0:182"><span class="id" title="variable">b0</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:186" class="idref" href="#x:186"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x:185"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:188" class="idref" href="#x:188"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x:187"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(250, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(251, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(252, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(253, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(254, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(255, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(256, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:190" class="idref" href="#x:190"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x:189"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(257, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(258, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(259, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(260, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(261, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(262, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(263, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(264, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:192" class="idref" href="#x:192"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x:191"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(265, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(266, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="bisimulation" class="idref" href="#bisimulation"><span class="id" title="definition">bisimulation</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp@</span></a>{<span class="id" title="var">U</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(267, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(268, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> (<a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#bisim_aux"><span class="id" title="definition">bisim_aux</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(269, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_img</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(270, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(271, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(272, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(273, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(274, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(275, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(276, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(277, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(278, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(279, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(280, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(281, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(282, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(283, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(284, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(285, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(286, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(287, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(288, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(289, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(290, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(291, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(292, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(293, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(294, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(295, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(296, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(297, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(298, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(299, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(300, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(301, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(302, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(303, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(304, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(305, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(306, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(307, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(308, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(309, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="522815bdfed329d51c502b2896923471" class="idref" href="#522815bdfed329d51c502b2896923471"><span class="id" title="notation">"</span></a>u ~~ v" := (<a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(310, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="reflexive_bisimulation" class="idref" href="#reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Reflexive"><span class="id" title="class">Reflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(311, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(312, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(313, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>; <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(314, '0_3_47');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(315, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(316, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(317, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(318, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="bisimulation_equiv_id" class="idref" href="#bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u:193" class="idref" href="#u:193"><span class="id" title="binder">u</span></a> <a id="v:194" class="idref" href="#v:194"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u:193"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v:194"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u:193"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#v:194"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(319, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(320, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(321, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#equiv_iff_hprop"><span class="id" title="definition">equiv_iff_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(322, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:196" class="idref" href="#x:196"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#x:195"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> (<a class="idref" href="HoTT.HIT.V.html#reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> <span class="id" title="var">u</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(323, '0_3_47');
      "><br>
  - <span class="id" title="tactic">generalize</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(324, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(325, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(326, '0_3_47');
      "><br>
    <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(327, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(328, '0_3_47');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(329, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(330, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(331, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(332, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(333, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(334, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(335, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(336, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(337, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(338, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(339, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(340, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
<a id="lab474"></a><h2 class="section">Canonical presentation of V-sets (Lemma 10.5.6)</h2>
<div class="doc" scenenumber="4"> </div>

 Using the regular kernel would lead to a universe inconsistency in the monic_set_present lemma later. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(349, '0_3_51');
      ">
<span class="id" title="keyword">Definition</span> <a id="ker_bisim" class="idref" href="#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> {<a id="A:197" class="idref" href="#A:197"><span class="id" title="binder">A</span></a>} (<a id="f:198" class="idref" href="#f:198"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:197"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="x:199" class="idref" href="#x:199"><span class="id" title="binder">x</span></a> <a id="y:200" class="idref" href="#y:200"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:197"><span class="id" title="variable">A</span></a>) := (<a class="idref" href="HoTT.HIT.V.html#f:198"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x:199"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#f:198"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y:200"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(350, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="ker_bisim_is_ker" class="idref" href="#ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> {<a id="A:201" class="idref" href="#A:201"><span class="id" title="binder">A</span></a>} (<a id="f:202" class="idref" href="#f:202"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:201"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:203" class="idref" href="#x:203"><span class="id" title="binder">x</span></a> <a id="y:204" class="idref" href="#y:204"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:201"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#f:202"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x:203"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#f:202"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y:204"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <a class="idref" href="HoTT.HIT.V.html#f:202"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x:203"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#y:204"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(351, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(352, '0_3_51');
      "><br>
  <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(353, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(354, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a id="AssumingUA.MonicSetPresent_Uniqueness" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(355, '0_3_51');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(359, '0_3_55');
      ">
<br>
<span class="id" title="keyword">Context</span> {<a id="u:205" class="idref" href="#u:205"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<a id="Au:206" class="idref" href="#Au:206"><span class="id" title="binder">Au</span></a> <a id="Au':207" class="idref" href="#Au':207"><span class="id" title="binder">Au'</span></a>: <span class="id" title="keyword">Type</span>} {<a id="h:208" class="idref" href="#h:208"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au:206"><span class="id" title="variable">Au</span></a>} {<a id="h':209" class="idref" href="#h':209"><span class="id" title="binder">h'</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au':207"><span class="id" title="variable">Au'</span></a>} {<a id="mu:210" class="idref" href="#mu:210"><span class="id" title="binder">mu</span></a> : <a class="idref" href="HoTT.HIT.V.html#Au:206"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<a id="mono:211" class="idref" href="#mono:211"><span class="id" title="binder">mono</span></a> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu:210"><span class="id" title="variable">mu</span></a>}<br>
  {<a id="mu':212" class="idref" href="#mu':212"><span class="id" title="binder">mu'</span></a> : <a class="idref" href="HoTT.HIT.V.html#Au':207"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<a id="mono':213" class="idref" href="#mono':213"><span class="id" title="binder">mono'</span></a> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu':212"><span class="id" title="variable">mu'</span></a>} {<a id="p:214" class="idref" href="#p:214"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.HIT.V.html#u:205"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu:210"><span class="id" title="variable">mu</span></a>} {<a id="p':215" class="idref" href="#p':215"><span class="id" title="binder">p'</span></a> : <a class="idref" href="HoTT.HIT.V.html#u:205"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu':212"><span class="id" title="variable">mu'</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(360, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="eq_img_untrunc" class="idref" href="#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> : <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:216" class="idref" href="#a:216"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a':217" class="idref" href="#a':217"><span class="id" title="binder">a'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#a':217"><span class="id" title="variable">a'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
                     <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a':218" class="idref" href="#a':218"><span class="id" title="binder">a'</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a:219" class="idref" href="#a:219"><span class="id" title="binder">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#a:219"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#a':218"><span class="id" title="variable">a'</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(361, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(362, '0_3_55');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(363, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(364, '0_3_55');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:221" class="idref" href="#x:221"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:220"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(365, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(366, '0_3_55');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:223" class="idref" href="#x:223"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:222"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(367, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(368, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a id="AssumingUA.MonicSetPresent_Uniqueness.e" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> := <span class="id" title="keyword">fun</span> <a id="a:224" class="idref" href="#a:224"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a:224"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(369, '0_3_55');
      "><br>
<span class="id" title="keyword">Let</span> <a id="AssumingUA.MonicSetPresent_Uniqueness.inv_e" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> := <span class="id" title="keyword">fun</span> <a id="a':225" class="idref" href="#a':225"><span class="id" title="binder">a'</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a':225"><span class="id" title="variable">a'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(370, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a id="AssumingUA.MonicSetPresent_Uniqueness.hom1" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(371, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(372, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(373, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(374, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(375, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(376, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(377, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(378, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a id="AssumingUA.MonicSetPresent_Uniqueness.hom2" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(379, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(380, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(381, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(382, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(383, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(384, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(385, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(386, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a id="AssumingUA.MonicSetPresent_Uniqueness.path" class="idref" href="#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(387, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(388, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(389, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(390, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(391, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="mu_eq_mu'" class="idref" href="#mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="A:226" class="idref" href="#A:226"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A:226"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(392, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(393, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(394, '0_3_55');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(395, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="X:230" class="idref" href="#X:230"><span class="id" title="binder">X</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="X:229" class="idref" href="#X:229"><span class="id" title="binder">X</span></a> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X:227"><span class="id" title="variable">X</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(396, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Arrow.html#transport_arrow"><span class="id" title="definition">transport_arrow</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <a id="X:233" class="idref" href="#X:233"><span class="id" title="binder">X</span></a> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X:231"><span class="id" title="variable">X</span></a>) (<span class="id" title="keyword">fun</span> <a id="X:234" class="idref" href="#X:234"><span class="id" title="binder">X</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(397, '0_3_55');
      "><br>
  - <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(398, '0_3_55');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(399, '0_3_55');
      "><br>
    + <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(400, '0_3_55');
      "><br>
      2: <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(401, '0_3_55');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(402, '0_3_55');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(403, '0_3_55');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:236" class="idref" href="#x:236"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#x:235"><span class="id" title="variable">x</span></a> <span class="id" title="var">a'</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(404, '0_3_55');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#transport_path_universe"><span class="id" title="definition">transport_path_universe</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(405, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(406, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="monic_set_present_uniqueness" class="idref" href="#monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h'"><span class="id" title="variable">h'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="A:237" class="idref" href="#A:237"><span class="id" title="binder">A</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="m:238" class="idref" href="#m:238"><span class="id" title="binder">m</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#A:237"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A:237"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m:238"><span class="id" title="variable">m</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m:238"><span class="id" title="variable">m</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(407, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(408, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(409, '0_3_55');
      "><br>
  <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(410, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transportD"><span class="id" title="definition">transportD</span></a> (<span class="id" title="keyword">fun</span> <a id="A:244" class="idref" href="#A:244"><span class="id" title="binder">A</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#A:241"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <a id="A:242" class="idref" href="#A:242"><span class="id" title="binder">A</span></a> <a id="m:243" class="idref" href="#m:243"><span class="id" title="binder">m</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A:239"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m:240"><span class="id" title="variable">m</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m:240"><span class="id" title="variable">m</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(411, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <a id="A:248" class="idref" href="#A:248"><span class="id" title="binder">A</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#A:245"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <a id="A:249" class="idref" href="#A:249"><span class="id" title="binder">A</span></a> <a id="m:250" class="idref" href="#m:250"><span class="id" title="binder">m</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A:246"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m:247"><span class="id" title="variable">m</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m:247"><span class="id" title="variable">m</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(412, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(413, '0_3_55');
      "><br>
    <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.V.html#mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(414, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(415, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(416, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
This lemma actually says a little more than 10.5.6, i.e., that Au is a hSet 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(420, '0_3_59');
      ">
<span class="id" title="keyword">Lemma</span> <a id="monic_set_present" class="idref" href="#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u:251" class="idref" href="#u:251"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><a id="Au:252" class="idref" href="#Au:252"><span class="id" title="binder">Au</span></a> : <span class="id" title="keyword">Type</span>) (<a id="m:253" class="idref" href="#m:253"><span class="id" title="binder">m</span></a> : <a class="idref" href="HoTT.HIT.V.html#Au:252"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Overture.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au:252"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m:253"><span class="id" title="variable">m</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u:251"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m:253"><span class="id" title="variable">m</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(421, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(422, '0_3_59');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(423, '0_3_59');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(424, '0_3_59');
      "><br>
    <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Colimits.Quotient.html#quotient_kernel_factor"><span class="id" title="lemma">quotient_kernel_factor</span></a> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.HIT.V.html#ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> <span class="id" title="var">f</span>))<br>
      <span class="id" title="keyword">as</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">eu</span> [<span class="id" title="var">mu</span> (((<span class="id" title="var">hset_Au</span>, <span class="id" title="var">epi_eu</span>), <span class="id" title="var">mono_mu</span>), <span class="id" title="var">factor</span>)]]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(425, '0_3_59');
      "><br>
    <span class="id" title="tactic">∃</span> <span class="id" title="var">Au</span>, <span class="id" title="var">mu</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(426, '0_3_59');
      "><span class="id" title="tactic">split</span>;[<span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">hset_Au</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">mono_mu</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>|].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(427, '0_3_59');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(428, '0_3_59');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(429, '0_3_59');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(430, '0_3_59');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(431, '0_3_59');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(432, '0_3_59');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">epi_eu</span> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(433, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" title="method">center</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(434, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(435, '0_3_59');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(436, '0_3_59');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">mu</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(437, '0_3_59');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(438, '0_3_59');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">mu</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(439, '0_3_59');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(440, '0_3_59');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(441, '0_3_59');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">mu</span> ((<span class="id" title="var">hset</span>, <span class="id" title="var">mono</span>), <span class="id" title="var">p</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(442, '0_3_59');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au'</span> [<span class="id" title="var">mu'</span> ((<span class="id" title="var">hset'</span>, <span class="id" title="var">mono'</span>), <span class="id" title="var">p'</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(443, '0_3_59');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(444, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(445, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="type_of_members" class="idref" href="#type_of_members"><span class="id" title="definition">type_of_members</span></a> (<a id="u:254" class="idref" href="#u:254"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u:254"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(446, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="9e940231d243ed642093049b7e46ee99" class="idref" href="#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">"</span></a>[ u ]" := (<a class="idref" href="HoTT.HIT.V.html#type_of_members"><span class="id" title="definition">type_of_members</span></a> <span class="id" title="var">u</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(447, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="func_of_members" class="idref" href="#func_of_members"><span class="id" title="definition">func_of_members</span></a> {<a id="u:255" class="idref" href="#u:255"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u:255"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u:255"><span class="id" title="variable">u</span></a>)) : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u:255"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(448, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="is_hset_typeofmembers" class="idref" href="#is_hset_typeofmembers"><span class="id" title="definition">is_hset_typeofmembers</span></a> {<a id="u:256" class="idref" href="#u:256"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> (<a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u:256"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a>) := <a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u:256"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(449, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="IsEmbedding_funcofmembers" class="idref" href="#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> {<a id="u:257" class="idref" href="#u:257"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u:257"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(450, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="is_valid_presentation" class="idref" href="#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a id="u:258" class="idref" href="#u:258"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#u:258"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u:258"><span class="id" title="variable">u</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(451, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
<a id="lab475"></a><h2 class="section">Lemmas 10.5.8 (i) &amp; (vii), we put them here because they are useful later</h2>
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(458, '0_3_63');
      ">
<span class="id" title="keyword">Lemma</span> <a id="extensionality" class="idref" href="#extensionality"><span class="id" title="lemma">extensionality</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">{</span></a><a id="x:259" class="idref" href="#x:259"><span class="id" title="binder">x</span></a> <a id="y:260" class="idref" href="#y:260"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">},</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x:259"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#y:260"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#y:260"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#x:259"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x:259"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y:260"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(459, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(460, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(461, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(462, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(463, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(464, '0_3_63');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(465, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(466, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(467, '0_3_63');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(468, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(469, '0_3_63');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a>1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(470, '0_3_63');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(471, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(472, '0_3_63');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(473, '0_3_63');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(474, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(475, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<span class="id" title="var">H2</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(476, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(477, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(478, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(479, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:262" class="idref" href="#x:262"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:261"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(480, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(481, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:264" class="idref" href="#x:264"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:263"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(482, '0_3_63');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(483, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="mem_induction" class="idref" href="#mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<a id="C:265" class="idref" href="#C:265"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:266" class="idref" href="#v:266"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:267" class="idref" href="#x:267"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:267"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v:266"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C:265"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x:267"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C:265"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v:266"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:268" class="idref" href="#v:268"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#C:265"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v:268"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(484, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(485, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(486, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(487, '0_3_63');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(488, '0_3_63');
      "><span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(489, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(490, '0_3_63');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(491, '0_3_63');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(492, '0_3_63');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(493, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(494, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
<a id="lab476"></a><h2 class="section">Two useful lemmas</h2>
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(501, '0_3_67');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a id="irreflexive_mem" class="idref" href="#irreflexive_mem"><span class="id" title="instance">irreflexive_mem</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Irreflexive"><span class="id" title="class">Irreflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(502, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(503, '0_3_67');
      "><br>
  <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:272" class="idref" href="#v:272"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a> (<span class="id" title="keyword">fun</span> <a id="x:273" class="idref" href="#x:273"><span class="id" title="binder">x</span></a> <a id="x0:274" class="idref" href="#x0:274"><span class="id" title="binder">x0</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#x:270"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x0:271"><span class="id" title="variable">x0</span></a>) <a class="idref" href="HoTT.HIT.V.html#v:269"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#v:269"><span class="id" title="variable">v</span></a>)).   { </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(504, '0_3_67');
      "><span class="id" title="tactic">intro</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(505, '0_3_67');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(506, '0_3_67');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="keyword">fun</span> <a id="x:276" class="idref" href="#x:276"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.HIT.V.html#x:275"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:275"><span class="id" title="variable">x</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(507, '0_3_67');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(508, '0_3_67');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">Hv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(509, '0_3_67');
      "><br>
  <span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">v</span> <span class="id" title="var">Hv</span> <span class="id" title="var">Hv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(510, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(511, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="path_V_eqimg" class="idref" href="#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> {<a id="A:277" class="idref" href="#A:277"><span class="id" title="binder">A</span></a> <a id="B:278" class="idref" href="#B:278"><span class="id" title="binder">B</span></a>} {<a id="f:279" class="idref" href="#f:279"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#A:277"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<a id="g:280" class="idref" href="#g:280"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.HIT.V.html#B:278"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f:279"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g:280"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f:279"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g:280"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(512, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(513, '0_3_67');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(514, '0_3_67');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(515, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(516, '0_3_67');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(517, '0_3_67');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(518, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(519, '0_3_67');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(520, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(521, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(522, '0_3_67');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(523, '0_3_67');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(524, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(525, '0_3_67');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(526, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(527, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(528, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a id="lab477"></a><h2 class="section">Definitions of particular sets in V</h2>
<div class="doc" scenenumber="4"> </div>

 The empty set 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(537, '0_3_71');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_empty" class="idref" href="#V_empty"><span class="id" title="definition">V_empty</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(538, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
The singleton {u} 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(542, '0_3_75');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_singleton" class="idref" href="#V_singleton"><span class="id" title="definition">V_singleton</span></a> (<a id="u:281" class="idref" href="#u:281"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Unit_ind"><span class="id" title="definition">Unit_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#u:281"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(543, '0_3_75');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_ap_V_singleton" class="idref" href="#isequiv_ap_V_singleton"><span class="id" title="instance">isequiv_ap_V_singleton</span></a> {<a id="u:282" class="idref" href="#u:282"><span class="id" title="binder">u</span></a> <a id="v:283" class="idref" href="#v:283"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (@<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u:282"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v:283"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(544, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(545, '0_3_75');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#Build_IsEquiv"><span class="id" title="constructor">Build_IsEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> ].</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(546, '0_3_75');
      "><br>
  { <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(547, '0_3_75');
      "><span class="id" title="tactic">specialize</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(548, '0_3_75');
      "><span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(549, '0_3_75');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(550, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(551, '0_3_75');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(552, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
The pair {u,v} 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(556, '0_3_79');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_pair" class="idref" href="#V_pair"><span class="id" title="definition">V_pair</span></a> (<a id="u:284" class="idref" href="#u:284"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="v:285" class="idref" href="#v:285"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <a id="b:286" class="idref" href="#b:286"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="HoTT.HIT.V.html#b:286"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.HIT.V.html#u:284"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.HIT.V.html#v:285"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(557, '0_3_79');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="path_pair" class="idref" href="#path_pair"><span class="id" title="lemma">path_pair</span></a> {<a id="u:287" class="idref" href="#u:287"><span class="id" title="binder">u</span></a> <a id="v:288" class="idref" href="#v:288"><span class="id" title="binder">v</span></a> <a id="u':289" class="idref" href="#u':289"><span class="id" title="binder">u'</span></a> <a id="v':290" class="idref" href="#v':290"><span class="id" title="binder">v'</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>}} : <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u:287"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u':289"><span class="id" title="variable">u'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v:288"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v':290"><span class="id" title="variable">v'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u:287"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v:288"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u':289"><span class="id" title="variable">u'</span></a> <a class="idref" href="HoTT.HIT.V.html#v':290"><span class="id" title="variable">v'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(558, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(559, '0_3_79');
      "><br>
  <span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(560, '0_3_79');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(561, '0_3_79');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(562, '0_3_79');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(563, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(564, '0_3_79');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(565, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(566, '0_3_79');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(567, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(568, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(569, '0_3_79');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(570, '0_3_79');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="pair_eq_singleton" class="idref" href="#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> {<a id="u:291" class="idref" href="#u:291"><span class="id" title="binder">u</span></a> <a id="v:292" class="idref" href="#v:292"><span class="id" title="binder">v</span></a> <a id="w:293" class="idref" href="#w:293"><span class="id" title="binder">w</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u:291"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v:292"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#w:293"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u:291"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w:293"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v:292"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w:293"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(571, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(572, '0_3_79');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(573, '0_3_79');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(574, '0_3_79');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(575, '0_3_79');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(576, '0_3_79');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(577, '0_3_79');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(578, '0_3_79');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(579, '0_3_79');
      "><br>
    <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>| <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(580, '0_3_79');
      "><br>
  + <span class="id" title="tactic">intros</span> (<span class="id" title="var">p1</span>, <span class="id" title="var">p2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(581, '0_3_79');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(582, '0_3_79');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(583, '0_3_79');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">p2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(584, '0_3_79');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(585, '0_3_79');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(586, '0_3_79');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(587, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The ordered pair (u,v) 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(591, '0_3_83');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_pair_ord" class="idref" href="#V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> (<a id="u:294" class="idref" href="#u:294"><span class="id" title="binder">u</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="v:295" class="idref" href="#v:295"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u:294"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u:294"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v:295"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(592, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="5bd00e41e8e773c760ec63d09afefb5f" class="idref" href="#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">"</span></a> [ u , v ] " := (<a class="idref" href="HoTT.HIT.V.html#V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(593, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="path_pair_ord" class="idref" href="#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> {<a id="a:296" class="idref" href="#a:296"><span class="id" title="binder">a</span></a> <a id="b:297" class="idref" href="#b:297"><span class="id" title="binder">b</span></a> <a id="c:298" class="idref" href="#c:298"><span class="id" title="binder">c</span></a> <a id="d:299" class="idref" href="#d:299"><span class="id" title="binder">d</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a:296"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#b:297"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#c:298"><span class="id" title="variable">c</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#d:299"><span class="id" title="variable">d</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a:296"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#c:298"><span class="id" title="variable">c</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#b:297"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#d:299"><span class="id" title="variable">d</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(594, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(595, '0_3_83');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(596, '0_3_83');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(597, '0_3_83');
      "><span class="id" title="tactic">assert</span> (<span class="id" title="var">p1</span> : <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(598, '0_3_83');
      "><br>
    + <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(599, '0_3_83');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(600, '0_3_83');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(601, '0_3_83');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(602, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(603, '0_3_83');
      "><br>
      × <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">p'</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(604, '0_3_83');
      "><br>
      × <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(605, '0_3_83');
      "><br>
    + <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(606, '0_3_83');
      "><br>
      × <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(607, '0_3_83');
      "><br>
      × <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Truncations.Core.html#hor"><span class="id" title="definition">hor</span></a> (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">d</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(608, '0_3_83');
      "><br>
        { <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(609, '0_3_83');
      "><br>
          { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(610, '0_3_83');
      "><br>
            <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(611, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(612, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">left</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(613, '0_3_83');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(614, '0_3_83');
      "><br>
          - <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(615, '0_3_83');
      "><br>
            <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>); <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(616, '0_3_83');
      "><br>
            <span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p''</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(617, '0_3_83');
      "><br>
            + <span class="id" title="tactic">left</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(618, '0_3_83');
      "><br>
            + <span class="id" title="tactic">right</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>. }<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(619, '0_3_83');
      "><span class="id" title="tactic">intro</span> <span class="id" title="tactic">case</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="tactic">case</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">p'</span>| <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(620, '0_3_83');
      "><br>
        2: <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(621, '0_3_83');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(622, '0_3_83');
      "><br>
        { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(623, '0_3_83');
      "><br>
          <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(624, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(625, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(626, '0_3_83');
      "><br>
            <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) | <span class="id" title="tactic">reflexivity</span>]. }</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(627, '0_3_83');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">H''</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">c</span> <span class="id" title="var">d</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)<br>
          <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> (<span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">H'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(628, '0_3_83');
      "><br>
        <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">H''</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(629, '0_3_83');
      "><br>
  - <span class="id" title="tactic">intros</span> (<span class="id" title="var">p</span>, <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(630, '0_3_83');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(631, '0_3_83');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(632, '0_3_83');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(633, '0_3_83');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(634, '0_3_83');
      "><span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(635, '0_3_83');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(636, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The cartesian product a × b 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(640, '0_3_87');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_cart_prod" class="idref" href="#V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> (<a id="a:300" class="idref" href="#a:300"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="b:301" class="idref" href="#b:301"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <a id="x:302" class="idref" href="#x:302"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a:300"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b:301"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#x:302"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#x:302"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(641, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="c7797332d94cc7591d117bb1d3b33b33" class="idref" href="#c7797332d94cc7591d117bb1d3b33b33"><span class="id" title="notation">"</span></a> a × b " := (<a class="idref" href="HoTT.HIT.V.html#V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(642, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
f is a function with domain a and codomain b 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(646, '0_3_91');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_is_func" class="idref" href="#V_is_func"><span class="id" title="definition">V_is_func</span></a> (<a id="a:303" class="idref" href="#a:303"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="b:304" class="idref" href="#b:304"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="f:305" class="idref" href="#f:305"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) := <a class="idref" href="HoTT.HIT.V.html#f:305"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a:303"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#c7797332d94cc7591d117bb1d3b33b33"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#b:304"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:306" class="idref" href="#x:306"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:306"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a:303"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="y:307" class="idref" href="#y:307"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#y:307"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#b:304"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x:306"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y:307"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f:305"><span class="id" title="variable">f</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:308" class="idref" href="#x:308"><span class="id" title="binder">x</span></a> <a id="y:309" class="idref" href="#y:309"><span class="id" title="binder">y</span></a> <a id="y':310" class="idref" href="#y':310"><span class="id" title="binder">y'</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x:308"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y:309"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f:305"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x:308"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y':310"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f:305"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#y:309"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y':310"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(647, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The set of functions from a to b 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(651, '0_3_95');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_func" class="idref" href="#V_func"><span class="id" title="definition">V_func</span></a> (<a id="a:311" class="idref" href="#a:311"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="b:312" class="idref" href="#b:312"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a:311"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b:312"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a>) (<span class="id" title="keyword">fun</span> <a id="f:313" class="idref" href="#f:313"><span class="id" title="binder">f</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <a id="x:314" class="idref" href="#x:314"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#x:314"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.HIT.V.html#f:313"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x:314"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> )).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(652, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
The union of a set Uv 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(656, '0_3_99');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_union" class="idref" href="#V_union"><span class="id" title="definition">V_union</span></a> (<a id="v:315" class="idref" href="#v:315"><span class="id" title="binder">v</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) :=<br>
  @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="x:316" class="idref" href="#x:316"><span class="id" title="binder">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#v:315"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#x:316"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>) (<span class="id" title="keyword">fun</span> <a id="z:317" class="idref" href="#z:317"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <a class="idref" href="HoTT.HIT.V.html#z:317"><span class="id" title="variable">z</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(657, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The ordinal successor x ∪ {x} 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(661, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_succ" class="idref" href="#V_succ"><span class="id" title="definition">V_succ</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(662, '0_3_103');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(663, '0_3_103');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(664, '0_3_103');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(665, '0_3_103');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> (<a id="x:320" class="idref" href="#x:320"><span class="id" title="binder">x</span></a> : <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#x:318"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">a</span><br>
                                           | <a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span> <span class="id" title="keyword">end</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(666, '0_3_103');
      "><br>
  - <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(667, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(668, '0_3_103');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(669, '0_3_103');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(670, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(671, '0_3_103');
      "><br>
      × <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(672, '0_3_103');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(673, '0_3_103');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(674, '0_3_103');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">b</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(675, '0_3_103');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(676, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(677, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(678, '0_3_103');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(679, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(680, '0_3_103');
      "><br>
      × <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(681, '0_3_103');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(682, '0_3_103');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(683, '0_3_103');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(684, '0_3_103');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(685, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(686, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(687, '0_3_103');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(688, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The set of finite ordinals 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(692, '0_3_107');
      ">
<span class="id" title="keyword">Definition</span> <a id="V_omega" class="idref" href="#V_omega"><span class="id" title="definition">V_omega</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fix</span> <span class="id" title="var">I</span> <a id="n:322" class="idref" href="#n:322"><span class="id" title="binder">n</span></a> := <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#n:322"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span> 0   ⇒ <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><br>
                              | <a class="idref" href="HoTT.Basics.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> (<a class="idref" href="HoTT.HIT.V.html#I:323"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.HIT.V.html#n:322"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">end</span>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(693, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
<a id="lab478"></a><h2 class="section">Axioms of set theory (theorem 10.5.8)</h2>
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(700, '0_3_111');
      ">
<br>
<span class="id" title="keyword">Lemma</span> <a id="not_mem_Vempty" class="idref" href="#not_mem_Vempty"><span class="id" title="lemma">not_mem_Vempty</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:325" class="idref" href="#x:325"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x:325"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(701, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(702, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(703, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(704, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">ff</span> <span class="id" title="var">_</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(705, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">ff</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(706, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(707, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="pairing" class="idref" href="#pairing"><span class="id" title="lemma">pairing</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u:326" class="idref" href="#u:326"><span class="id" title="binder">u</span></a> <a id="v:327" class="idref" href="#v:327"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="w:328" class="idref" href="#w:328"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:329" class="idref" href="#x:329"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:329"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w:328"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hor"><span class="id" title="definition">hor</span></a> (<a class="idref" href="HoTT.HIT.V.html#x:329"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u:326"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#x:329"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v:327"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(708, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(709, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(710, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(711, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(712, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(713, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [[|] <span class="id" title="var">p</span>]; [<span class="id" title="tactic">left</span>|<span class="id" title="tactic">right</span>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(714, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">p</span> | <span class="id" title="var">p</span>]; [<span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a> | <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(715, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(716, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="infinity" class="idref" href="#infinity"><span class="id" title="lemma">infinity</span></a> : <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:330" class="idref" href="#x:330"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:330"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> <a class="idref" href="HoTT.HIT.V.html#x:330"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(717, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(718, '0_3_111');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(719, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> 0; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(720, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(721, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(722, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">n</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(723, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(724, '0_3_111');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(725, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(726, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="union" class="idref" href="#union"><span class="id" title="lemma">union</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="v:331" class="idref" href="#v:331"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="w:332" class="idref" href="#w:332"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:333" class="idref" href="#x:333"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:333"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w:332"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="u:334" class="idref" href="#u:334"><span class="id" title="binder">u</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#x:333"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#u:334"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#u:334"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v:331"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(727, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(728, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(729, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_union"><span class="id" title="definition">V_union</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(730, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(731, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(732, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(733, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(734, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">u'</span> <span class="id" title="var">x'</span>] <span class="id" title="var">p</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(735, '0_3_111');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(736, '0_3_111');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:336" class="idref" href="#z:336"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:335"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(737, '0_3_111');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(738, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">x'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(739, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(740, '0_3_111');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:338" class="idref" href="#z:338"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:337"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(741, '0_3_111');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(742, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">u'</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(743, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(744, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u</span> (<span class="id" title="var">Hx</span>, <span class="id" title="var">Hu</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(745, '0_3_111');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:340" class="idref" href="#z:340"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:339"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>) <span class="id" title="var">Hu</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(746, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(747, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u'</span> <span class="id" title="var">pu</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(748, '0_3_111');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:344" class="idref" href="#z:344"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:342"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:343" class="idref" href="#z:343"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:341"><span class="id" title="variable">z</span></a>) <span class="id" title="var">pu</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hx</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(749, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(750, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">x'</span> <span class="id" title="var">px</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(751, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(752, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">u'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">x'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(753, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">px</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(754, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(755, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="function" class="idref" href="#function"><span class="id" title="lemma">function</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u:345" class="idref" href="#u:345"><span class="id" title="binder">u</span></a> <a id="v:346" class="idref" href="#v:346"><span class="id" title="binder">v</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="w:347" class="idref" href="#w:347"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:348" class="idref" href="#x:348"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:348"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w:347"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#V_is_func"><span class="id" title="definition">V_is_func</span></a> <a class="idref" href="HoTT.HIT.V.html#u:345"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v:346"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#x:348"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(756, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(757, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(758, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_func"><span class="id" title="definition">V_func</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(759, '0_3_111');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_u</span> : <span class="id" title="var">u</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">u</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(760, '0_3_111');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_v</span> : <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">v</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(761, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">phi</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(762, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(763, '0_3_111');
      "><span class="id" title="tactic">split</span>;[<span class="id" title="tactic">split</span>|].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(764, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(765, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(766, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(767, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(768, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(769, '0_3_111');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:350" class="idref" href="#x:350"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:349"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(770, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(771, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(772, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(773, '0_3_111');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(774, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(775, '0_3_111');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="y:352" class="idref" href="#y:352"><span class="id" title="binder">y</span></a> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y:351"><span class="id" title="variable">y</span></a>) <span class="id" title="var">memb_u</span> <span class="id" title="var">Hx</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(776, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(777, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(778, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(779, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(780, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(781, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(782, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:354" class="idref" href="#z:354"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:353"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(783, '0_3_111');
      "><br>
      × <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="y:356" class="idref" href="#y:356"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y:355"><span class="id" title="variable">y</span></a>) <span class="id" title="var">p_phi</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(784, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(785, '0_3_111');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(786, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> (<span class="id" title="var">Hy</span>, <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(787, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(788, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(789, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:358" class="idref" href="#z:358"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:357"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(790, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(791, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(792, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:360" class="idref" href="#z:360"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">y'</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:359"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(793, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(794, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a'</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(795, '0_3_111');
      "><br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px</span>, <span class="id" title="var">py</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(796, '0_3_111');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px'</span>, <span class="id" title="var">py'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(797, '0_3_111');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(798, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a'</span>));<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(799, '0_3_111');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(800, '0_3_111');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(801, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> (<span class="id" title="var">px</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">px'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(802, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> ((<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>), <span class="id" title="var">H3</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(803, '0_3_111');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(804, '0_3_111');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:363" class="idref" href="#a:363"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><span class="id" title="var">u</span><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="b:364" class="idref" href="#b:364"><span class="id" title="binder">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><span class="id" title="var">v</span><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#a:361"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#b:362"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(805, '0_3_111');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(806, '0_3_111');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(807, '0_3_111');
      "><br>
      <span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="y:366" class="idref" href="#y:366"><span class="id" title="binder">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#y:365"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y:365"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(808, '0_3_111');
      "><br>
      - <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="y:369" class="idref" href="#y:369"><span class="id" title="binder">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#y:367"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y:367"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span><br>
                                 (<span class="id" title="var">H2</span> <span class="id" title="var">x</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:370" class="idref" href="#z:370"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:368"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_u</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(809, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(810, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)] [<span class="id" title="var">y'</span> (<span class="id" title="var">H1_y'</span>, <span class="id" title="var">H2_y'</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(811, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(812, '0_3_111');
      "><br>
        <span class="id" title="tactic">∃</span> (<span class="id" title="var">H3</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">H2_y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">H2_y'</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(813, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(814, '0_3_111');
      "><br>
      - <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(815, '0_3_111');
      "><br>
        <span class="id" title="tactic">destruct</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">y</span>) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:372" class="idref" href="#z:372"><span class="id" title="binder">z</span></a> ⇒ <span class="id" title="var">y</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z:371"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span> <span class="id" title="var">H1_y</span>)) <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">Hb</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(816, '0_3_111');
      "><br>
        <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(817, '0_3_111');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="z:374" class="idref" href="#z:374"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z:373"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Hb</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2_y</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(818, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <a id="a:376" class="idref" href="#a:376"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.HIT.V.html#a:375"><span class="id" title="variable">a</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(819, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(820, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(821, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(822, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hz</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(823, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Ha</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(824, '0_3_111');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="w:378" class="idref" href="#w:378"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#w:377"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Ha</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(825, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(826, '0_3_111');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(827, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(828, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(829, '0_3_111');
      "><span class="id" title="tactic">intros</span> [(<span class="id" title="var">a</span>,<span class="id" title="var">b</span>) <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(830, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(831, '0_3_111');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(832, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(833, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(834, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">H3</span> <span class="id" title="keyword">with</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(835, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(836, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(837, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="w:380" class="idref" href="#w:380"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#w:379"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(838, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(839, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="replacement" class="idref" href="#replacement"><span class="id" title="lemma">replacement</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="r:381" class="idref" href="#r:381"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<a id="x:382" class="idref" href="#x:382"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="w:383" class="idref" href="#w:383"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:384" class="idref" href="#y:384"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y:384"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w:383"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="z:385" class="idref" href="#z:385"><span class="id" title="binder">z</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#z:385"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x:382"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#r:381"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.HIT.V.html#z:385"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y:384"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(840, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(841, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">r</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(842, '0_3_111');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(843, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(844, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(845, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="var">r</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <span class="id" title="var">f</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(846, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(847, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(848, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(849, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(850, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(851, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(852, '0_3_111');
      "><br>
    + <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(853, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(854, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">z</span> [<span class="id" title="var">h</span> <span class="id" title="var">p</span>]]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(855, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(856, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(857, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(858, '0_3_111');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(859, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">r</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(860, '0_3_111');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">r</span> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(861, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(862, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="separation" class="idref" href="#separation"><span class="id" title="lemma">separation</span></a> (<a id="C:386" class="idref" href="#C:386"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:387" class="idref" href="#a:387"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="w:388" class="idref" href="#w:388"><span class="id" title="binder">w</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:389" class="idref" href="#x:389"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x:389"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w:388"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x:389"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a:387"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#C:386"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x:389"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(863, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(864, '0_3_111');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(865, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(866, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(867, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <a id="z:393" class="idref" href="#z:393"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a:392" class="idref" href="#a:392"><span class="id" title="binder">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">C</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a:390"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> ⇒ <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.HIT.V.html#z:391"><span class="id" title="variable">z</span></a>))). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(868, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(869, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(870, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">h</span>] <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(871, '0_3_111');
      "><span class="id" title="tactic">split</span>. + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">assumption</span>. + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(872, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(873, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(874, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(875, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(876, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(877, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(878, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(879, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(880, '0_3_111');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
