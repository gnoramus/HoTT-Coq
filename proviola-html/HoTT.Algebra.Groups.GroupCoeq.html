<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "1 goal (ID 17)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  Group	";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "2 goals (ID 24)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism (FreeProduct A A) A		goal 2 (ID 25) is:	 GroupHomomorphism (FreeProduct A A) B	";
            responses[i]=data;
          

            i = 19;
            data = "4 goals (ID 26)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism A A		goal 2 (ID 27) is:	 GroupHomomorphism A A	goal 3 (ID 28) is:	 GroupHomomorphism A B	goal 4 (ID 29) is:	 GroupHomomorphism A B	";
            responses[i]=data;
          

            i = 20;
            data = "1 goal (ID 26)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism A A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 27) is:	 GroupHomomorphism A A	goal 2 (ID 28) is:	 GroupHomomorphism A B	goal 3 (ID 29) is:	 GroupHomomorphism A B	";
            responses[i]=data;
          

            i = 21;
            data = "1 goal (ID 27)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism A A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 28) is:	 GroupHomomorphism A B	goal 2 (ID 29) is:	 GroupHomomorphism A B	";
            responses[i]=data;
          

            i = 22;
            data = "1 goal (ID 28)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism A B	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 29) is:	 GroupHomomorphism A B	";
            responses[i]=data;
          

            i = 23;
            data = "1 goal (ID 29)	  	  A : Group	  B : Group	  f, g : GroupHomomorphism A B	  ============================	  GroupHomomorphism A B	No more goals.	";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "1 goal (ID 47)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  ============================	  {h : GroupHomomorphism B C & h o f == h o g} <~>	  GroupHomomorphism (GroupCoeq f g) C	";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "1 goal (ID 66)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  ============================	  {h : GroupHomomorphism B C &	  (fun x : A => h (f x)) == (fun x : A => h (g x))} <~>	  {h : GroupHomomorphism A C &	  {k : GroupHomomorphism B C &	  (fun x : FreeProduct A A =>	   h (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => k (FreeProduct_rec A A B f g x))}}	";
            responses[i]=data;
          

            i = 28;
            data = "1 goal (ID 76)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  ============================	  {h : GroupHomomorphism B C &	  (fun x : A => h (f x)) == (fun x : A => h (g x))} <~>	  {a : GroupHomomorphism B C &	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => a (FreeProduct_rec A A B f g x))}}	";
            responses[i]=data;
          

            i = 29;
            data = "1 goal (ID 80)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  ============================	  forall a : GroupHomomorphism B C,	  (fun x : A => a (f x)) == (fun x : A => a (g x)) <~>	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => a (FreeProduct_rec A A B f g x))}	";
            responses[i]=data;
          

            i = 30;
            data = "1 goal (ID 81)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun x : A => h (f x)) == (fun x : A => h (g x)) <~>	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))}	";
            responses[i]=data;
          

            i = 31;
            data = "4 goals (ID 105)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun x : A => h (f x)) == (fun x : A => h (g x)) ->	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))}		goal 2 (ID 107) is:	 {b : GroupHomomorphism A C &	 (fun x : FreeProduct A A =>	  b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	 (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} ->	 (fun x : A => h (f x)) == (fun x : A => h (g x))	goal 3 (ID 109) is:	 ?f o ?g == idmap	goal 4 (ID 111) is:	 ?g o ?f == idmap	";
            responses[i]=data;
          

            i = 32;
            data = "1 goal (ID 105)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun x : A => h (f x)) == (fun x : A => h (g x)) ->	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))}	1 goal (ID 112)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))}	";
            responses[i]=data;
          

            i = 33;
            data = "1 goal (ID 117)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  (fun x : FreeProduct A A =>	   grp_homo_compose h f (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	";
            responses[i]=data;
          

            i = 34;
            data = "1 goal (ID 119)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  x : FreeProduct A A	  ============================	  grp_homo_compose h f (FreeProduct_rec A A A grp_homo_id grp_homo_id x) =	  h (FreeProduct_rec A A B f g x)	";
            responses[i]=data;
          

            i = 35;
            data = "1 goal (ID 128)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  x : FreeProduct A A	  ============================	  h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) =	  h (FreeProduct_rec A A B f g x)	";
            responses[i]=data;
          

            i = 36;
            data = "1 goal (ID 130)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  forall x : FreeProduct A A,	  h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) =	  h (FreeProduct_rec A A B f g x)	";
            responses[i]=data;
          

            i = 37;
            data = "1 goal (ID 438)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  forall	  a : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)),	  h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr a))) =	  h (FreeProduct_rec A A B f g (tr a))	";
            responses[i]=data;
          

            i = 38;
            data = "2 goals (ID 464)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  forall a : FreeProduct.Words A A,	  (fun	     w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	           (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	   h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	   h (FreeProduct_rec A A B f g (tr w))) (coeq a)		goal 2 (ID 466) is:	 forall	 b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	     FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	     FreeProduct.pc5 A A,	 transport	   (fun	      w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	            (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	    h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	    h (FreeProduct_rec A A B f g (tr w))) (cglue b)	   (?coeq' (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)) =	 ?coeq' (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)	";
            responses[i]=data;
          

            i = 39;
            data = "1 goal (ID 464)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  forall a : FreeProduct.Words A A,	  (fun	     w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	           (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	   h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	   h (FreeProduct_rec A A B f g (tr w))) (coeq a)	";
            responses[i]=data;
          

            i = 40;
            data = "1 goal (ID 668)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  w : FreeProduct.Words A A	  ============================	  (fun	     w0 : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	            (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	   h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w0))) =	   h (FreeProduct_rec A A B f g (tr w0))) (coeq w)	";
            responses[i]=data;
          

            i = 41;
            data = "1 goal (ID 669)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  w : FreeProduct.Words A A	  ============================	  h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	  h (FreeProduct_rec A A B f g (tr (coeq w)))	";
            responses[i]=data;
          

            i = 42;
            data = "2 goals (ID 673)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  ============================	  h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq nil)))) =	  h (FreeProduct_rec A A B f g (tr (coeq nil)))		goal 2 (ID 677) is:	 h	   (g	      (FreeProduct_rec A A A grp_homo_id grp_homo_id	         (tr (coeq (a :: w)%list)))) =	 h (FreeProduct_rec A A B f g (tr (coeq (a :: w)%list)))	";
            responses[i]=data;
          

            i = 43;
            data = "1 goal (ID 677)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A + A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h	    (g	       (FreeProduct_rec A A A grp_homo_id grp_homo_id	          (tr (coeq (a :: w)%list)))) =	  h (FreeProduct_rec A A B f g (tr (coeq (a :: w)%list)))	";
            responses[i]=data;
          

            i = 44;
            data = "1 goal (ID 685)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A + A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h	    (g	       (match a with	        | inl a0 => fun x : A => a0 * x	        | inr b => fun x : A => b * x	        end	          (List.fold_right A (A + A)	             (fun X0 : A + A =>	              match X0 with	              | inl a0 => fun x : A => a0 * x	              | inr b => fun x : A => b * x	              end) mon_unit w))) =	  h	    (match a with	     | inl a0 => fun x : B => f a0 * x	     | inr b => fun x : B => g b * x	     end	       (List.fold_right B (A + A)	          (fun X0 : A + A =>	           match X0 with	           | inl a0 => fun x : B => f a0 * x	           | inr b => fun x : B => g b * x	           end) mon_unit w))	";
            responses[i]=data;
          

            i = 45;
            data = "2 goals (ID 692)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h	    (g	       (a *	        List.fold_right A (A + A)	          (fun X0 : A + A =>	           match X0 with	           | inl a0 => fun x : A => a0 * x	           | inr b => fun x : A => b * x	           end) mon_unit w)) =	  h	    (f a *	     List.fold_right B (A + A)	       (fun X0 : A + A =>	        match X0 with	        | inl a0 => fun x : B => f a0 * x	        | inr b => fun x : B => g b * x	        end) mon_unit w)		goal 2 (ID 694) is:	 h	   (g	      (a *	       List.fold_right A (A + A)	         (fun X0 : A + A =>	          match X0 with	          | inl a0 => fun x : A => a0 * x	          | inr b => fun x : A => b * x	          end) mon_unit w)) =	 h	   (g a *	    List.fold_right B (A + A)	      (fun X0 : A + A =>	       match X0 with	       | inl a0 => fun x : B => f a0 * x	       | inr b => fun x : B => g b * x	       end) mon_unit w)	";
            responses[i]=data;
          

            i = 46;
            data = "2 goals (ID 715)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h	    (g a *	     g	       (List.fold_right A (A + A)	          (fun X0 : A + A =>	           match X0 with	           | inl a0 => fun x : A => a0 * x	           | inr b => fun x : A => b * x	           end) mon_unit w)) =	  h	    (f a *	     List.fold_right B (A + A)	       (fun X0 : A + A =>	        match X0 with	        | inl a0 => fun x : B => f a0 * x	        | inr b => fun x : B => g b * x	        end) mon_unit w)		goal 2 (ID 736) is:	 h	   (g a *	    g	      (List.fold_right A (A + A)	         (fun X0 : A + A =>	          match X0 with	          | inl a0 => fun x : A => a0 * x	          | inr b => fun x : A => b * x	          end) mon_unit w)) =	 h	   (g a *	    List.fold_right B (A + A)	      (fun X0 : A + A =>	       match X0 with	       | inl a0 => fun x : B => f a0 * x	       | inr b => fun x : B => g b * x	       end) mon_unit w)	";
            responses[i]=data;
          

            i = 47;
            data = "1 goal (ID 827)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h (g a) = h (f a)	";
            responses[i]=data;
          

            i = 48;
            data = "1 goal (ID 843)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  p : (fun x : A => h (f x)) == (fun x : A => h (g x))	  a : A	  w : list (A + A)	  IHw : h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w)))) =	        h (FreeProduct_rec A A B f g (tr (coeq w)))	  ============================	  h (f a) = h (g a)	";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "3 goals		goal 1 (ID 107) is:	 {b : GroupHomomorphism A C &	 (fun x : FreeProduct A A =>	  b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	 (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} ->	 (fun x : A => h (f x)) == (fun x : A => h (g x))	goal 2 (ID 109) is:	 (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	  (grp_homo_compose h f;	  fun x : FreeProduct A A =>	  p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x0 : A => a0 * x0	                      | inr b => fun x0 : A => b * x0	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x0 : B => f a0 * x0	                   | inr b => fun x0 : B => g b * x0	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0)))	           with	           | inl a0 =>	               (fun a1 : A =>	                ap h	                  (grp_homo_op g a1	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a2 => fun x0 : A => a2 * x0	                         | inr b => fun x0 : A => b * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a1)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @ ap11 (ap11 1 (p a1)^) IHw) @	                 (grp_homo_op h (f a1)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a2 => fun x0 : B => f a2 * x0	                        | inr b => fun x0 : B => g b * x0	                        end) mon_unit w0))^)) a0	           | inr b =>	               (fun a0 : A =>	                ap h	                  (grp_homo_op g a0	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a1 => fun x0 : A => a1 * x0	                         | inr b0 => fun x0 : A => b0 * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a0)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @ ap11 1 IHw) @	                 (grp_homo_op h (g a0)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x0 : B => f a1 * x0	                        | inr b0 => fun x0 : B => g b0 * x0	                        end) mon_unit w0))^)) b	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             ((fun w : FreeProduct.Words A A =>	               list_rect	                 (fun w0 : list (A + A) =>	                  h	                    (g	                       (FreeProduct_rec A A A grp_homo_id grp_homo_id	                          (tr (coeq w0)))) =	                  h (FreeProduct_rec A A B f g (tr (coeq w0))))	                 (ap h (grp_homo_unit g))	                 (fun (a : A + A) (w0 : list (A + A))	                    (IHw : h	                             (g	                                (FreeProduct_rec A A A grp_homo_id	                                   grp_homo_id (tr (coeq w0)))) =	                           h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                  match	                    a as s	                    return	                      (h	                         (g	                            (match s with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a0 => fun x0 : A => a0 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0))) =	                       h	                         (match s with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : B => f a0 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0)))	                  with	                  | inl a0 =>	                      (fun a1 : A =>	                       ap h	                         (grp_homo_op g a1	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a1)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ap11 (ap11 1 (p a1)^) IHw) @	                        (grp_homo_op h (f a1)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : B => f a2 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0))^)) a0	                  | inr b0 =>	                      (fun a0 : A =>	                       ap h	                         (grp_homo_op g a0	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a0)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @ 	                         ap11 1 IHw) @	                        (grp_homo_op h (g a0)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : B => f a1 * x0	                               | inr b1 => fun x0 : B => g b1 * x0	                               end) mon_unit w0))^)) b0	                  end) w)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          ((fun w : FreeProduct.Words A A =>	            list_rect	              (fun w0 : list (A + A) =>	               h	                 (g	                    (FreeProduct_rec A A A grp_homo_id grp_homo_id	                       (tr (coeq w0)))) =	               h (FreeProduct_rec A A B f g (tr (coeq w0))))	              (ap h (grp_homo_unit g))	              (fun (a : A + A) (w0 : list (A + A))	                 (IHw : h	                          (g	                             (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                (tr (coeq w0)))) =	                        h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	               match	                 a as s	                 return	                   (h	                      (g	                         (match s with	                          | inl a0 => fun x0 : A => a0 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0))) =	                    h	                      (match s with	                       | inl a0 => fun x0 : B => f a0 * x0	                       | inr b0 => fun x0 : B => g b0 * x0	                       end	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w0)))	               with	               | inl a0 =>	                   (fun a1 : A =>	                    ap h	                      (grp_homo_op g a1	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a1)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @ 	                      ap11 (ap11 1 (p a1)^) IHw) @	                     (grp_homo_op h (f a1)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : B => f a2 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end) mon_unit w0))^)) a0	               | inr b0 =>	                   (fun a0 : A =>	                    ap h	                      (grp_homo_op g a0	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b1 => fun x0 : A => b1 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a0)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @ 	                      ap11 1 IHw) @	                     (grp_homo_op h (g a0)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : B => f a1 * x0	                            | inr b1 => fun x0 : B => g b1 * x0	                            end) mon_unit w0))^)) b0	               end) w)	             (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x))	 o ?g == idmap	goal 3 (ID 111) is:	 ?g	 o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	    (grp_homo_compose h f;	    fun x : FreeProduct A A =>	    p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	    Trunc_ind	      (fun	         aa : Trunc 0	                (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	       h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	       h (FreeProduct_rec A A B f g aa))	      (Coeq_ind	         (fun	            w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	          h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	          h (FreeProduct_rec A A B f g (tr w)))	         (fun w : FreeProduct.Words A A =>	          list_rect	            (fun w0 : list (A + A) =>	             h	               (g	                  (FreeProduct_rec A A A grp_homo_id grp_homo_id	                     (tr (coeq w0)))) =	             h (FreeProduct_rec A A B f g (tr (coeq w0))))	            (ap h (grp_homo_unit g))	            (fun (a : A + A) (w0 : list (A + A))	               (IHw : h	                        (g	                           (FreeProduct_rec A A A grp_homo_id grp_homo_id	                              (tr (coeq w0)))) =	                      h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	             match	               a as s	               return	                 (h	                    (g	                       (match s with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b => fun x0 : A => b * x0	                        end	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0))) =	                  h	                    (match s with	                     | inl a0 => fun x0 : B => f a0 * x0	                     | inr b => fun x0 : B => g b * x0	                     end	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0)))	             with	             | inl a0 =>	                 (fun a1 : A =>	                  ap h	                    (grp_homo_op g a1	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a1)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0)) @ 	                    ap11 (ap11 1 (p a1)^) IHw) @	                   (grp_homo_op h (f a1)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : B => f a2 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0))^)) a0	             | inr b =>	                 (fun a0 : A =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @ 	                    ap11 1 IHw) @	                   (grp_homo_op h (g a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w0))^)) b	             end) w)	         (fun	            b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                FreeProduct.pc3 grp_trivial A A + 	                FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	          path_ishprop	            (transport	               (fun	                  w : Coeq	                        (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	                =>	                h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                h (FreeProduct_rec A A B f g (tr w))) 	               (cglue b)	               ((fun w : FreeProduct.Words A A =>	                 list_rect	                   (fun w0 : list (A + A) =>	                    h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0))))	                   (ap h (grp_homo_unit g))	                   (fun (a : A + A) (w0 : list (A + A))	                      (IHw : h	                               (g	                                  (FreeProduct_rec A A A grp_homo_id	                                     grp_homo_id (tr (coeq w0)))) =	                             h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                    match	                      a as s	                      return	                        (h	                           (g	                              (match s with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a0 => fun x0 : A => a0 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0))) =	                         h	                           (match s with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : B => f a0 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0)))	                    with	                    | inl a0 =>	                        (fun a1 : A =>	                         ap h	                           (grp_homo_op g a1	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a1)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a2 => fun x0 : A => a2 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0)) @	                           ap11 (ap11 1 (p a1)^) IHw) @	                          (grp_homo_op h (f a1)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : B => f a2 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0))^)) a0	                    | inr b0 =>	                        (fun a0 : A =>	                         ap h	                           (grp_homo_op g a0	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a0)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a1 => fun x0 : A => a1 * x0	                                    | inr b1 => fun x0 : A => b1 * x0	                                    end) mon_unit w0)) @ 	                           ap11 1 IHw) @	                          (grp_homo_op h (g a0)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : B => f a1 * x0	                                 | inr b1 => fun x0 : B => g b1 * x0	                                 end) mon_unit w0))^)) b0	                    end) w)	                  (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	            ((fun w : FreeProduct.Words A A =>	              list_rect	                (fun w0 : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w0)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w0))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w0 : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w0)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0)))	                 with	                 | inl a0 =>	                     (fun a1 : A =>	                      ap h	                        (grp_homo_op g a1	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a1)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ap11 (ap11 1 (p a1)^) IHw) @	                       (grp_homo_op h (f a1)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : B => f a2 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0))^)) a0	                 | inr b0 =>	                     (fun a0 : A =>	                      ap h	                        (grp_homo_op g a0	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a0)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @ 	                        ap11 1 IHw) @	                       (grp_homo_op h (g a0)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : B => f a1 * x0	                              | inr b1 => fun x0 : B => g b1 * x0	                              end) mon_unit w0))^)) b0	                 end) w)	               (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	 idmap	";
            responses[i]=data;
          

            i = 52;
            data = "3 goals (ID 107)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} ->	  (fun x : A => h (f x)) == (fun x : A => h (g x))		goal 2 (ID 109) is:	 (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	  (grp_homo_compose h f;	  fun x : FreeProduct A A =>	  p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x0 : A => a0 * x0	                      | inr b => fun x0 : A => b * x0	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x0 : B => f a0 * x0	                   | inr b => fun x0 : B => g b * x0	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0)))	           with	           | inl a0 =>	               (fun a1 : A =>	                ap h	                  (grp_homo_op g a1	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a2 => fun x0 : A => a2 * x0	                         | inr b => fun x0 : A => b * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a1)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @ ap11 (ap11 1 (p a1)^) IHw) @	                 (grp_homo_op h (f a1)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a2 => fun x0 : B => f a2 * x0	                        | inr b => fun x0 : B => g b * x0	                        end) mon_unit w0))^)) a0	           | inr b =>	               (fun a0 : A =>	                ap h	                  (grp_homo_op g a0	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a1 => fun x0 : A => a1 * x0	                         | inr b0 => fun x0 : A => b0 * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a0)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @ ap11 1 IHw) @	                 (grp_homo_op h (g a0)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x0 : B => f a1 * x0	                        | inr b0 => fun x0 : B => g b0 * x0	                        end) mon_unit w0))^)) b	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             ((fun w : FreeProduct.Words A A =>	               list_rect	                 (fun w0 : list (A + A) =>	                  h	                    (g	                       (FreeProduct_rec A A A grp_homo_id grp_homo_id	                          (tr (coeq w0)))) =	                  h (FreeProduct_rec A A B f g (tr (coeq w0))))	                 (ap h (grp_homo_unit g))	                 (fun (a : A + A) (w0 : list (A + A))	                    (IHw : h	                             (g	                                (FreeProduct_rec A A A grp_homo_id	                                   grp_homo_id (tr (coeq w0)))) =	                           h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                  match	                    a as s	                    return	                      (h	                         (g	                            (match s with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a0 => fun x0 : A => a0 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0))) =	                       h	                         (match s with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : B => f a0 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0)))	                  with	                  | inl a0 =>	                      (fun a1 : A =>	                       ap h	                         (grp_homo_op g a1	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a1)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ap11 (ap11 1 (p a1)^) IHw) @	                        (grp_homo_op h (f a1)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : B => f a2 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0))^)) a0	                  | inr b0 =>	                      (fun a0 : A =>	                       ap h	                         (grp_homo_op g a0	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a0)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @ 	                         ap11 1 IHw) @	                        (grp_homo_op h (g a0)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : B => f a1 * x0	                               | inr b1 => fun x0 : B => g b1 * x0	                               end) mon_unit w0))^)) b0	                  end) w)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          ((fun w : FreeProduct.Words A A =>	            list_rect	              (fun w0 : list (A + A) =>	               h	                 (g	                    (FreeProduct_rec A A A grp_homo_id grp_homo_id	                       (tr (coeq w0)))) =	               h (FreeProduct_rec A A B f g (tr (coeq w0))))	              (ap h (grp_homo_unit g))	              (fun (a : A + A) (w0 : list (A + A))	                 (IHw : h	                          (g	                             (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                (tr (coeq w0)))) =	                        h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	               match	                 a as s	                 return	                   (h	                      (g	                         (match s with	                          | inl a0 => fun x0 : A => a0 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0))) =	                    h	                      (match s with	                       | inl a0 => fun x0 : B => f a0 * x0	                       | inr b0 => fun x0 : B => g b0 * x0	                       end	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w0)))	               with	               | inl a0 =>	                   (fun a1 : A =>	                    ap h	                      (grp_homo_op g a1	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a1)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @ 	                      ap11 (ap11 1 (p a1)^) IHw) @	                     (grp_homo_op h (f a1)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : B => f a2 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end) mon_unit w0))^)) a0	               | inr b0 =>	                   (fun a0 : A =>	                    ap h	                      (grp_homo_op g a0	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b1 => fun x0 : A => b1 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a0)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @ 	                      ap11 1 IHw) @	                     (grp_homo_op h (g a0)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : B => f a1 * x0	                            | inr b1 => fun x0 : B => g b1 * x0	                            end) mon_unit w0))^)) b0	               end) w)	             (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x))	 o ?g == idmap	goal 3 (ID 111) is:	 ?g	 o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	    (grp_homo_compose h f;	    fun x : FreeProduct A A =>	    p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	    Trunc_ind	      (fun	         aa : Trunc 0	                (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	       h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	       h (FreeProduct_rec A A B f g aa))	      (Coeq_ind	         (fun	            w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	          h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	          h (FreeProduct_rec A A B f g (tr w)))	         (fun w : FreeProduct.Words A A =>	          list_rect	            (fun w0 : list (A + A) =>	             h	               (g	                  (FreeProduct_rec A A A grp_homo_id grp_homo_id	                     (tr (coeq w0)))) =	             h (FreeProduct_rec A A B f g (tr (coeq w0))))	            (ap h (grp_homo_unit g))	            (fun (a : A + A) (w0 : list (A + A))	               (IHw : h	                        (g	                           (FreeProduct_rec A A A grp_homo_id grp_homo_id	                              (tr (coeq w0)))) =	                      h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	             match	               a as s	               return	                 (h	                    (g	                       (match s with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b => fun x0 : A => b * x0	                        end	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0))) =	                  h	                    (match s with	                     | inl a0 => fun x0 : B => f a0 * x0	                     | inr b => fun x0 : B => g b * x0	                     end	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0)))	             with	             | inl a0 =>	                 (fun a1 : A =>	                  ap h	                    (grp_homo_op g a1	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a1)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0)) @ 	                    ap11 (ap11 1 (p a1)^) IHw) @	                   (grp_homo_op h (f a1)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : B => f a2 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0))^)) a0	             | inr b =>	                 (fun a0 : A =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @ 	                    ap11 1 IHw) @	                   (grp_homo_op h (g a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w0))^)) b	             end) w)	         (fun	            b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                FreeProduct.pc3 grp_trivial A A + 	                FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	          path_ishprop	            (transport	               (fun	                  w : Coeq	                        (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	                =>	                h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                h (FreeProduct_rec A A B f g (tr w))) 	               (cglue b)	               ((fun w : FreeProduct.Words A A =>	                 list_rect	                   (fun w0 : list (A + A) =>	                    h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0))))	                   (ap h (grp_homo_unit g))	                   (fun (a : A + A) (w0 : list (A + A))	                      (IHw : h	                               (g	                                  (FreeProduct_rec A A A grp_homo_id	                                     grp_homo_id (tr (coeq w0)))) =	                             h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                    match	                      a as s	                      return	                        (h	                           (g	                              (match s with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a0 => fun x0 : A => a0 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0))) =	                         h	                           (match s with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : B => f a0 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0)))	                    with	                    | inl a0 =>	                        (fun a1 : A =>	                         ap h	                           (grp_homo_op g a1	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a1)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a2 => fun x0 : A => a2 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0)) @	                           ap11 (ap11 1 (p a1)^) IHw) @	                          (grp_homo_op h (f a1)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : B => f a2 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0))^)) a0	                    | inr b0 =>	                        (fun a0 : A =>	                         ap h	                           (grp_homo_op g a0	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a0)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a1 => fun x0 : A => a1 * x0	                                    | inr b1 => fun x0 : A => b1 * x0	                                    end) mon_unit w0)) @ 	                           ap11 1 IHw) @	                          (grp_homo_op h (g a0)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : B => f a1 * x0	                                 | inr b1 => fun x0 : B => g b1 * x0	                                 end) mon_unit w0))^)) b0	                    end) w)	                  (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	            ((fun w : FreeProduct.Words A A =>	              list_rect	                (fun w0 : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w0)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w0))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w0 : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w0)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0)))	                 with	                 | inl a0 =>	                     (fun a1 : A =>	                      ap h	                        (grp_homo_op g a1	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a1)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ap11 (ap11 1 (p a1)^) IHw) @	                       (grp_homo_op h (f a1)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : B => f a2 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0))^)) a0	                 | inr b0 =>	                     (fun a0 : A =>	                      ap h	                        (grp_homo_op g a0	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a0)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @ 	                        ap11 1 IHw) @	                       (grp_homo_op h (g a0)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : B => f a1 * x0	                              | inr b1 => fun x0 : B => g b1 * x0	                              end) mon_unit w0))^)) b0	                 end) w)	               (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	 idmap	1 goal (ID 107)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  {b : GroupHomomorphism A C &	  (fun x : FreeProduct A A =>	   b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	  (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} ->	  (fun x : A => h (f x)) == (fun x : A => h (g x))	1 goal (ID 850)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  x : A	  ============================	  h (f x) = h (g x)	1 goal (ID 854)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  x : A	  q1 : (fun x : FreeProduct A A =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	         (freeproduct_inl x) =	       (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	         (freeproduct_inl x)	  ============================	  h (f x) = h (g x)	1 goal (ID 858)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  x : A	  q1 : (fun x : FreeProduct A A =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	         (freeproduct_inl x) =	       (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	         (freeproduct_inl x)	  q2 : (fun x : FreeProduct A A =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	         (freeproduct_inr x) =	       (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	         (freeproduct_inr x)	  ============================	  h (f x) = h (g x)	1 goal (ID 867)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  x : A	  q1 : k (x * mon_unit) = h (f x * mon_unit)	  q2 : k (x * mon_unit) = h (g x * mon_unit)	  ============================	  h (f x) = h (g x)	";
            responses[i]=data;
          

            i = 53;
            data = "1 goal (ID 1047)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  x : A	  q1 : k x = h (f x)	  q2 : k x = h (g x)	  ============================	  h (f x) = h (g x)	";
            responses[i]=data;
          

            i = 54;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "2 goals		goal 1 (ID 109) is:	 (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	  (grp_homo_compose h f;	  fun x : FreeProduct A A =>	  p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x0 : A => a0 * x0	                      | inr b => fun x0 : A => b * x0	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x0 : B => f a0 * x0	                   | inr b => fun x0 : B => g b * x0	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0)))	           with	           | inl a0 =>	               (fun a1 : A =>	                ap h	                  (grp_homo_op g a1	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a2 => fun x0 : A => a2 * x0	                         | inr b => fun x0 : A => b * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a1)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @ ap11 (ap11 1 (p a1)^) IHw) @	                 (grp_homo_op h (f a1)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a2 => fun x0 : B => f a2 * x0	                        | inr b => fun x0 : B => g b * x0	                        end) mon_unit w0))^)) a0	           | inr b =>	               (fun a0 : A =>	                ap h	                  (grp_homo_op g a0	                     (List.fold_right A (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a1 => fun x0 : A => a1 * x0	                         | inr b0 => fun x0 : A => b0 * x0	                         end) mon_unit w0)) @	                ((grp_homo_op h (g a0)	                    (g	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @ ap11 1 IHw) @	                 (grp_homo_op h (g a0)	                    (List.fold_right B (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x0 : B => f a1 * x0	                        | inr b0 => fun x0 : B => g b0 * x0	                        end) mon_unit w0))^)) b	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             ((fun w : FreeProduct.Words A A =>	               list_rect	                 (fun w0 : list (A + A) =>	                  h	                    (g	                       (FreeProduct_rec A A A grp_homo_id grp_homo_id	                          (tr (coeq w0)))) =	                  h (FreeProduct_rec A A B f g (tr (coeq w0))))	                 (ap h (grp_homo_unit g))	                 (fun (a : A + A) (w0 : list (A + A))	                    (IHw : h	                             (g	                                (FreeProduct_rec A A A grp_homo_id	                                   grp_homo_id (tr (coeq w0)))) =	                           h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                  match	                    a as s	                    return	                      (h	                         (g	                            (match s with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a0 => fun x0 : A => a0 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0))) =	                       h	                         (match s with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : B => f a0 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0)))	                  with	                  | inl a0 =>	                      (fun a1 : A =>	                       ap h	                         (grp_homo_op g a1	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a1)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ap11 (ap11 1 (p a1)^) IHw) @	                        (grp_homo_op h (f a1)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : B => f a2 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0))^)) a0	                  | inr b0 =>	                      (fun a0 : A =>	                       ap h	                         (grp_homo_op g a0	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a0)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @ 	                         ap11 1 IHw) @	                        (grp_homo_op h (g a0)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : B => f a1 * x0	                               | inr b1 => fun x0 : B => g b1 * x0	                               end) mon_unit w0))^)) b0	                  end) w)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          ((fun w : FreeProduct.Words A A =>	            list_rect	              (fun w0 : list (A + A) =>	               h	                 (g	                    (FreeProduct_rec A A A grp_homo_id grp_homo_id	                       (tr (coeq w0)))) =	               h (FreeProduct_rec A A B f g (tr (coeq w0))))	              (ap h (grp_homo_unit g))	              (fun (a : A + A) (w0 : list (A + A))	                 (IHw : h	                          (g	                             (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                (tr (coeq w0)))) =	                        h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	               match	                 a as s	                 return	                   (h	                      (g	                         (match s with	                          | inl a0 => fun x0 : A => a0 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0))) =	                    h	                      (match s with	                       | inl a0 => fun x0 : B => f a0 * x0	                       | inr b0 => fun x0 : B => g b0 * x0	                       end	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w0)))	               with	               | inl a0 =>	                   (fun a1 : A =>	                    ap h	                      (grp_homo_op g a1	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a1)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @ 	                      ap11 (ap11 1 (p a1)^) IHw) @	                     (grp_homo_op h (f a1)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : B => f a2 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end) mon_unit w0))^)) a0	               | inr b0 =>	                   (fun a0 : A =>	                    ap h	                      (grp_homo_op g a0	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b1 => fun x0 : A => b1 * x0	                             end) mon_unit w0)) @	                    ((grp_homo_op h (g a0)	                        (g	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @ 	                      ap11 1 IHw) @	                     (grp_homo_op h (g a0)	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : B => f a1 * x0	                            | inr b1 => fun x0 : B => g b1 * x0	                            end) mon_unit w0))^)) b0	               end) w)	             (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x))	 o (fun	      X : {b : GroupHomomorphism A C &	          (fun x : FreeProduct A A =>	           b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	          (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	    (fun (k : GroupHomomorphism A C)	       (p : (fun x : FreeProduct A A =>	             k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	            (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	       (x : A) =>	     let q1 := p (freeproduct_inl x) in	     let q2 := p (freeproduct_inr x) in	     let q0 :=	       internal_paths_rew A (x * mon_unit)	         (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	         (right_identity x) in	     let q3 :=	       internal_paths_rew A (x * mon_unit)	         (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	         (right_identity x) in	     let q4 :=	       internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	         (f x) (right_identity (f x)) in	     let q5 :=	       internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	         (g x) (right_identity (g x)) in	     q4^ @ q5) X.1 X.2) == idmap	goal 2 (ID 111) is:	 (fun	    X : {b : GroupHomomorphism A C &	        (fun x : FreeProduct A A =>	         b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	        (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	  (fun (k : GroupHomomorphism A C)	     (p : (fun x : FreeProduct A A =>	           k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	          (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	     (x : A) =>	   let q1 := p (freeproduct_inl x) in	   let q2 := p (freeproduct_inr x) in	   let q0 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	       (right_identity x) in	   let q3 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	       (right_identity x) in	   let q4 :=	     internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	       (f x) (right_identity (f x)) in	   let q5 :=	     internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	       (g x) (right_identity (g x)) in	   q4^ @ q5) X.1 X.2)	 o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	    (grp_homo_compose h f;	    fun x : FreeProduct A A =>	    p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	    Trunc_ind	      (fun	         aa : Trunc 0	                (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	       h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	       h (FreeProduct_rec A A B f g aa))	      (Coeq_ind	         (fun	            w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	          h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	          h (FreeProduct_rec A A B f g (tr w)))	         (fun w : FreeProduct.Words A A =>	          list_rect	            (fun w0 : list (A + A) =>	             h	               (g	                  (FreeProduct_rec A A A grp_homo_id grp_homo_id	                     (tr (coeq w0)))) =	             h (FreeProduct_rec A A B f g (tr (coeq w0))))	            (ap h (grp_homo_unit g))	            (fun (a : A + A) (w0 : list (A + A))	               (IHw : h	                        (g	                           (FreeProduct_rec A A A grp_homo_id grp_homo_id	                              (tr (coeq w0)))) =	                      h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	             match	               a as s	               return	                 (h	                    (g	                       (match s with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b => fun x0 : A => b * x0	                        end	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0))) =	                  h	                    (match s with	                     | inl a0 => fun x0 : B => f a0 * x0	                     | inr b => fun x0 : B => g b * x0	                     end	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0)))	             with	             | inl a0 =>	                 (fun a1 : A =>	                  ap h	                    (grp_homo_op g a1	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a1)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0)) @ 	                    ap11 (ap11 1 (p a1)^) IHw) @	                   (grp_homo_op h (f a1)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : B => f a2 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0))^)) a0	             | inr b =>	                 (fun a0 : A =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @ 	                    ap11 1 IHw) @	                   (grp_homo_op h (g a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w0))^)) b	             end) w)	         (fun	            b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                FreeProduct.pc3 grp_trivial A A + 	                FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	          path_ishprop	            (transport	               (fun	                  w : Coeq	                        (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	                =>	                h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                h (FreeProduct_rec A A B f g (tr w))) 	               (cglue b)	               ((fun w : FreeProduct.Words A A =>	                 list_rect	                   (fun w0 : list (A + A) =>	                    h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0))))	                   (ap h (grp_homo_unit g))	                   (fun (a : A + A) (w0 : list (A + A))	                      (IHw : h	                               (g	                                  (FreeProduct_rec A A A grp_homo_id	                                     grp_homo_id (tr (coeq w0)))) =	                             h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                    match	                      a as s	                      return	                        (h	                           (g	                              (match s with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a0 => fun x0 : A => a0 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0))) =	                         h	                           (match s with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : B => f a0 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0)))	                    with	                    | inl a0 =>	                        (fun a1 : A =>	                         ap h	                           (grp_homo_op g a1	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a1)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a2 => fun x0 : A => a2 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0)) @	                           ap11 (ap11 1 (p a1)^) IHw) @	                          (grp_homo_op h (f a1)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : B => f a2 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0))^)) a0	                    | inr b0 =>	                        (fun a0 : A =>	                         ap h	                           (grp_homo_op g a0	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a0)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a1 => fun x0 : A => a1 * x0	                                    | inr b1 => fun x0 : A => b1 * x0	                                    end) mon_unit w0)) @ 	                           ap11 1 IHw) @	                          (grp_homo_op h (g a0)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : B => f a1 * x0	                                 | inr b1 => fun x0 : B => g b1 * x0	                                 end) mon_unit w0))^)) b0	                    end) w)	                  (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	            ((fun w : FreeProduct.Words A A =>	              list_rect	                (fun w0 : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w0)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w0))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w0 : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w0)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0)))	                 with	                 | inl a0 =>	                     (fun a1 : A =>	                      ap h	                        (grp_homo_op g a1	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a1)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ap11 (ap11 1 (p a1)^) IHw) @	                       (grp_homo_op h (f a1)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : B => f a2 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0))^)) a0	                 | inr b0 =>	                     (fun a0 : A =>	                      ap h	                        (grp_homo_op g a0	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a0)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @ 	                        ap11 1 IHw) @	                       (grp_homo_op h (g a0)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : B => f a1 * x0	                              | inr b1 => fun x0 : B => g b1 * x0	                              end) mon_unit w0))^)) b0	                 end) w)	               (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	 idmap	2 goals (ID 109)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	   (grp_homo_compose h f;	   fun x : FreeProduct A A =>	   p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	   Trunc_ind	     (fun	        aa : Trunc 0	               (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	      h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	      h (FreeProduct_rec A A B f g aa))	     (Coeq_ind	        (fun	           w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	         h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	         h (FreeProduct_rec A A B f g (tr w)))	        (fun w : FreeProduct.Words A A =>	         list_rect	           (fun w0 : list (A + A) =>	            h	              (g	                 (FreeProduct_rec A A A grp_homo_id grp_homo_id	                    (tr (coeq w0)))) =	            h (FreeProduct_rec A A B f g (tr (coeq w0))))	           (ap h (grp_homo_unit g))	           (fun (a : A + A) (w0 : list (A + A))	              (IHw : h	                       (g	                          (FreeProduct_rec A A A grp_homo_id grp_homo_id	                             (tr (coeq w0)))) =	                     h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	            match	              a as s	              return	                (h	                   (g	                      (match s with	                       | inl a0 => fun x0 : A => a0 * x0	                       | inr b => fun x0 : A => b * x0	                       end	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0))) =	                 h	                   (match s with	                    | inl a0 => fun x0 : B => f a0 * x0	                    | inr b => fun x0 : B => g b * x0	                    end	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0)))	            with	            | inl a0 =>	                (fun a1 : A =>	                 ap h	                   (grp_homo_op g a1	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : A => a2 * x0	                          | inr b => fun x0 : A => b * x0	                          end) mon_unit w0)) @	                 ((grp_homo_op h (g a1)	                     (g	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : A => a2 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0)) @ ap11 (ap11 1 (p a1)^) IHw) @	                  (grp_homo_op h (f a1)	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a2 => fun x0 : B => f a2 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0))^)) a0	            | inr b =>	                (fun a0 : A =>	                 ap h	                   (grp_homo_op g a0	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : A => a1 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end) mon_unit w0)) @	                 ((grp_homo_op h (g a0)	                     (g	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : A => a1 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end) mon_unit w0)) @ ap11 1 IHw) @	                  (grp_homo_op h (g a0)	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a1 => fun x0 : B => f a1 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end) mon_unit w0))^)) b	            end) w)	        (fun	           b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	               FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	               FreeProduct.pc5 A A =>	         path_ishprop	           (transport	              (fun	                 w : Coeq	                       (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                       (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	               =>	               h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	               h (FreeProduct_rec A A B f g (tr w))) 	              (cglue b)	              ((fun w : FreeProduct.Words A A =>	                list_rect	                  (fun w0 : list (A + A) =>	                   h	                     (g	                        (FreeProduct_rec A A A grp_homo_id grp_homo_id	                           (tr (coeq w0)))) =	                   h (FreeProduct_rec A A B f g (tr (coeq w0))))	                  (ap h (grp_homo_unit g))	                  (fun (a : A + A) (w0 : list (A + A))	                     (IHw : h	                              (g	                                 (FreeProduct_rec A A A grp_homo_id	                                    grp_homo_id (tr (coeq w0)))) =	                            h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                   match	                     a as s	                     return	                       (h	                          (g	                             (match s with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a0 => fun x0 : A => a0 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0))) =	                        h	                          (match s with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b0 => fun x0 : B => g b0 * x0	                           end	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a0 => fun x0 : B => f a0 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0)))	                   with	                   | inl a0 =>	                       (fun a1 : A =>	                        ap h	                          (grp_homo_op g a1	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ((grp_homo_op h (g a1)	                            (g	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a2 => fun x0 : A => a2 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0)) @	                          ap11 (ap11 1 (p a1)^) IHw) @	                         (grp_homo_op h (f a1)	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : B => f a2 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0))^)) a0	                   | inr b0 =>	                       (fun a0 : A =>	                        ap h	                          (grp_homo_op g a0	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @	                        ((grp_homo_op h (g a0)	                            (g	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a1 => fun x0 : A => a1 * x0	                                   | inr b1 => fun x0 : A => b1 * x0	                                   end) mon_unit w0)) @ 	                          ap11 1 IHw) @	                         (grp_homo_op h (g a0)	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : B => f a1 * x0	                                | inr b1 => fun x0 : B => g b1 * x0	                                end) mon_unit w0))^)) b0	                   end) w)	                 (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	           ((fun w : FreeProduct.Words A A =>	             list_rect	               (fun w0 : list (A + A) =>	                h	                  (g	                     (FreeProduct_rec A A A grp_homo_id grp_homo_id	                        (tr (coeq w0)))) =	                h (FreeProduct_rec A A B f g (tr (coeq w0))))	               (ap h (grp_homo_unit g))	               (fun (a : A + A) (w0 : list (A + A))	                  (IHw : h	                           (g	                              (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                 (tr (coeq w0)))) =	                         h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                match	                  a as s	                  return	                    (h	                       (g	                          (match s with	                           | inl a0 => fun x0 : A => a0 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a0 => fun x0 : A => a0 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0))) =	                     h	                       (match s with	                        | inl a0 => fun x0 : B => f a0 * x0	                        | inr b0 => fun x0 : B => g b0 * x0	                        end	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : B => f a0 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0)))	                with	                | inl a0 =>	                    (fun a1 : A =>	                     ap h	                       (grp_homo_op g a1	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : A => a2 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end) mon_unit w0)) @	                     ((grp_homo_op h (g a1)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ap11 (ap11 1 (p a1)^) IHw) @	                      (grp_homo_op h (f a1)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : B => f a2 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w0))^)) a0	                | inr b0 =>	                    (fun a0 : A =>	                     ap h	                       (grp_homo_op g a0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : A => a1 * x0	                              | inr b1 => fun x0 : A => b1 * x0	                              end) mon_unit w0)) @	                     ((grp_homo_op h (g a0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @ 	                       ap11 1 IHw) @	                      (grp_homo_op h (g a0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : B => f a1 * x0	                             | inr b1 => fun x0 : B => g b1 * x0	                             end) mon_unit w0))^)) b0	                end) w)	              (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x))	  o (fun	       X : {b : GroupHomomorphism A C &	           (fun x : FreeProduct A A =>	            b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	           (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	     (fun (k : GroupHomomorphism A C)	        (p : (fun x : FreeProduct A A =>	              k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	             (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	        (x : A) =>	      let q1 := p (freeproduct_inl x) in	      let q2 := p (freeproduct_inr x) in	      let q0 :=	        internal_paths_rew A (x * mon_unit)	          (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	          (right_identity x) in	      let q3 :=	        internal_paths_rew A (x * mon_unit)	          (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	          (right_identity x) in	      let q4 :=	        internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	          (f x) (right_identity (f x)) in	      let q5 :=	        internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	          (g x) (right_identity (g x)) in	      q4^ @ q5) X.1 X.2) == idmap		goal 2 (ID 111) is:	 (fun	    X : {b : GroupHomomorphism A C &	        (fun x : FreeProduct A A =>	         b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	        (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	  (fun (k : GroupHomomorphism A C)	     (p : (fun x : FreeProduct A A =>	           k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	          (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	     (x : A) =>	   let q1 := p (freeproduct_inl x) in	   let q2 := p (freeproduct_inr x) in	   let q0 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	       (right_identity x) in	   let q3 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	       (right_identity x) in	   let q4 :=	     internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	       (f x) (right_identity (f x)) in	   let q5 :=	     internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	       (g x) (right_identity (g x)) in	   q4^ @ q5) X.1 X.2)	 o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	    (grp_homo_compose h f;	    fun x : FreeProduct A A =>	    p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	    Trunc_ind	      (fun	         aa : Trunc 0	                (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	       h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	       h (FreeProduct_rec A A B f g aa))	      (Coeq_ind	         (fun	            w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	          h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	          h (FreeProduct_rec A A B f g (tr w)))	         (fun w : FreeProduct.Words A A =>	          list_rect	            (fun w0 : list (A + A) =>	             h	               (g	                  (FreeProduct_rec A A A grp_homo_id grp_homo_id	                     (tr (coeq w0)))) =	             h (FreeProduct_rec A A B f g (tr (coeq w0))))	            (ap h (grp_homo_unit g))	            (fun (a : A + A) (w0 : list (A + A))	               (IHw : h	                        (g	                           (FreeProduct_rec A A A grp_homo_id grp_homo_id	                              (tr (coeq w0)))) =	                      h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	             match	               a as s	               return	                 (h	                    (g	                       (match s with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b => fun x0 : A => b * x0	                        end	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0))) =	                  h	                    (match s with	                     | inl a0 => fun x0 : B => f a0 * x0	                     | inr b => fun x0 : B => g b * x0	                     end	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0)))	             with	             | inl a0 =>	                 (fun a1 : A =>	                  ap h	                    (grp_homo_op g a1	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a1)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0)) @ 	                    ap11 (ap11 1 (p a1)^) IHw) @	                   (grp_homo_op h (f a1)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : B => f a2 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0))^)) a0	             | inr b =>	                 (fun a0 : A =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @ 	                    ap11 1 IHw) @	                   (grp_homo_op h (g a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w0))^)) b	             end) w)	         (fun	            b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                FreeProduct.pc3 grp_trivial A A + 	                FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	          path_ishprop	            (transport	               (fun	                  w : Coeq	                        (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	                =>	                h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                h (FreeProduct_rec A A B f g (tr w))) 	               (cglue b)	               ((fun w : FreeProduct.Words A A =>	                 list_rect	                   (fun w0 : list (A + A) =>	                    h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0))))	                   (ap h (grp_homo_unit g))	                   (fun (a : A + A) (w0 : list (A + A))	                      (IHw : h	                               (g	                                  (FreeProduct_rec A A A grp_homo_id	                                     grp_homo_id (tr (coeq w0)))) =	                             h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                    match	                      a as s	                      return	                        (h	                           (g	                              (match s with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a0 => fun x0 : A => a0 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0))) =	                         h	                           (match s with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : B => f a0 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0)))	                    with	                    | inl a0 =>	                        (fun a1 : A =>	                         ap h	                           (grp_homo_op g a1	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a1)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a2 => fun x0 : A => a2 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0)) @	                           ap11 (ap11 1 (p a1)^) IHw) @	                          (grp_homo_op h (f a1)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : B => f a2 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0))^)) a0	                    | inr b0 =>	                        (fun a0 : A =>	                         ap h	                           (grp_homo_op g a0	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a0)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a1 => fun x0 : A => a1 * x0	                                    | inr b1 => fun x0 : A => b1 * x0	                                    end) mon_unit w0)) @ 	                           ap11 1 IHw) @	                          (grp_homo_op h (g a0)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : B => f a1 * x0	                                 | inr b1 => fun x0 : B => g b1 * x0	                                 end) mon_unit w0))^)) b0	                    end) w)	                  (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	            ((fun w : FreeProduct.Words A A =>	              list_rect	                (fun w0 : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w0)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w0))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w0 : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w0)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0)))	                 with	                 | inl a0 =>	                     (fun a1 : A =>	                      ap h	                        (grp_homo_op g a1	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a1)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ap11 (ap11 1 (p a1)^) IHw) @	                       (grp_homo_op h (f a1)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : B => f a2 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0))^)) a0	                 | inr b0 =>	                     (fun a0 : A =>	                      ap h	                        (grp_homo_op g a0	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a0)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @ 	                        ap11 1 IHw) @	                       (grp_homo_op h (g a0)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : B => f a1 * x0	                              | inr b1 => fun x0 : B => g b1 * x0	                              end) mon_unit w0))^)) b0	                 end) w)	               (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	 idmap	1 goal (ID 109)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	   (grp_homo_compose h f;	   fun x : FreeProduct A A =>	   p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	   Trunc_ind	     (fun	        aa : Trunc 0	               (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	      h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	      h (FreeProduct_rec A A B f g aa))	     (Coeq_ind	        (fun	           w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	         h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	         h (FreeProduct_rec A A B f g (tr w)))	        (fun w : FreeProduct.Words A A =>	         list_rect	           (fun w0 : list (A + A) =>	            h	              (g	                 (FreeProduct_rec A A A grp_homo_id grp_homo_id	                    (tr (coeq w0)))) =	            h (FreeProduct_rec A A B f g (tr (coeq w0))))	           (ap h (grp_homo_unit g))	           (fun (a : A + A) (w0 : list (A + A))	              (IHw : h	                       (g	                          (FreeProduct_rec A A A grp_homo_id grp_homo_id	                             (tr (coeq w0)))) =	                     h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	            match	              a as s	              return	                (h	                   (g	                      (match s with	                       | inl a0 => fun x0 : A => a0 * x0	                       | inr b => fun x0 : A => b * x0	                       end	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0))) =	                 h	                   (match s with	                    | inl a0 => fun x0 : B => f a0 * x0	                    | inr b => fun x0 : B => g b * x0	                    end	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0)))	            with	            | inl a0 =>	                (fun a1 : A =>	                 ap h	                   (grp_homo_op g a1	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : A => a2 * x0	                          | inr b => fun x0 : A => b * x0	                          end) mon_unit w0)) @	                 ((grp_homo_op h (g a1)	                     (g	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : A => a2 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0)) @ ap11 (ap11 1 (p a1)^) IHw) @	                  (grp_homo_op h (f a1)	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a2 => fun x0 : B => f a2 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0))^)) a0	            | inr b =>	                (fun a0 : A =>	                 ap h	                   (grp_homo_op g a0	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : A => a1 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end) mon_unit w0)) @	                 ((grp_homo_op h (g a0)	                     (g	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : A => a1 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end) mon_unit w0)) @ ap11 1 IHw) @	                  (grp_homo_op h (g a0)	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a1 => fun x0 : B => f a1 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end) mon_unit w0))^)) b	            end) w)	        (fun	           b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	               FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	               FreeProduct.pc5 A A =>	         path_ishprop	           (transport	              (fun	                 w : Coeq	                       (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                       (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	               =>	               h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	               h (FreeProduct_rec A A B f g (tr w))) 	              (cglue b)	              ((fun w : FreeProduct.Words A A =>	                list_rect	                  (fun w0 : list (A + A) =>	                   h	                     (g	                        (FreeProduct_rec A A A grp_homo_id grp_homo_id	                           (tr (coeq w0)))) =	                   h (FreeProduct_rec A A B f g (tr (coeq w0))))	                  (ap h (grp_homo_unit g))	                  (fun (a : A + A) (w0 : list (A + A))	                     (IHw : h	                              (g	                                 (FreeProduct_rec A A A grp_homo_id	                                    grp_homo_id (tr (coeq w0)))) =	                            h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                   match	                     a as s	                     return	                       (h	                          (g	                             (match s with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a0 => fun x0 : A => a0 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0))) =	                        h	                          (match s with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b0 => fun x0 : B => g b0 * x0	                           end	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a0 => fun x0 : B => f a0 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0)))	                   with	                   | inl a0 =>	                       (fun a1 : A =>	                        ap h	                          (grp_homo_op g a1	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ((grp_homo_op h (g a1)	                            (g	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a2 => fun x0 : A => a2 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0)) @	                          ap11 (ap11 1 (p a1)^) IHw) @	                         (grp_homo_op h (f a1)	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : B => f a2 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0))^)) a0	                   | inr b0 =>	                       (fun a0 : A =>	                        ap h	                          (grp_homo_op g a0	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @	                        ((grp_homo_op h (g a0)	                            (g	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a1 => fun x0 : A => a1 * x0	                                   | inr b1 => fun x0 : A => b1 * x0	                                   end) mon_unit w0)) @ 	                          ap11 1 IHw) @	                         (grp_homo_op h (g a0)	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : B => f a1 * x0	                                | inr b1 => fun x0 : B => g b1 * x0	                                end) mon_unit w0))^)) b0	                   end) w)	                 (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	           ((fun w : FreeProduct.Words A A =>	             list_rect	               (fun w0 : list (A + A) =>	                h	                  (g	                     (FreeProduct_rec A A A grp_homo_id grp_homo_id	                        (tr (coeq w0)))) =	                h (FreeProduct_rec A A B f g (tr (coeq w0))))	               (ap h (grp_homo_unit g))	               (fun (a : A + A) (w0 : list (A + A))	                  (IHw : h	                           (g	                              (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                 (tr (coeq w0)))) =	                         h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                match	                  a as s	                  return	                    (h	                       (g	                          (match s with	                           | inl a0 => fun x0 : A => a0 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a0 => fun x0 : A => a0 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0))) =	                     h	                       (match s with	                        | inl a0 => fun x0 : B => f a0 * x0	                        | inr b0 => fun x0 : B => g b0 * x0	                        end	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : B => f a0 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0)))	                with	                | inl a0 =>	                    (fun a1 : A =>	                     ap h	                       (grp_homo_op g a1	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : A => a2 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end) mon_unit w0)) @	                     ((grp_homo_op h (g a1)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ap11 (ap11 1 (p a1)^) IHw) @	                      (grp_homo_op h (f a1)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : B => f a2 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w0))^)) a0	                | inr b0 =>	                    (fun a0 : A =>	                     ap h	                       (grp_homo_op g a0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : A => a1 * x0	                              | inr b1 => fun x0 : A => b1 * x0	                              end) mon_unit w0)) @	                     ((grp_homo_op h (g a0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @ 	                       ap11 1 IHw) @	                      (grp_homo_op h (g a0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : B => f a1 * x0	                             | inr b1 => fun x0 : B => g b1 * x0	                             end) mon_unit w0))^)) b0	                end) w)	              (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x))	  o (fun	       X : {b : GroupHomomorphism A C &	           (fun x : FreeProduct A A =>	            b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	           (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	     (fun (k : GroupHomomorphism A C)	        (p : (fun x : FreeProduct A A =>	              k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	             (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	        (x : A) =>	      let q1 := p (freeproduct_inl x) in	      let q2 := p (freeproduct_inr x) in	      let q0 :=	        internal_paths_rew A (x * mon_unit)	          (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	          (right_identity x) in	      let q3 :=	        internal_paths_rew A (x * mon_unit)	          (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	          (right_identity x) in	      let q4 :=	        internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	          (f x) (right_identity (f x)) in	      let q5 :=	        internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	          (g x) (right_identity (g x)) in	      q4^ @ q5) X.1 X.2) == idmap	1 goal (ID 1060)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  forall	  x : {b : GroupHomomorphism A C &	      (fun x : FreeProduct A A =>	       b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))},	  (grp_homo_compose h f;	  fun x0 : FreeProduct A A =>	  (let q1 :=	     x.2 (freeproduct_inl (FreeProduct_rec A A A grp_homo_id grp_homo_id x0))	     in	   let q2 :=	     x.2 (freeproduct_inr (FreeProduct_rec A A A grp_homo_id grp_homo_id x0))	     in	   let q0 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x0 * mon_unit)	       (fun g0 : A =>	        x.1 g0 =	        h (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) * mon_unit))	       q1 (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)) in	   let q3 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x0 * mon_unit)	       (fun g0 : A =>	        x.1 g0 =	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) * mon_unit))	       q2 (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)) in	   let q4 :=	     internal_paths_rew B	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) * mon_unit)	       (fun g0 : B =>	        x.1 (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) = h g0) q0	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x0))	       (right_identity (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)))	     in	   let q5 :=	     internal_paths_rew B	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) * mon_unit)	       (fun g0 : B =>	        x.1 (FreeProduct_rec A A A grp_homo_id grp_homo_id x0) = h g0) q3	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x0))	       (right_identity (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x0)))	     in	   q4^ @ q5) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x1 : A => a0 * x1	                      | inr b => fun x1 : A => b * x1	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x1 : A => a0 * x1	                            | inr b => fun x1 : A => b * x1	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x1 : B => f a0 * x1	                   | inr b => fun x1 : B => g b * x1	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x1 : B => f a0 * x1	                         | inr b => fun x1 : B => g b * x1	                         end) mon_unit w0)))	           with	           | inl a0 =>	               ap h	                 (grp_homo_op g a0	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x1 : A => a1 * x1	                        | inr b => fun x1 : A => b * x1	                        end) mon_unit w0)) @	               ((grp_homo_op h (g a0)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x1 : A => a1 * x1	                          | inr b => fun x1 : A => b * x1	                          end) mon_unit w0)) @	                 ap11	                   (ap11 1	                      (let q1 := x.2 (freeproduct_inl a0) in	                       let q2 := x.2 (freeproduct_inr a0) in	                       let q0 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => x.1 g0 = h (f a0 * mon_unit)) q1 a0	                           (right_identity a0) in	                       let q3 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => x.1 g0 = h (g a0 * mon_unit)) q2 a0	                           (right_identity a0) in	                       let q4 :=	                         internal_paths_rew B (f a0 * mon_unit)	                           (fun g0 : B => x.1 a0 = h g0) q0 	                           (f a0) (right_identity (f a0)) in	                       let q5 :=	                         internal_paths_rew B (g a0 * mon_unit)	                           (fun g0 : B => x.1 a0 = h g0) q3 	                           (g a0) (right_identity (g a0)) in	                       q4^ @ q5)^) IHw) @	                (grp_homo_op h (f a0)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a1 => fun x1 : B => f a1 * x1	                       | inr b => fun x1 : B => g b * x1	                       end) mon_unit w0))^)	           | inr b =>	               ap h	                 (grp_homo_op g b	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a0 => fun x1 : A => a0 * x1	                        | inr b0 => fun x1 : A => b0 * x1	                        end) mon_unit w0)) @	               ((grp_homo_op h (g b)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x1 : A => a0 * x1	                          | inr b0 => fun x1 : A => b0 * x1	                          end) mon_unit w0)) @ ap11 1 IHw) @	                (grp_homo_op h (g b)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a0 => fun x1 : B => f a0 * x1	                       | inr b0 => fun x1 : B => g b0 * x1	                       end) mon_unit w0))^)	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             (list_rect	                (fun w : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x1 : A => a0 * x1	                            | inr b0 => fun x1 : A => b0 * x1	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x1 : A => a0 * x1	                                  | inr b0 => fun x1 : A => b0 * x1	                                  end) mon_unit w))) =	                      h	                        (match s with	                         | inl a0 => fun x1 : B => f a0 * x1	                         | inr b0 => fun x1 : B => g b0 * x1	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x1 : B => f a0 * x1	                               | inr b0 => fun x1 : B => g b0 * x1	                               end) mon_unit w)))	                 with	                 | inl a0 =>	                     ap h	                       (grp_homo_op g a0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x1 : A => a1 * x1	                              | inr b0 => fun x1 : A => b0 * x1	                              end) mon_unit w)) @	                     ((grp_homo_op h (g a0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x1 : A => a1 * x1	                                | inr b0 => fun x1 : A => b0 * x1	                                end) mon_unit w)) @	                       ap11	                         (ap11 1	                            (let q1 := x.2 (freeproduct_inl a0) in	                             let q2 := x.2 (freeproduct_inr a0) in	                             let q0 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => x.1 g0 = h (f a0 * mon_unit))	                                 q1 a0 (right_identity a0) in	                             let q3 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => x.1 g0 = h (g a0 * mon_unit))	                                 q2 a0 (right_identity a0) in	                             let q4 :=	                               internal_paths_rew B 	                                 (f a0 * mon_unit)	                                 (fun g0 : B => x.1 a0 = h g0) q0 	                                 (f a0) (right_identity (f a0)) in	                             let q5 :=	                               internal_paths_rew B 	                                 (g a0 * mon_unit)	                                 (fun g0 : B => x.1 a0 = h g0) q3 	                                 (g a0) (right_identity (g a0)) in	                             q4^ @ q5)^) IHw) @	                      (grp_homo_op h (f a0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x1 : B => f a1 * x1	                             | inr b0 => fun x1 : B => g b0 * x1	                             end) mon_unit w))^)	                 | inr b0 =>	                     ap h	                       (grp_homo_op g b0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x1 : A => a0 * x1	                              | inr b1 => fun x1 : A => b1 * x1	                              end) mon_unit w)) @	                     ((grp_homo_op h (g b0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x1 : A => a0 * x1	                                | inr b1 => fun x1 : A => b1 * x1	                                end) mon_unit w)) @ 	                       ap11 1 IHw) @	                      (grp_homo_op h (g b0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x1 : B => f a0 * x1	                             | inr b1 => fun x1 : B => g b1 * x1	                             end) mon_unit w))^)	                 end)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          (list_rect	             (fun w : list (A + A) =>	              h	                (g	                   (FreeProduct_rec A A A grp_homo_id grp_homo_id	                      (tr (coeq w)))) =	              h (FreeProduct_rec A A B f g (tr (coeq w))))	             (ap h (grp_homo_unit g))	             (fun (a : A + A) (w : list (A + A))	                (IHw : h	                         (g	                            (FreeProduct_rec A A A grp_homo_id grp_homo_id	                               (tr (coeq w)))) =	                       h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	              match	                a as s	                return	                  (h	                     (g	                        (match s with	                         | inl a0 => fun x1 : A => a0 * x1	                         | inr b0 => fun x1 : A => b0 * x1	                         end	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x1 : A => a0 * x1	                               | inr b0 => fun x1 : A => b0 * x1	                               end) mon_unit w))) =	                   h	                     (match s with	                      | inl a0 => fun x1 : B => f a0 * x1	                      | inr b0 => fun x1 : B => g b0 * x1	                      end	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x1 : B => f a0 * x1	                            | inr b0 => fun x1 : B => g b0 * x1	                            end) mon_unit w)))	              with	              | inl a0 =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x1 : A => a1 * x1	                           | inr b0 => fun x1 : A => b0 * x1	                           end) mon_unit w)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x1 : A => a1 * x1	                             | inr b0 => fun x1 : A => b0 * x1	                             end) mon_unit w)) @	                    ap11	                      (ap11 1	                         (let q1 := x.2 (freeproduct_inl a0) in	                          let q2 := x.2 (freeproduct_inr a0) in	                          let q0 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => x.1 g0 = h (f a0 * mon_unit)) q1	                              a0 (right_identity a0) in	                          let q3 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => x.1 g0 = h (g a0 * mon_unit)) q2	                              a0 (right_identity a0) in	                          let q4 :=	                            internal_paths_rew B (f a0 * mon_unit)	                              (fun g0 : B => x.1 a0 = h g0) q0 	                              (f a0) (right_identity (f a0)) in	                          let q5 :=	                            internal_paths_rew B (g a0 * mon_unit)	                              (fun g0 : B => x.1 a0 = h g0) q3 	                              (g a0) (right_identity (g a0)) in	                          q4^ @ q5)^) IHw) @	                   (grp_homo_op h (f a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x1 : B => f a1 * x1	                          | inr b0 => fun x1 : B => g b0 * x1	                          end) mon_unit w))^)	              | inr b0 =>	                  ap h	                    (grp_homo_op g b0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x1 : A => a0 * x1	                           | inr b1 => fun x1 : A => b1 * x1	                           end) mon_unit w)) @	                  ((grp_homo_op h (g b0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x1 : A => a0 * x1	                             | inr b1 => fun x1 : A => b1 * x1	                             end) mon_unit w)) @ ap11 1 IHw) @	                   (grp_homo_op h (g b0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x1 : B => f a0 * x1	                          | inr b1 => fun x1 : B => g b1 * x1	                          end) mon_unit w))^)	              end) (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b))))	    x0) = x	";
            responses[i]=data;
          

            i = 57;
            data = "1 goal (ID 1065)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  ============================	  (grp_homo_compose h f;	  fun x : FreeProduct A A =>	  (let q1 :=	     p (freeproduct_inl (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q2 :=	     p (freeproduct_inr (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q0 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x * mon_unit)	       (fun g0 : A =>	        k g0 =	        h (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit))	       q1 (FreeProduct_rec A A A grp_homo_id grp_homo_id x)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q3 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x * mon_unit)	       (fun g0 : A =>	        k g0 =	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit))	       q2 (FreeProduct_rec A A A grp_homo_id grp_homo_id x)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q4 :=	     internal_paths_rew B	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit)	       (fun g0 : B =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x) = h g0) q0	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	       (right_identity (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x)))	     in	   let q5 :=	     internal_paths_rew B	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit)	       (fun g0 : B =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x) = h g0) q3	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	       (right_identity (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x)))	     in	   q4^ @ q5) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x0 : A => a0 * x0	                      | inr b => fun x0 : A => b * x0	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x0 : B => f a0 * x0	                   | inr b => fun x0 : B => g b * x0	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0)))	           with	           | inl a0 =>	               ap h	                 (grp_homo_op g a0	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x0 : A => a1 * x0	                        | inr b => fun x0 : A => b * x0	                        end) mon_unit w0)) @	               ((grp_homo_op h (g a0)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : A => a1 * x0	                          | inr b => fun x0 : A => b * x0	                          end) mon_unit w0)) @	                 ap11	                   (ap11 1	                      (let q1 := p (freeproduct_inl a0) in	                       let q2 := p (freeproduct_inr a0) in	                       let q0 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => k g0 = h (f a0 * mon_unit)) q1 a0	                           (right_identity a0) in	                       let q3 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => k g0 = h (g a0 * mon_unit)) q2 a0	                           (right_identity a0) in	                       let q4 :=	                         internal_paths_rew B (f a0 * mon_unit)	                           (fun g0 : B => k a0 = h g0) q0 	                           (f a0) (right_identity (f a0)) in	                       let q5 :=	                         internal_paths_rew B (g a0 * mon_unit)	                           (fun g0 : B => k a0 = h g0) q3 	                           (g a0) (right_identity (g a0)) in	                       q4^ @ q5)^) IHw) @	                (grp_homo_op h (f a0)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a1 => fun x0 : B => f a1 * x0	                       | inr b => fun x0 : B => g b * x0	                       end) mon_unit w0))^)	           | inr b =>	               ap h	                 (grp_homo_op g b	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b0 => fun x0 : A => b0 * x0	                        end) mon_unit w0)) @	               ((grp_homo_op h (g b)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : A => a0 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end) mon_unit w0)) @ ap11 1 IHw) @	                (grp_homo_op h (g b)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a0 => fun x0 : B => f a0 * x0	                       | inr b0 => fun x0 : B => g b0 * x0	                       end) mon_unit w0))^)	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             (list_rect	                (fun w : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w)))	                 with	                 | inl a0 =>	                     ap h	                       (grp_homo_op g a0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : A => a1 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end) mon_unit w)) @	                     ((grp_homo_op h (g a0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w)) @	                       ap11	                         (ap11 1	                            (let q1 := p (freeproduct_inl a0) in	                             let q2 := p (freeproduct_inr a0) in	                             let q0 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => k g0 = h (f a0 * mon_unit))	                                 q1 a0 (right_identity a0) in	                             let q3 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => k g0 = h (g a0 * mon_unit))	                                 q2 a0 (right_identity a0) in	                             let q4 :=	                               internal_paths_rew B 	                                 (f a0 * mon_unit)	                                 (fun g0 : B => k a0 = h g0) q0 	                                 (f a0) (right_identity (f a0)) in	                             let q5 :=	                               internal_paths_rew B 	                                 (g a0 * mon_unit)	                                 (fun g0 : B => k a0 = h g0) q3 	                                 (g a0) (right_identity (g a0)) in	                             q4^ @ q5)^) IHw) @	                      (grp_homo_op h (f a0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : B => f a1 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w))^)	                 | inr b0 =>	                     ap h	                       (grp_homo_op g b0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b1 => fun x0 : A => b1 * x0	                              end) mon_unit w)) @	                     ((grp_homo_op h (g b0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w)) @ 	                       ap11 1 IHw) @	                      (grp_homo_op h (g b0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b1 => fun x0 : B => g b1 * x0	                             end) mon_unit w))^)	                 end)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          (list_rect	             (fun w : list (A + A) =>	              h	                (g	                   (FreeProduct_rec A A A grp_homo_id grp_homo_id	                      (tr (coeq w)))) =	              h (FreeProduct_rec A A B f g (tr (coeq w))))	             (ap h (grp_homo_unit g))	             (fun (a : A + A) (w : list (A + A))	                (IHw : h	                         (g	                            (FreeProduct_rec A A A grp_homo_id grp_homo_id	                               (tr (coeq w)))) =	                       h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	              match	                a as s	                return	                  (h	                     (g	                        (match s with	                         | inl a0 => fun x0 : A => a0 * x0	                         | inr b0 => fun x0 : A => b0 * x0	                         end	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w))) =	                   h	                     (match s with	                      | inl a0 => fun x0 : B => f a0 * x0	                      | inr b0 => fun x0 : B => g b0 * x0	                      end	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end) mon_unit w)))	              with	              | inl a0 =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w)) @	                    ap11	                      (ap11 1	                         (let q1 := p (freeproduct_inl a0) in	                          let q2 := p (freeproduct_inr a0) in	                          let q0 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => k g0 = h (f a0 * mon_unit)) q1	                              a0 (right_identity a0) in	                          let q3 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => k g0 = h (g a0 * mon_unit)) q2	                              a0 (right_identity a0) in	                          let q4 :=	                            internal_paths_rew B (f a0 * mon_unit)	                              (fun g0 : B => k a0 = h g0) q0 	                              (f a0) (right_identity (f a0)) in	                          let q5 :=	                            internal_paths_rew B (g a0 * mon_unit)	                              (fun g0 : B => k a0 = h g0) q3 	                              (g a0) (right_identity (g a0)) in	                          q4^ @ q5)^) IHw) @	                   (grp_homo_op h (f a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w))^)	              | inr b0 =>	                  ap h	                    (grp_homo_op g b0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : A => a0 * x0	                           | inr b1 => fun x0 : A => b1 * x0	                           end) mon_unit w)) @	                  ((grp_homo_op h (g b0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b1 => fun x0 : A => b1 * x0	                             end) mon_unit w)) @ ap11 1 IHw) @	                   (grp_homo_op h (g b0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b1 => fun x0 : B => g b1 * x0	                          end) mon_unit w))^)	              end) (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b))))	    x) = (k; p)	1 goal (ID 1316)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  ============================	  (grp_homo_compose h f;	  fun x : FreeProduct A A =>	  (let q1 :=	     p (freeproduct_inl (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q2 :=	     p (freeproduct_inr (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q0 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x * mon_unit)	       (fun g0 : A =>	        k g0 =	        h (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit))	       q1 (FreeProduct_rec A A A grp_homo_id grp_homo_id x)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q3 :=	     internal_paths_rew A	       (FreeProduct_rec A A A grp_homo_id grp_homo_id x * mon_unit)	       (fun g0 : A =>	        k g0 =	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit))	       q2 (FreeProduct_rec A A A grp_homo_id grp_homo_id x)	       (right_identity (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) in	   let q4 :=	     internal_paths_rew B	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit)	       (fun g0 : B =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x) = h g0) q0	       (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	       (right_identity (f (FreeProduct_rec A A A grp_homo_id grp_homo_id x)))	     in	   let q5 :=	     internal_paths_rew B	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x) * mon_unit)	       (fun g0 : B =>	        k (FreeProduct_rec A A A grp_homo_id grp_homo_id x) = h g0) q3	       (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	       (right_identity (g (FreeProduct_rec A A A grp_homo_id grp_homo_id x)))	     in	   q4^ @ q5) @	  Trunc_ind	    (fun	       aa : Trunc 0	              (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                 (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	     h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	     h (FreeProduct_rec A A B f g aa))	    (Coeq_ind	       (fun	          w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	        h (FreeProduct_rec A A B f g (tr w)))	       (fun w : FreeProduct.Words A A =>	        list_rect	          (fun w0 : list (A + A) =>	           h	             (g	                (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr (coeq w0)))) =	           h (FreeProduct_rec A A B f g (tr (coeq w0))))	          (ap h (grp_homo_unit g))	          (fun (a : A + A) (w0 : list (A + A))	             (IHw : h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	           match	             a as s	             return	               (h	                  (g	                     (match s with	                      | inl a0 => fun x0 : A => a0 * x0	                      | inr b => fun x0 : A => b * x0	                      end	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0))) =	                h	                  (match s with	                   | inl a0 => fun x0 : B => f a0 * x0	                   | inr b => fun x0 : B => g b * x0	                   end	                     (List.fold_right B (A + A)	                        (fun X0 : A + A =>	                         match X0 with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b => fun x0 : B => g b * x0	                         end) mon_unit w0)))	           with	           | inl a0 =>	               ap h	                 (grp_homo_op g a0	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a1 => fun x0 : A => a1 * x0	                        | inr b => fun x0 : A => b * x0	                        end) mon_unit w0)) @	               ((grp_homo_op h (g a0)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : A => a1 * x0	                          | inr b => fun x0 : A => b * x0	                          end) mon_unit w0)) @	                 ap11	                   (ap11 1	                      (let q1 := p (freeproduct_inl a0) in	                       let q2 := p (freeproduct_inr a0) in	                       let q0 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => k g0 = h (f a0 * mon_unit)) q1 a0	                           (right_identity a0) in	                       let q3 :=	                         internal_paths_rew A (a0 * mon_unit)	                           (fun g0 : A => k g0 = h (g a0 * mon_unit)) q2 a0	                           (right_identity a0) in	                       let q4 :=	                         internal_paths_rew B (f a0 * mon_unit)	                           (fun g0 : B => k a0 = h g0) q0 	                           (f a0) (right_identity (f a0)) in	                       let q5 :=	                         internal_paths_rew B (g a0 * mon_unit)	                           (fun g0 : B => k a0 = h g0) q3 	                           (g a0) (right_identity (g a0)) in	                       q4^ @ q5)^) IHw) @	                (grp_homo_op h (f a0)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a1 => fun x0 : B => f a1 * x0	                       | inr b => fun x0 : B => g b * x0	                       end) mon_unit w0))^)	           | inr b =>	               ap h	                 (grp_homo_op g b	                    (List.fold_right A (A + A)	                       (fun X0 : A + A =>	                        match X0 with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b0 => fun x0 : A => b0 * x0	                        end) mon_unit w0)) @	               ((grp_homo_op h (g b)	                   (g	                      (List.fold_right A (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : A => a0 * x0	                          | inr b0 => fun x0 : A => b0 * x0	                          end) mon_unit w0)) @ ap11 1 IHw) @	                (grp_homo_op h (g b)	                   (List.fold_right B (A + A)	                      (fun X0 : A + A =>	                       match X0 with	                       | inl a0 => fun x0 : B => f a0 * x0	                       | inr b0 => fun x0 : B => g b0 * x0	                       end) mon_unit w0))^)	           end) w)	       (fun	          b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	              FreeProduct.pc3 grp_trivial A A + FreeProduct.pc4 A A +	              FreeProduct.pc5 A A =>	        path_ishprop	          (transport	             (fun	                w : Coeq	                      (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                      (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	              =>	              h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	              h (FreeProduct_rec A A B f g (tr w))) 	             (cglue b)	             (list_rect	                (fun w : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w)))	                 with	                 | inl a0 =>	                     ap h	                       (grp_homo_op g a0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : A => a1 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end) mon_unit w)) @	                     ((grp_homo_op h (g a0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w)) @	                       ap11	                         (ap11 1	                            (let q1 := p (freeproduct_inl a0) in	                             let q2 := p (freeproduct_inr a0) in	                             let q0 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => k g0 = h (f a0 * mon_unit))	                                 q1 a0 (right_identity a0) in	                             let q3 :=	                               internal_paths_rew A 	                                 (a0 * mon_unit)	                                 (fun g0 : A => k g0 = h (g a0 * mon_unit))	                                 q2 a0 (right_identity a0) in	                             let q4 :=	                               internal_paths_rew B 	                                 (f a0 * mon_unit)	                                 (fun g0 : B => k a0 = h g0) q0 	                                 (f a0) (right_identity (f a0)) in	                             let q5 :=	                               internal_paths_rew B 	                                 (g a0 * mon_unit)	                                 (fun g0 : B => k a0 = h g0) q3 	                                 (g a0) (right_identity (g a0)) in	                             q4^ @ q5)^) IHw) @	                      (grp_homo_op h (f a0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : B => f a1 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end) mon_unit w))^)	                 | inr b0 =>	                     ap h	                       (grp_homo_op g b0	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b1 => fun x0 : A => b1 * x0	                              end) mon_unit w)) @	                     ((grp_homo_op h (g b0)	                         (g	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w)) @ 	                       ap11 1 IHw) @	                      (grp_homo_op h (g b0)	                         (List.fold_right B (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b1 => fun x0 : B => g b1 * x0	                             end) mon_unit w))^)	                 end)	                (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	          (list_rect	             (fun w : list (A + A) =>	              h	                (g	                   (FreeProduct_rec A A A grp_homo_id grp_homo_id	                      (tr (coeq w)))) =	              h (FreeProduct_rec A A B f g (tr (coeq w))))	             (ap h (grp_homo_unit g))	             (fun (a : A + A) (w : list (A + A))	                (IHw : h	                         (g	                            (FreeProduct_rec A A A grp_homo_id grp_homo_id	                               (tr (coeq w)))) =	                       h (FreeProduct_rec A A B f g (tr (coeq w)))) =>	              match	                a as s	                return	                  (h	                     (g	                        (match s with	                         | inl a0 => fun x0 : A => a0 * x0	                         | inr b0 => fun x0 : A => b0 * x0	                         end	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w))) =	                   h	                     (match s with	                      | inl a0 => fun x0 : B => f a0 * x0	                      | inr b0 => fun x0 : B => g b0 * x0	                      end	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end) mon_unit w)))	              with	              | inl a0 =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w)) @	                    ap11	                      (ap11 1	                         (let q1 := p (freeproduct_inl a0) in	                          let q2 := p (freeproduct_inr a0) in	                          let q0 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => k g0 = h (f a0 * mon_unit)) q1	                              a0 (right_identity a0) in	                          let q3 :=	                            internal_paths_rew A (a0 * mon_unit)	                              (fun g0 : A => k g0 = h (g a0 * mon_unit)) q2	                              a0 (right_identity a0) in	                          let q4 :=	                            internal_paths_rew B (f a0 * mon_unit)	                              (fun g0 : B => k a0 = h g0) q0 	                              (f a0) (right_identity (f a0)) in	                          let q5 :=	                            internal_paths_rew B (g a0 * mon_unit)	                              (fun g0 : B => k a0 = h g0) q3 	                              (g a0) (right_identity (g a0)) in	                          q4^ @ q5)^) IHw) @	                   (grp_homo_op h (f a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w))^)	              | inr b0 =>	                  ap h	                    (grp_homo_op g b0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : A => a0 * x0	                           | inr b1 => fun x0 : A => b1 * x0	                           end) mon_unit w)) @	                  ((grp_homo_op h (g b0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b1 => fun x0 : A => b1 * x0	                             end) mon_unit w)) @ ap11 1 IHw) @	                   (grp_homo_op h (g b0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b1 => fun x0 : B => g b1 * x0	                          end) mon_unit w))^)	              end) (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b))))	    x).1 = (k; p).1	";
            responses[i]=data;
          

            i = 58;
            data = "1 goal (ID 1317)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  ============================	  grp_homo_compose h f = k	";
            responses[i]=data;
          

            i = 59;
            data = "1 goal (ID 1326)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  ============================	  grp_homo_compose h f == k	";
            responses[i]=data;
          

            i = 60;
            data = "1 goal (ID 1328)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  y : A	  ============================	  grp_homo_compose h f y = k y	";
            responses[i]=data;
          

            i = 61;
            data = "1 goal (ID 1331)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  y : A	  q1 := p (freeproduct_inl y)	   : (fun x : FreeProduct A A =>	      k (FreeProduct_rec A A A grp_homo_id grp_homo_id x))	       (freeproduct_inl y) =	     (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	       (freeproduct_inl y)	  ============================	  grp_homo_compose h f y = k y	";
            responses[i]=data;
          

            i = 62;
            data = "1 goal (ID 1336)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  y : A	  q1 := p	          (amal_eta grp_trivial A A (grp_trivial_rec A) 	             (grp_trivial_rec A) (inl y :: nil)%list)	   : k (y * mon_unit) = h (f y * mon_unit)	  ============================	  grp_homo_compose h f y = k y	";
            responses[i]=data;
          

            i = 63;
            data = "1 goal (ID 1512)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  k : GroupHomomorphism A C	  p : (fun x : FreeProduct A A =>	       k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	      (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))	  y : A	  q1 : k y = h (f y)	  ============================	  grp_homo_compose h f y = k y	";
            responses[i]=data;
          

            i = 64;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 65;
            data = "1 goal		goal 1 (ID 111) is:	 (fun	    X : {b : GroupHomomorphism A C &	        (fun x : FreeProduct A A =>	         b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	        (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	  (fun (k : GroupHomomorphism A C)	     (p : (fun x : FreeProduct A A =>	           k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	          (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	     (x : A) =>	   let q1 := p (freeproduct_inl x) in	   let q2 := p (freeproduct_inr x) in	   let q0 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	       (right_identity x) in	   let q3 :=	     internal_paths_rew A (x * mon_unit)	       (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	       (right_identity x) in	   let q4 :=	     internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	       (f x) (right_identity (f x)) in	   let q5 :=	     internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	       (g x) (right_identity (g x)) in	   q4^ @ q5) X.1 X.2)	 o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	    (grp_homo_compose h f;	    fun x : FreeProduct A A =>	    p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	    Trunc_ind	      (fun	         aa : Trunc 0	                (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))) =>	       h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	       h (FreeProduct_rec A A B f g aa))	      (Coeq_ind	         (fun	            w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                  (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	          h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	          h (FreeProduct_rec A A B f g (tr w)))	         (fun w : FreeProduct.Words A A =>	          list_rect	            (fun w0 : list (A + A) =>	             h	               (g	                  (FreeProduct_rec A A A grp_homo_id grp_homo_id	                     (tr (coeq w0)))) =	             h (FreeProduct_rec A A B f g (tr (coeq w0))))	            (ap h (grp_homo_unit g))	            (fun (a : A + A) (w0 : list (A + A))	               (IHw : h	                        (g	                           (FreeProduct_rec A A A grp_homo_id grp_homo_id	                              (tr (coeq w0)))) =	                      h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	             match	               a as s	               return	                 (h	                    (g	                       (match s with	                        | inl a0 => fun x0 : A => a0 * x0	                        | inr b => fun x0 : A => b * x0	                        end	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a0 => fun x0 : A => a0 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0))) =	                  h	                    (match s with	                     | inl a0 => fun x0 : B => f a0 * x0	                     | inr b => fun x0 : B => g b * x0	                     end	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a0 => fun x0 : B => f a0 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0)))	             with	             | inl a0 =>	                 (fun a1 : A =>	                  ap h	                    (grp_homo_op g a1	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : A => a2 * x0	                           | inr b => fun x0 : A => b * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a1)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a2 => fun x0 : A => a2 * x0	                             | inr b => fun x0 : A => b * x0	                             end) mon_unit w0)) @ 	                    ap11 (ap11 1 (p a1)^) IHw) @	                   (grp_homo_op h (f a1)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a2 => fun x0 : B => f a2 * x0	                          | inr b => fun x0 : B => g b * x0	                          end) mon_unit w0))^)) a0	             | inr b =>	                 (fun a0 : A =>	                  ap h	                    (grp_homo_op g a0	                       (List.fold_right A (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : A => a1 * x0	                           | inr b0 => fun x0 : A => b0 * x0	                           end) mon_unit w0)) @	                  ((grp_homo_op h (g a0)	                      (g	                         (List.fold_right A (A + A)	                            (fun X0 : A + A =>	                             match X0 with	                             | inl a1 => fun x0 : A => a1 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end) mon_unit w0)) @ 	                    ap11 1 IHw) @	                   (grp_homo_op h (g a0)	                      (List.fold_right B (A + A)	                         (fun X0 : A + A =>	                          match X0 with	                          | inl a1 => fun x0 : B => f a1 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end) mon_unit w0))^)) b	             end) w)	         (fun	            b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                FreeProduct.pc3 grp_trivial A A + 	                FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	          path_ishprop	            (transport	               (fun	                  w : Coeq	                        (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                        (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A))	                =>	                h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                h (FreeProduct_rec A A B f g (tr w))) 	               (cglue b)	               ((fun w : FreeProduct.Words A A =>	                 list_rect	                   (fun w0 : list (A + A) =>	                    h	                      (g	                         (FreeProduct_rec A A A grp_homo_id grp_homo_id	                            (tr (coeq w0)))) =	                    h (FreeProduct_rec A A B f g (tr (coeq w0))))	                   (ap h (grp_homo_unit g))	                   (fun (a : A + A) (w0 : list (A + A))	                      (IHw : h	                               (g	                                  (FreeProduct_rec A A A grp_homo_id	                                     grp_homo_id (tr (coeq w0)))) =	                             h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                    match	                      a as s	                      return	                        (h	                           (g	                              (match s with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a0 => fun x0 : A => a0 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0))) =	                         h	                           (match s with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b0 => fun x0 : B => g b0 * x0	                            end	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : B => f a0 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0)))	                    with	                    | inl a0 =>	                        (fun a1 : A =>	                         ap h	                           (grp_homo_op g a1	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a1)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a2 => fun x0 : A => a2 * x0	                                    | inr b0 => fun x0 : A => b0 * x0	                                    end) mon_unit w0)) @	                           ap11 (ap11 1 (p a1)^) IHw) @	                          (grp_homo_op h (f a1)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : B => f a2 * x0	                                 | inr b0 => fun x0 : B => g b0 * x0	                                 end) mon_unit w0))^)) a0	                    | inr b0 =>	                        (fun a0 : A =>	                         ap h	                           (grp_homo_op g a0	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @	                         ((grp_homo_op h (g a0)	                             (g	                                (List.fold_right A 	                                   (A + A)	                                   (fun X0 : A + A =>	                                    match X0 with	                                    | inl a1 => fun x0 : A => a1 * x0	                                    | inr b1 => fun x0 : A => b1 * x0	                                    end) mon_unit w0)) @ 	                           ap11 1 IHw) @	                          (grp_homo_op h (g a0)	                             (List.fold_right B (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : B => f a1 * x0	                                 | inr b1 => fun x0 : B => g b1 * x0	                                 end) mon_unit w0))^)) b0	                    end) w)	                  (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	            ((fun w : FreeProduct.Words A A =>	              list_rect	                (fun w0 : list (A + A) =>	                 h	                   (g	                      (FreeProduct_rec A A A grp_homo_id grp_homo_id	                         (tr (coeq w0)))) =	                 h (FreeProduct_rec A A B f g (tr (coeq w0))))	                (ap h (grp_homo_unit g))	                (fun (a : A + A) (w0 : list (A + A))	                   (IHw : h	                            (g	                               (FreeProduct_rec A A A grp_homo_id grp_homo_id	                                  (tr (coeq w0)))) =	                          h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                 match	                   a as s	                   return	                     (h	                        (g	                           (match s with	                            | inl a0 => fun x0 : A => a0 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a0 => fun x0 : A => a0 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0))) =	                      h	                        (match s with	                         | inl a0 => fun x0 : B => f a0 * x0	                         | inr b0 => fun x0 : B => g b0 * x0	                         end	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : B => f a0 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0)))	                 with	                 | inl a0 =>	                     (fun a1 : A =>	                      ap h	                        (grp_homo_op g a1	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : A => a2 * x0	                               | inr b0 => fun x0 : A => b0 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a1)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a2 => fun x0 : A => a2 * x0	                                 | inr b0 => fun x0 : A => b0 * x0	                                 end) mon_unit w0)) @	                        ap11 (ap11 1 (p a1)^) IHw) @	                       (grp_homo_op h (f a1)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : B => f a2 * x0	                              | inr b0 => fun x0 : B => g b0 * x0	                              end) mon_unit w0))^)) a0	                 | inr b0 =>	                     (fun a0 : A =>	                      ap h	                        (grp_homo_op g a0	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : A => a1 * x0	                               | inr b1 => fun x0 : A => b1 * x0	                               end) mon_unit w0)) @	                      ((grp_homo_op h (g a0)	                          (g	                             (List.fold_right A (A + A)	                                (fun X0 : A + A =>	                                 match X0 with	                                 | inl a1 => fun x0 : A => a1 * x0	                                 | inr b1 => fun x0 : A => b1 * x0	                                 end) mon_unit w0)) @ 	                        ap11 1 IHw) @	                       (grp_homo_op h (g a0)	                          (List.fold_right B (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : B => f a1 * x0	                              | inr b1 => fun x0 : B => g b1 * x0	                              end) mon_unit w0))^)) b0	                 end) w)	               (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	 idmap	1 goal (ID 111)	  	  H : Funext	  A : Group	  B : Group	  C : Group	  f, g : GroupHomomorphism A B	  h : GroupHomomorphism B C	  ============================	  (fun	     X : {b : GroupHomomorphism A C &	         (fun x : FreeProduct A A =>	          b (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	         (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x))} =>	   (fun (k : GroupHomomorphism A C)	      (p : (fun x : FreeProduct A A =>	            k (FreeProduct_rec A A A grp_homo_id grp_homo_id x)) ==	           (fun x : FreeProduct A A => h (FreeProduct_rec A A B f g x)))	      (x : A) =>	    let q1 := p (freeproduct_inl x) in	    let q2 := p (freeproduct_inr x) in	    let q0 :=	      internal_paths_rew A (x * mon_unit)	        (fun g0 : A => k g0 = h (f x * mon_unit)) q1 x 	        (right_identity x) in	    let q3 :=	      internal_paths_rew A (x * mon_unit)	        (fun g0 : A => k g0 = h (g x * mon_unit)) q2 x 	        (right_identity x) in	    let q4 :=	      internal_paths_rew B (f x * mon_unit) (fun g0 : B => k x = h g0) q0	        (f x) (right_identity (f x)) in	    let q5 :=	      internal_paths_rew B (g x * mon_unit) (fun g0 : B => k x = h g0) q3	        (g x) (right_identity (g x)) in	    q4^ @ q5) X.1 X.2)	  o (fun p : (fun x : A => h (f x)) == (fun x : A => h (g x)) =>	     (grp_homo_compose h f;	     fun x : FreeProduct A A =>	     p (FreeProduct_rec A A A grp_homo_id grp_homo_id x) @	     Trunc_ind	       (fun	          aa : Trunc 0	                 (Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                    (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)))	        =>	        h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id aa)) =	        h (FreeProduct_rec A A B f g aa))	       (Coeq_ind	          (fun	             w : Coeq (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A))	                   (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A)) =>	           h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	           h (FreeProduct_rec A A B f g (tr w)))	          (fun w : FreeProduct.Words A A =>	           list_rect	             (fun w0 : list (A + A) =>	              h	                (g	                   (FreeProduct_rec A A A grp_homo_id grp_homo_id	                      (tr (coeq w0)))) =	              h (FreeProduct_rec A A B f g (tr (coeq w0))))	             (ap h (grp_homo_unit g))	             (fun (a : A + A) (w0 : list (A + A))	                (IHw : h	                         (g	                            (FreeProduct_rec A A A grp_homo_id grp_homo_id	                               (tr (coeq w0)))) =	                       h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	              match	                a as s	                return	                  (h	                     (g	                        (match s with	                         | inl a0 => fun x0 : A => a0 * x0	                         | inr b => fun x0 : A => b * x0	                         end	                           (List.fold_right A (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a0 => fun x0 : A => a0 * x0	                               | inr b => fun x0 : A => b * x0	                               end) mon_unit w0))) =	                   h	                     (match s with	                      | inl a0 => fun x0 : B => f a0 * x0	                      | inr b => fun x0 : B => g b * x0	                      end	                        (List.fold_right B (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a0 => fun x0 : B => f a0 * x0	                            | inr b => fun x0 : B => g b * x0	                            end) mon_unit w0)))	              with	              | inl a0 =>	                  (fun a1 : A =>	                   ap h	                     (grp_homo_op g a1	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a2 => fun x0 : A => a2 * x0	                            | inr b => fun x0 : A => b * x0	                            end) mon_unit w0)) @	                   ((grp_homo_op h (g a1)	                       (g	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a2 => fun x0 : A => a2 * x0	                              | inr b => fun x0 : A => b * x0	                              end) mon_unit w0)) @ 	                     ap11 (ap11 1 (p a1)^) IHw) @	                    (grp_homo_op h (f a1)	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a2 => fun x0 : B => f a2 * x0	                           | inr b => fun x0 : B => g b * x0	                           end) mon_unit w0))^)) a0	              | inr b =>	                  (fun a0 : A =>	                   ap h	                     (grp_homo_op g a0	                        (List.fold_right A (A + A)	                           (fun X0 : A + A =>	                            match X0 with	                            | inl a1 => fun x0 : A => a1 * x0	                            | inr b0 => fun x0 : A => b0 * x0	                            end) mon_unit w0)) @	                   ((grp_homo_op h (g a0)	                       (g	                          (List.fold_right A (A + A)	                             (fun X0 : A + A =>	                              match X0 with	                              | inl a1 => fun x0 : A => a1 * x0	                              | inr b0 => fun x0 : A => b0 * x0	                              end) mon_unit w0)) @ 	                     ap11 1 IHw) @	                    (grp_homo_op h (g a0)	                       (List.fold_right B (A + A)	                          (fun X0 : A + A =>	                           match X0 with	                           | inl a1 => fun x0 : B => f a1 * x0	                           | inr b0 => fun x0 : B => g b0 * x0	                           end) mon_unit w0))^)) b	              end) w)	          (fun	             b : FreeProduct.pc1 A A + FreeProduct.pc2 A A +	                 FreeProduct.pc3 grp_trivial A A + 	                 FreeProduct.pc4 A A + FreeProduct.pc5 A A =>	           path_ishprop	             (transport	                (fun	                   w : Coeq	                         (FreeProduct.map1 grp_trivial A A	                            (grp_trivial_rec A))	                         (FreeProduct.map2 grp_trivial A A	                            (grp_trivial_rec A)) =>	                 h (g (FreeProduct_rec A A A grp_homo_id grp_homo_id (tr w))) =	                 h (FreeProduct_rec A A B f g (tr w))) 	                (cglue b)	                ((fun w : FreeProduct.Words A A =>	                  list_rect	                    (fun w0 : list (A + A) =>	                     h	                       (g	                          (FreeProduct_rec A A A grp_homo_id grp_homo_id	                             (tr (coeq w0)))) =	                     h (FreeProduct_rec A A B f g (tr (coeq w0))))	                    (ap h (grp_homo_unit g))	                    (fun (a : A + A) (w0 : list (A + A))	                       (IHw : h	                                (g	                                   (FreeProduct_rec A A A grp_homo_id	                                      grp_homo_id 	                                      (tr (coeq w0)))) =	                              h (FreeProduct_rec A A B f g (tr (coeq w0))))	                     =>	                     match	                       a as s	                       return	                         (h	                            (g	                               (match s with	                                | inl a0 => fun x0 : A => a0 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end	                                  (List.fold_right A 	                                     (A + A)	                                     (fun X0 : A + A =>	                                      match X0 with	                                      | inl a0 => fun x0 : A => a0 * x0	                                      | inr b0 => fun x0 : A => b0 * x0	                                      end) mon_unit w0))) =	                          h	                            (match s with	                             | inl a0 => fun x0 : B => f a0 * x0	                             | inr b0 => fun x0 : B => g b0 * x0	                             end	                               (List.fold_right B 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a0 => fun x0 : B => f a0 * x0	                                   | inr b0 => fun x0 : B => g b0 * x0	                                   end) mon_unit w0)))	                     with	                     | inl a0 =>	                         (fun a1 : A =>	                          ap h	                            (grp_homo_op g a1	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a2 => fun x0 : A => a2 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0)) @	                          ((grp_homo_op h (g a1)	                              (g	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a2 => fun x0 : A => a2 * x0	                                     | inr b0 => fun x0 : A => b0 * x0	                                     end) mon_unit w0)) @	                            ap11 (ap11 1 (p a1)^) IHw) @	                           (grp_homo_op h (f a1)	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : B => f a2 * x0	                                  | inr b0 => fun x0 : B => g b0 * x0	                                  end) mon_unit w0))^)) a0	                     | inr b0 =>	                         (fun a0 : A =>	                          ap h	                            (grp_homo_op g a0	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a1 => fun x0 : A => a1 * x0	                                   | inr b1 => fun x0 : A => b1 * x0	                                   end) mon_unit w0)) @	                          ((grp_homo_op h (g a0)	                              (g	                                 (List.fold_right A 	                                    (A + A)	                                    (fun X0 : A + A =>	                                     match X0 with	                                     | inl a1 => fun x0 : A => a1 * x0	                                     | inr b1 => fun x0 : A => b1 * x0	                                     end) mon_unit w0)) @ 	                            ap11 1 IHw) @	                           (grp_homo_op h (g a0)	                              (List.fold_right B (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : B => f a1 * x0	                                  | inr b1 => fun x0 : B => g b1 * x0	                                  end) mon_unit w0))^)) b0	                     end) w)	                   (FreeProduct.map1 grp_trivial A A (grp_trivial_rec A) b)))	             ((fun w : FreeProduct.Words A A =>	               list_rect	                 (fun w0 : list (A + A) =>	                  h	                    (g	                       (FreeProduct_rec A A A grp_homo_id grp_homo_id	                          (tr (coeq w0)))) =	                  h (FreeProduct_rec A A B f g (tr (coeq w0))))	                 (ap h (grp_homo_unit g))	                 (fun (a : A + A) (w0 : list (A + A))	                    (IHw : h	                             (g	                                (FreeProduct_rec A A A grp_homo_id	                                   grp_homo_id (tr (coeq w0)))) =	                           h (FreeProduct_rec A A B f g (tr (coeq w0)))) =>	                  match	                    a as s	                    return	                      (h	                         (g	                            (match s with	                             | inl a0 => fun x0 : A => a0 * x0	                             | inr b0 => fun x0 : A => b0 * x0	                             end	                               (List.fold_right A 	                                  (A + A)	                                  (fun X0 : A + A =>	                                   match X0 with	                                   | inl a0 => fun x0 : A => a0 * x0	                                   | inr b0 => fun x0 : A => b0 * x0	                                   end) mon_unit w0))) =	                       h	                         (match s with	                          | inl a0 => fun x0 : B => f a0 * x0	                          | inr b0 => fun x0 : B => g b0 * x0	                          end	                            (List.fold_right B (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a0 => fun x0 : B => f a0 * x0	                                | inr b0 => fun x0 : B => g b0 * x0	                                end) mon_unit w0)))	                  with	                  | inl a0 =>	                      (fun a1 : A =>	                       ap h	                         (grp_homo_op g a1	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a2 => fun x0 : A => a2 * x0	                                | inr b0 => fun x0 : A => b0 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a1)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a2 => fun x0 : A => a2 * x0	                                  | inr b0 => fun x0 : A => b0 * x0	                                  end) mon_unit w0)) @	                         ap11 (ap11 1 (p a1)^) IHw) @	                        (grp_homo_op h (f a1)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a2 => fun x0 : B => f a2 * x0	                               | inr b0 => fun x0 : B => g b0 * x0	                               end) mon_unit w0))^)) a0	                  | inr b0 =>	                      (fun a0 : A =>	                       ap h	                         (grp_homo_op g a0	                            (List.fold_right A (A + A)	                               (fun X0 : A + A =>	                                match X0 with	                                | inl a1 => fun x0 : A => a1 * x0	                                | inr b1 => fun x0 : A => b1 * x0	                                end) mon_unit w0)) @	                       ((grp_homo_op h (g a0)	                           (g	                              (List.fold_right A (A + A)	                                 (fun X0 : A + A =>	                                  match X0 with	                                  | inl a1 => fun x0 : A => a1 * x0	                                  | inr b1 => fun x0 : A => b1 * x0	                                  end) mon_unit w0)) @ 	                         ap11 1 IHw) @	                        (grp_homo_op h (g a0)	                           (List.fold_right B (A + A)	                              (fun X0 : A + A =>	                               match X0 with	                               | inl a1 => fun x0 : B => f a1 * x0	                               | inr b1 => fun x0 : B => g b1 * x0	                               end) mon_unit w0))^)) b0	                  end) w)	                (FreeProduct.map2 grp_trivial A A (grp_trivial_rec A) b)))) x)) ==	  idmap	No more goals.	";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Algebra.Groups.GroupCoeq</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#"><span class="id" title="library">Algebra.Groups.Group</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HIT.Coeq.html#"><span class="id" title="library">HIT.Coeq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#"><span class="id" title="library">Algebra.Groups.FreeProduct</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(11, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_mult_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(12, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
Coequalizers of group homomorphisms 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="GroupCoeq" class="idref" href="#GroupCoeq"><span class="id" title="definition">GroupCoeq</span></a> {<a id="A:1" class="idref" href="#A:1"><span class="id" title="binder">A</span></a> <a id="B:2" class="idref" href="#B:2"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>} (<a id="f:3" class="idref" href="#f:3"><span class="id" title="binder">f</span></a> <a id="g:4" class="idref" href="#g:4"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#A:1"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#B:2"><span class="id" title="variable">B</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
  <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> <span class="id" title="var">A</span> <span class="id" title="var">A</span>) <span class="id" title="var">A</span> <span class="id" title="var">B</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
  1,2: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct_rec"><span class="id" title="definition">FreeProduct_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
  + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_id"><span class="id" title="definition">grp_homo_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
  + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_id"><span class="id" title="definition">grp_homo_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
  + <span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
  + <span class="id" title="tactic">exact</span> <span class="id" title="var">g</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_groupcoeq_rec" class="idref" href="#equiv_groupcoeq_rec"><span class="id" title="definition">equiv_groupcoeq_rec</span></a> `{<a id="H:5" class="idref" href="#H:5"><span class="id" title="binder">Funext</span></a>} {<a id="A:6" class="idref" href="#A:6"><span class="id" title="binder">A</span></a> <a id="B:7" class="idref" href="#B:7"><span class="id" title="binder">B</span></a> <a id="C:8" class="idref" href="#C:8"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>} (<a id="f:9" class="idref" href="#f:9"><span class="id" title="binder">f</span></a> <a id="g:10" class="idref" href="#g:10"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#A:6"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#B:7"><span class="id" title="variable">B</span></a>)<br>
  : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="h:11" class="idref" href="#h:11"><span class="id" title="binder">h</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#B:7"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#C:8"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#h:11"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#f:9"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#h:11"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#g:10"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#GroupCoeq"><span class="id" title="definition">GroupCoeq</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#f:9"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#g:10"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.Algebra.Groups.GroupCoeq.html#C:8"><span class="id" title="variable">C</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#equiv_amalgamatedfreeproduct_rec"><span class="id" title="lemma">equiv_amalgamatedfreeproduct_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_symm"><span class="id" title="definition">equiv_sigma_symm</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma_id"><span class="id" title="definition">equiv_functor_sigma_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
  <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
  { <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_compose"><span class="id" title="definition">grp_homo_compose</span></a> <span class="id" title="var">h</span> <span class="id" title="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
    <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">p</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.Trunc_ind"><span class="id" title="definition">Trunc_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.HIT.Coeq.html#Coeq.Coeq_ind"><span class="id" title="definition">Coeq_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
    2: <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(42, '0_3_7');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">w</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(43, '0_3_7');
      "><br>
    1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(44, '0_3_7');
      "><br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(45, '0_3_7');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">a</span>|<span class="id" title="var">a</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(46, '0_3_7');
      "><br>
    1,2: <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(47, '0_3_7');
      "><br>
    1,2: <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>); <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(48, '0_3_7');
      "><br>
    <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(49, '0_3_7');
      "><br>
    <span class="id" title="tactic">apply</span> <span class="id" title="var">p</span>. }<br>
  { <span class="id" title="tactic">intros</span> [<span class="id" title="var">k</span> <span class="id" title="var">p</span>] <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(50, '0_3_7');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">q1</span> := <span class="id" title="var">p</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#freeproduct_inl"><span class="id" title="definition">freeproduct_inl</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(51, '0_3_7');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">q2</span> := <span class="id" title="var">p</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#freeproduct_inr"><span class="id" title="definition">freeproduct_inr</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(52, '0_3_7');
      "><br>
    <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">q1</span>, <span class="id" title="var">q2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(53, '0_3_7');
      "><br>
    <span class="id" title="tactic">rewrite</span> 2 <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_identity"><span class="id" title="definition">right_identity</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">q1</span>, <span class="id" title="var">q2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(54, '0_3_7');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">q1</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">q2</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(55, '0_3_7');
      "><br>
  { <span class="id" title="tactic">hnf</span>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(56, '0_3_7');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">k</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(57, '0_3_7');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(58, '0_3_7');
      "><br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(59, '0_3_7');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#equiv_path_grouphomomorphism"><span class="id" title="definition">equiv_path_grouphomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(60, '0_3_7');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(61, '0_3_7');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">q1</span> := <span class="id" title="var">p</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#freeproduct_inl"><span class="id" title="definition">freeproduct_inl</span></a> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(62, '0_3_7');
      "><br>
    <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">q1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(63, '0_3_7');
      "><br>
    <span class="id" title="tactic">rewrite</span> 2 <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_identity"><span class="id" title="definition">right_identity</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">q1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(64, '0_3_7');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">q1</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>. }<br>
  <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(65, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(66, '0_3_7');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
