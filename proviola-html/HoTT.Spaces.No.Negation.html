<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "<infomsg>hasnegation_maxsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 22;
            data = "1 goal (ID 4)	  	  ============================	  HasNegation DecSort	";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "<infomsg>S is declared</infomsg>	<infomsg>H is declared</infomsg>	";
            responses[i]=data;
          

            i = 28;
            data = "<infomsg>No is defined</infomsg>	";
            responses[i]=data;
          

            i = 29;
            data = "1 goal (ID 5)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  ============================	  No -> No	";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "5 goals (ID 67)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  ============================	  No		goal 2 (ID 71) is:	 a = b	goal 3 (ID 93) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R s xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' s' yL yR ycut fyL fyR fycut)	goal 4 (ID 114) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R s xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' s' yL yR ycut fyL fyR fycut)	goal 5 (ID 135) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L R s xL xR xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S)	       (xcut0 : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     ?Goal@{L:=L0; R:=R0; s:=s0; xL:=xL0; xR:=xR0; xcut:=xcut0; fxL:=fxL0;	            fxR:=fxR0; fxcut:=fxcut0}) L' R' s' yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 32;
            data = "1 goal (ID 67)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  ============================	  No	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 goals		goal 1 (ID 71) is:	 a = b	goal 2 (ID 93) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' s' yL yR	      ycut fyL fyR fycut)	goal 3 (ID 114) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' s' yL	      yR ycut fyL fyR fycut)	goal 4 (ID 135) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' s' yL	      yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 33;
            data = "1 goal (ID 71)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  a, b : No	  X : (fun x y : No => y <= x) a b	  X0 : (fun x y : No => y <= x) b a	  ============================	  a = b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 93) is:	 (fun x y : No => y <= x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' s' yL yR	      ycut fyL fyR fycut)	goal 2 (ID 114) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' s' yL	      yR ycut fyL fyR fycut)	goal 3 (ID 135) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' s' yL	      yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 34;
            data = "1 goal (ID 93)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  p : forall l : L, xL l < {{ yL | yR // ycut }}	  dp : forall l : L,	       (fun x y : No => y < x) (fxL l)	         ((fun (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	             (xR : R -> GenNo S) (_ : forall (l0 : L) (r : R), xL l0 < xR r)	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l0 : L) (r : R),	                      (fun x y : No => y < x) (fxL l0) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l0 : L) => fxcut l0 r }}) L' R' s' yL	            yR ycut fyL fyR fycut)	  q : forall r : R', {{ xL | xR // xcut }} < yR r	  dq : forall r : R',	       (fun x y : No => y < x)	         ((fun (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	             (xR : R -> GenNo S) (_ : forall (l : L) (r0 : R), xL l < xR r0)	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r0 : R),	                      (fun x y : No => y < x) (fxL l) (fxR r0)) =>	           {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}) L R s xL xR	            xcut fxL fxR fxcut) (fyR r)	  ============================	  (fun x y : No => y <= x)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L R s xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r : R0), xL0 l < xR0 r)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l : L0) => fxcut0 l r }}) L' R' s' yL	       yR ycut fyL fyR fycut)	1 goal (ID 150)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  p : forall l : L, xL l < {{ yL | yR // ycut }}	  dp : forall l : L,	       {{ fyR | fyL // fun (r : R') (l0 : L') => fycut l0 r }} < fxL l	  q : forall r : R', {{ xL | xR // xcut }} < yR r	  dq : forall r : R',	       fyR r < {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}	  ============================	  {{ fyR | fyL // fun (r : R') (l : L') => fycut l r }} <=	  {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}	";
            responses[i]=data;
          

            i = 35;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 114) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l0 : L0) (r : R0),	                 (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	     {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' s' yL	      yR ycut fyL fyR fycut)	goal 2 (ID 135) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' s' yL	      yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 36;
            data = "1 goal (ID 114)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  l : L'	  p : {{ xL | xR // xcut }} <= yL l	  dp : (fun x y : No => y <= x)	         ((fun (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	             (xR : R -> GenNo S) (_ : forall (l : L) (r : R), xL l < xR r)	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r : R),	                      (fun x y : No => y < x) (fxL l) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}) L R s xL xR	            xcut fxL fxR fxcut) (fyL l)	  ============================	  (fun x y : No => y < x)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l0 : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L R s xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l0 : L0) (r : R0),	                  (fun x y : No => y < x) (fxL0 l0) (fxR0 r)) =>	      {{ fxR0 | fxL0 // fun (r : R0) (l0 : L0) => fxcut0 l0 r }}) L' R' s' yL	       yR ycut fyL fyR fycut)	1 goal (ID 160)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  l : L'	  p : {{ xL | xR // xcut }} <= yL l	  dp : fyL l <= {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}	  ============================	  {{ fyR | fyL // fun (r : R') (l0 : L') => fycut l0 r }} <	  {{ fxR | fxL // fun (r : R) (l0 : L) => fxcut l0 r }}	";
            responses[i]=data;
          

            i = 37;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 135) is:	 (fun x y : No => y < x)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R s xL xR	      xcut fxL fxR fxcut)	   ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	       (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	       (fxL0 : L0 -> No) (fxR0 : R0 -> No)	       (fxcut0 : forall (l : L0) (r0 : R0),	                 (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	     {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' s' yL	      yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 38;
            data = "1 goal (ID 135)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), (fun x y : No => y < x) (fxL l) (fxR r)	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), (fun x y : No => y < x) (fyL l) (fyR r)	  r : R	  p : xR r <= {{ yL | yR // ycut }}	  dp : (fun x y : No => y <= x) (fxR r)	         ((fun (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	             (xR : R -> GenNo S) (_ : forall (l : L) (r : R), xL l < xR r)	             (fxL : L -> No) (fxR : R -> No)	             (fxcut : forall (l : L) (r : R),	                      (fun x y : No => y < x) (fxL l) (fxR r)) =>	           {{ fxR | fxL // fun (r : R) (l : L) => fxcut l r }}) L' R' s' yL	            yR ycut fyL fyR fycut)	  ============================	  (fun x y : No => y < x)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r0 : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	      {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L R s xL xR	       xcut fxL fxR fxcut)	    ((fun (L0 R0 : Type) (s0 : InSort S L0 R0) (xL0 : L0 -> GenNo S)	        (xR0 : R0 -> GenNo S) (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	        (fxL0 : L0 -> No) (fxR0 : R0 -> No)	        (fxcut0 : forall (l : L0) (r0 : R0),	                  (fun x y : No => y < x) (fxL0 l) (fxR0 r0)) =>	      {{ fxR0 | fxL0 // fun (r0 : R0) (l : L0) => fxcut0 l r0 }}) L' R' s' yL	       yR ycut fyL fyR fycut)	1 goal (ID 167)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  L, R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  fxL : L -> No	  fxR : R -> No	  fxcut : forall (l : L) (r : R), fxR r < fxL l	  L', R' : Type	  s' : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  fyL : L' -> No	  fyR : R' -> No	  fycut : forall (l : L') (r : R'), fyR r < fyL l	  r : R	  p : xR r <= {{ yL | yR // ycut }}	  dp : {{ fyR | fyL // fun (r : R') (l : L') => fycut l r }} <= fxR r	  ============================	  {{ fyR | fyL // fun (r0 : R') (l : L') => fycut l r0 }} <	  {{ fxR | fxL // fun (r0 : R) (l : L) => fxcut l r0 }}	";
            responses[i]=data;
          

            i = 39;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>H0 is declared</infomsg>	<infomsg>H1 is declared</infomsg>	";
            responses[i]=data;
          

            i = 48;
            data = "1 goal (ID 18)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  ============================	  negate one = minusone	";
            responses[i]=data;
          

            i = 49;
            data = "";
            responses[i]=data;
          

            i = 50;
            data = "4 goals (ID 34)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  l : Empty	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R s xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	           (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0) =>	            {{ fxR | fxL // fun (r : R0) (l0 : L0) => fxcut l0 r }})	           (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	              (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No x0 y p q) a @ path_No a b dq dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0)	              (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	              (dp : forall l0 : L0,	                    {{ fyR | fyL // fun (r : R') (l1 : L') => fycut l1 r }} <	                    fxL l0)	              (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	              (dq : forall r : R',	                    fyR r <	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            le_lr fyR fyL (fun (r : R') (l0 : L') => fycut l0 r) fxR fxL	              (fun (r : R0) (l0 : L0) => fxcut l0 r) 	              (fun l0 : R' => dq l0) (fun r : L0 => dp r))	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (_ : forall (l0 : L') (r : R'), yL l0 < yR r) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	              (dp : fyL l0 <=	                    {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	            =>	            lt_r fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	              (fun (r : R0) (l1 : L0) => fxcut l1 r) l0 dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <=	                    fxR r) =>	            lt_l fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) r dp) No_ind_internal	           (opt L R s xL xR) (isno L R s xL xR i i0 g)	     end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)) <	  {{ Empty_rec | unit_name zero // lempty_cut }}		goal 2 (ID 35) is:	 {{ fun r0 : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	              {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                (dp : forall l : L0,	                      {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                      fxL l)	                (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                (dq : forall r1 : R',	                      fyR r1 <	                      {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	              =>	              le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                (fun (r1 : R0) (l : L0) => fxcut l r1) 	                (fun l : R' => dq l) (fun r1 : L0 => dp r1))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                (dp : fyL l <=	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                      fxR r1) =>	              lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp) No_ind_internal	             (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r0 : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }} < zero	goal 3 (ID 36) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	goal 4 (ID 37) is:	 {{ Empty_rec | unit_name zero // lempty_cut }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R s xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	          (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	             (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No x0 y p q) a @ path_No a b dq dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt L R s xL xR) (isno L R s xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "1 goal (ID 34)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  l : Empty	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R s xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	           (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0) =>	            {{ fxR | fxL // fun (r : R0) (l0 : L0) => fxcut l0 r }})	           (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	              (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No x0 y p q) a @ path_No a b dq dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0)	              (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	              (dp : forall l0 : L0,	                    {{ fyR | fyL // fun (r : R') (l1 : L') => fycut l1 r }} <	                    fxL l0)	              (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	              (dq : forall r : R',	                    fyR r <	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            le_lr fyR fyL (fun (r : R') (l0 : L') => fycut l0 r) fxR fxL	              (fun (r : R0) (l0 : L0) => fxcut l0 r) 	              (fun l0 : R' => dq l0) (fun r : L0 => dp r))	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (_ : forall (l0 : L') (r : R'), yL l0 < yR r) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	              (dp : fyL l0 <=	                    {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	            =>	            lt_r fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	              (fun (r : R0) (l1 : L0) => fxcut l1 r) l0 dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l0 : L0) (r : R0), xL0 l0 < xR0 r)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l0 : L0) (r : R0), fxR r < fxL l0)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l0 : L') (r : R'), yL l0 < yR r)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l0 : L') (r : R'), fyR r < fyL l0) 	              (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <=	                    fxR r) =>	            lt_l fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) r dp) No_ind_internal	           (opt L R s xL xR) (isno L R s xL xR i i0 g)	     end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)) <	  {{ Empty_rec | unit_name zero // lempty_cut }}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 35) is:	 {{ fun r0 : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	              {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                (dp : forall l : L0,	                      {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                      fxL l)	                (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                (dq : forall r1 : R',	                      fyR r1 <	                      {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	              =>	              le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                (fun (r1 : R0) (l : L0) => fxcut l r1) 	                (fun l : R' => dq l) (fun r1 : L0 => dp r1))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                (dp : fyL l <=	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                      fxR r1) =>	              lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp) No_ind_internal	             (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r0 : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                  {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                    (dp : forall l0 : L0,	                          {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} < 	                          fxL l0)	                    (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                    (dq : forall r1 : R',	                          fyR r1 <	                          {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                          fxcut l0 r2 }}) =>	                  le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                    fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                    (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                    (dp : fyL l0 <=	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                    (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                          fycut l0 r2 }} <= 	                          fxR r1) =>	                  lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                    fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }} < zero	goal 2 (ID 36) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	goal 3 (ID 37) is:	 {{ Empty_rec | unit_name zero // lempty_cut }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R s xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	          (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	             (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No x0 y p q) a @ path_No a b dq dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt L R s xL xR) (isno L R s xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	";
            responses[i]=data;
          

            i = 60;
            data = "1 goal (ID 35)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  r : Unit	  ============================	  {{ fun r0 : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	          No :=	        match xno with	        | isno L R s xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	              (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	               {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	              (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                 (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No x0 y p q) a @ path_No a b dq dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                 (dp : forall l : L0,	                       {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                       fxL l)	                 (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                 (dq : forall r1 : R',	                       fyR r1 <	                       {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	               =>	               le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                 (fun (r1 : R0) (l : L0) => fxcut l r1) 	                 (fun l : R' => dq l) (fun r1 : L0 => dp r1))	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                 (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                 (dp : fyL l <=	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                       fxR r1) =>	               lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                 (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp)	              No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	        end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	  unit_name	    ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	          No :=	        match xno with	        | isno L R s xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	              (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	               {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	              (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                 (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No x0 y p q) a @ path_No a b dq dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                 (dp : forall l0 : L0,	                       {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                       fxL l0)	                 (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                 (dq : forall r0 : R',	                       fyR r0 <	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                 (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                 (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                 (dp : fyL l0 <=	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                       fxR r0) =>	               lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	              No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	        end) (game_of zero) (isno_game_of zero)) // 	  fun r0 : Empty =>	  unit_name	    match	      No_Empty_admitted	      return	        ((fix No_ind_internal	            (x0 : Game) (xno : is_surreal x0) {struct xno} : No :=	            match xno with	            | isno L R s xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : GenNo S => No)	                  (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                   {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                  (fun (x1 y : GenNo S) (a b : No) 	                     (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                     (dq : a <= b) =>	                   transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                     (dp : forall l0 : L0,	                           {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} < 	                           fxL l0)	                     (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                     (dq : forall r1 : R',	                           fyR r1 <	                           {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                           fxcut l0 r2 }}) =>	                   le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                     fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                     (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                     (dp : fyL l0 <=	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                           fycut l0 r2 }} <= 	                           fxR r1) =>	                   lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                     fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                  No_ind_internal (opt L R s xL xR) 	                  (isno L R s xL xR i i0 g)	            end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	         (fix No_ind_internal	            (x0 : Game) (xno : is_surreal x0) {struct xno} : No :=	            match xno with	            | isno L R s xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : GenNo S => No)	                  (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                   {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                  (fun (x1 y : GenNo S) (a b : No) 	                     (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                     (dq : a <= b) =>	                   transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                     (dp : forall l0 : L0,	                           {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} < 	                           fxL l0)	                     (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                     (dq : forall r1 : R',	                           fyR r1 <	                           {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                           fxcut l0 r2 }}) =>	                   le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                     fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                     (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                     (dp : fyL l0 <=	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                     (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                           fycut l0 r2 }} <= 	                           fxR r1) =>	                   lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                     fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                  No_ind_internal (opt L R s xL xR) 	                  (isno L R s xL xR i i0 g)	            end) (game_of zero) (isno_game_of zero))	    with	    end }} < zero	1 goal (ID 42)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  r : Unit	  ============================	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R s xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	           (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	            {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	           (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	              (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No x0 y p q) a @ path_No a b dq dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	              (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	              (dp : forall l : L0,	                    {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                    fxL l)	              (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	              (dq : forall r0 : R',	                    fyR r0 <	                    {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	            =>	            le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	              (fun (r0 : R0) (l : L0) => fxcut l r0) 	              (fun l : R' => dq l) (fun r0 : L0 => dp r0))	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	              (dp : fyL l <=	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                    fxR r0) =>	            lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	              (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	           (opt L R s xL xR) (isno L R s xL xR i i0 g)	     end) (game_of zero) (isno_game_of zero) <=	  {{ Empty_rec | Empty_rec // lempty_cut }}	";
            responses[i]=data;
          

            i = 61;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 36) is:	 Empty_rec l <	 {{ fun r : Empty =>	    (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	              {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                (dp : forall l0 : L0,	                      {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                      fxL l0)	                (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                (dq : forall r0 : R',	                      fyR r0 <	                      {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	              =>	              le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                (dp : fyL l0 <=	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                      fxR r0) =>	              lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	 unit_name	   ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	       match xno with	       | isno L R s xL xR i i0 g =>	           Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	             (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	             (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	              {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	             (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	              transport_const (path_No x0 y p q) a @ path_No a b dq dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                (dp : forall l1 : L0,	                      {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                      fxL l1)	                (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                (dq : forall r : R',	                      fyR r <	                      {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	              =>	              le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                (fun (r : R0) (l1 : L0) => fxcut l1 r) 	                (fun l1 : R' => dq l1) (fun r : L0 => dp r))	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                (dp : fyL l1 <=	                      {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	              =>	              lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	             (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                (fxL : L0 -> No) (fxR : R0 -> No)	                (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                (L' R' : Type) (s' : InSort S L' R') 	                (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                (fyL : L' -> No) (fyR : R' -> No)	                (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                      fxR r) =>	              lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	             No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	       end) (game_of zero) (isno_game_of zero)) // 	 fun r : Empty =>	 unit_name	   match	     No_Empty_admitted	     return	       ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	        (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	             No :=	           match xno with	           | isno L R s xL xR i i0 g =>	               Core.Surreals.No_ind_internal_step 	                 (fun _ : GenNo S => No)	                 (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                 (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                  {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                 (fun (x1 y : GenNo S) (a b : No) 	                    (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                    (dq : a <= b) =>	                  transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                    (dp : forall l1 : L0,	                          {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                          fycut l2 r0 }} < 	                          fxL l1)	                    (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                    (dq : forall r0 : R',	                          fyR r0 <	                          {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                          fxcut l1 r1 }}) =>	                  le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                    fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                    (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                    (dp : fyL l1 <=	                          {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                          fxcut l2 r0 }}) =>	                  lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                    fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                 (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                    (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                    (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                    (fxL : L0 -> No) (fxR : R0 -> No)	                    (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                    (L' R' : Type) (s' : InSort S L' R') 	                    (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                    (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                    (fyL : L' -> No) (fyR : R' -> No)	                    (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                    (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                    (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                          fycut l1 r1 }} <= 	                          fxR r0) =>	                  lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                    fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                 No_ind_internal (opt L R s xL xR) 	                 (isno L R s xL xR i i0 g)	           end) (game_of zero) (isno_game_of zero))	   with	   end }}	goal 2 (ID 37) is:	 {{ Empty_rec | unit_name zero // lempty_cut }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R s xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	          (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	             (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No x0 y p q) a @ path_No a b dq dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt L R s xL xR) (isno L R s xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	";
            responses[i]=data;
          

            i = 62;
            data = "1 goal (ID 36)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  l : Empty	  ============================	  Empty_rec l <	  {{ fun r : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	          No :=	        match xno with	        | isno L R s xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	              (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	               {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	              (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                 (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No x0 y p q) a @ path_No a b dq dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                 (dp : forall l0 : L0,	                       {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                       fxL l0)	                 (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                 (dq : forall r0 : R',	                       fyR r0 <	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	                 (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	                 (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                 (dp : fyL l0 <=	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	                 (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                       fxR r0) =>	               lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	              No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	        end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) | 	  unit_name	    ((fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	          No :=	        match xno with	        | isno L R s xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	              (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1) =>	               {{ fxR | fxL // fun (r : R0) (l1 : L0) => fxcut l1 r }})	              (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                 (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No x0 y p q) a @ path_No a b dq dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                 (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                 (dp : forall l1 : L0,	                       {{ fyR | fyL // fun (r : R') (l2 : L') => fycut l2 r }} <	                       fxL l1)	                 (_ : forall r : R', {{ xL0 | xR0 // xcut }} < yR r)	                 (dq : forall r : R',	                       fyR r <	                       {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	               =>	               le_lr fyR fyL (fun (r : R') (l1 : L') => fycut l1 r) fxR fxL	                 (fun (r : R0) (l1 : L0) => fxcut l1 r)	                 (fun l1 : R' => dq l1) (fun r : L0 => dp r))	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (_ : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1)	                 (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                 (dp : fyL l1 <=	                       {{ fxR | fxL // fun (r : R0) (l2 : L0) => fxcut l2 r }})	               =>	               lt_r fyR fyL (fun (r : R') (l2 : L') => fycut l2 r) fxR fxL	                 (fun (r : R0) (l2 : L0) => fxcut l2 r) l1 dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l1 : L0) (r : R0), xL0 l1 < xR0 r)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l1 : L0) (r : R0), fxR r < fxL l1)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l1 : L') (r : R'), yL l1 < yR r)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l1 : L') (r : R'), fyR r < fyL l1) 	                 (r : R0) (_ : xR0 r <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <=	                       fxR r) =>	               lt_l fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	                 (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) r dp)	              No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	        end) (game_of zero) (isno_game_of zero)) // 	  fun r : Empty =>	  unit_name	    match	      No_Empty_admitted	      return	        ((fix No_ind_internal	            (x0 : Game) (xno : is_surreal x0) {struct xno} : No :=	            match xno with	            | isno L R s xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : GenNo S => No)	                  (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                   {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                  (fun (x1 y : GenNo S) (a b : No) 	                     (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                     (dq : a <= b) =>	                   transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                     (dp : forall l1 : L0,	                           {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                           fycut l2 r0 }} < 	                           fxL l1)	                     (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                     (dq : forall r0 : R',	                           fyR r0 <	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                     fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                     (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                     (dp : fyL l1 <=	                           {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                           fxcut l2 r0 }}) =>	                   lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                     fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} <= 	                           fxR r0) =>	                   lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                  No_ind_internal (opt L R s xL xR) 	                  (isno L R s xL xR i i0 g)	            end) (game_of (Empty_rec r)) (isno_game_of (Empty_rec r)) <	         (fix No_ind_internal	            (x0 : Game) (xno : is_surreal x0) {struct xno} : No :=	            match xno with	            | isno L R s xL xR i i0 g =>	                Core.Surreals.No_ind_internal_step 	                  (fun _ : GenNo S => No)	                  (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                  (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1) =>	                   {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	                  (fun (x1 y : GenNo S) (a b : No) 	                     (p : x1 <= y) (q : y <= x1) (dp : b <= a) 	                     (dq : a <= b) =>	                   transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (_ : forall l1 : L0, xL0 l1 < {{ yL | yR // ycut }})	                     (dp : forall l1 : L0,	                           {{ fyR | fyL // fun (r0 : R') (l2 : L') =>	                                           fycut l2 r0 }} < 	                           fxL l1)	                     (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	                     (dq : forall r0 : R',	                           fyR r0 <	                           {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                           fxcut l1 r1 }}) =>	                   le_lr fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR	                     fxL (fun (r0 : R0) (l1 : L0) => fxcut l1 r0)	                     (fun l1 : R' => dq l1) (fun r0 : L0 => dp r0))	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (xcut : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (_ : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (l1 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l1)	                     (dp : fyL l1 <=	                           {{ fxR | fxL // fun (r0 : R0) (l2 : L0) =>	                                           fxcut l2 r0 }}) =>	                   lt_r fyR fyL (fun (r0 : R') (l2 : L') => fycut l2 r0) fxR	                     fxL (fun (r0 : R0) (l2 : L0) => fxcut l2 r0) l1 dp)	                  (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                     (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                     (_ : forall (l1 : L0) (r0 : R0), xL0 l1 < xR0 r0)	                     (fxL : L0 -> No) (fxR : R0 -> No)	                     (fxcut : forall (l1 : L0) (r0 : R0), fxR r0 < fxL l1)	                     (L' R' : Type) (s' : InSort S L' R')	                     (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                     (ycut : forall (l1 : L') (r0 : R'), yL l1 < yR r0)	                     (fyL : L' -> No) (fyR : R' -> No)	                     (fycut : forall (l1 : L') (r0 : R'), fyR r0 < fyL l1)	                     (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	                     (dp : {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                           fycut l1 r1 }} <= 	                           fxR r0) =>	                   lt_l fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                     fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) r0 dp)	                  No_ind_internal (opt L R s xL xR) 	                  (isno L R s xL xR i i0 g)	            end) (game_of zero) (isno_game_of zero))	    with	    end }}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 37) is:	 {{ Empty_rec | unit_name zero // lempty_cut }} <	 (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	    match xno with	    | isno L R s xL xR i i0 g =>	        Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	          (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	          (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	           {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	          (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	             (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	           transport_const (path_No x0 y p q) a @ path_No a b dq dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	             (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	             (dp : forall l : L0,	                   {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                   fxL l)	             (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	             (dq : forall r0 : R',	                   fyR r0 <	                   {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	           =>	           le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	             (fun (r0 : R0) (l : L0) => fxcut l r0) 	             (fun l : R' => dq l) (fun r0 : L0 => dp r0))	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	             (dp : fyL l <=	                   {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	           =>	           lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	             (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	          (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	             (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	             (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0) 	             (fxL : L0 -> No) (fxR : R0 -> No)	             (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	             (L' R' : Type) (s' : InSort S L' R') 	             (yL : L' -> GenNo S) (yR : R' -> GenNo S)	             (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	             (fyL : L' -> No) (fyR : R' -> No)	             (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	             (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	             (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                   fxR r0) =>	           lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	             (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	          (opt L R s xL xR) (isno L R s xL xR i i0 g)	    end) (game_of zero) (isno_game_of zero)	";
            responses[i]=data;
          

            i = 63;
            data = "1 goal (ID 37)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  r : Unit	  ============================	  {{ Empty_rec | unit_name zero // lempty_cut }} <	  (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	     match xno with	     | isno L R s xL xR i i0 g =>	         Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	           (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	           (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l) =>	            {{ fxR | fxL // fun (r0 : R0) (l : L0) => fxcut l r0 }})	           (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	              (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	            transport_const (path_No x0 y p q) a @ path_No a b dq dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l)	              (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	              (dp : forall l : L0,	                    {{ fyR | fyL // fun (r0 : R') (l0 : L') => fycut l0 r0 }} <	                    fxL l)	              (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	              (dq : forall r0 : R',	                    fyR r0 <	                    {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	            =>	            le_lr fyR fyL (fun (r0 : R') (l : L') => fycut l r0) fxR fxL	              (fun (r0 : R0) (l : L0) => fxcut l r0) 	              (fun l : R' => dq l) (fun r0 : L0 => dp r0))	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (xcut : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (_ : forall (l : L') (r0 : R'), yL l < yR r0) 	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	              (dp : fyL l <=	                    {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            =>	            lt_r fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	              (fun (r0 : R0) (l0 : L0) => fxcut l0 r0) l dp)	           (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	              (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	              (_ : forall (l : L0) (r0 : R0), xL0 l < xR0 r0)	              (fxL : L0 -> No) (fxR : R0 -> No)	              (fxcut : forall (l : L0) (r0 : R0), fxR r0 < fxL l)	              (L' R' : Type) (s' : InSort S L' R') 	              (yL : L' -> GenNo S) (yR : R' -> GenNo S)	              (ycut : forall (l : L') (r0 : R'), yL l < yR r0)	              (fyL : L' -> No) (fyR : R' -> No)	              (fycut : forall (l : L') (r0 : R'), fyR r0 < fyL l) 	              (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	              (dp : {{ fyR | fyL // fun (r1 : R') (l : L') => fycut l r1 }} <=	                    fxR r0) =>	            lt_l fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	              (fun (r1 : R0) (l : L0) => fxcut l r1) r0 dp) No_ind_internal	           (opt L R s xL xR) (isno L R s xL xR i i0 g)	     end) (game_of zero) (isno_game_of zero)	1 goal (ID 53)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  r : Unit	  ============================	  zero <=	  {{ fun r0 : Empty =>	     (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} :	          No :=	        match xno with	        | isno L R s xL xR i i0 g =>	            Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	              (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	              (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l) =>	               {{ fxR | fxL // fun (r1 : R0) (l : L0) => fxcut l r1 }})	              (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	                 (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	               transport_const (path_No x0 y p q) a @ path_No a b dq dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (_ : forall l : L0, xL0 l < {{ yL | yR // ycut }})	                 (dp : forall l : L0,	                       {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <	                       fxL l)	                 (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                 (dq : forall r1 : R',	                       fyR r1 <	                       {{ fxR | fxL // fun (r2 : R0) (l : L0) => fxcut l r2 }})	               =>	               le_lr fyR fyL (fun (r1 : R') (l : L') => fycut l r1) fxR fxL	                 (fun (r1 : R0) (l : L0) => fxcut l r1) 	                 (fun l : R' => dq l) (fun r1 : L0 => dp r1))	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (xcut : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (_ : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l) 	                 (l : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l)	                 (dp : fyL l <=	                       {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	               =>	               lt_r fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	                 (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) l dp)	              (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	                 (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                 (_ : forall (l : L0) (r1 : R0), xL0 l < xR0 r1)	                 (fxL : L0 -> No) (fxR : R0 -> No)	                 (fxcut : forall (l : L0) (r1 : R0), fxR r1 < fxL l)	                 (L' R' : Type) (s' : InSort S L' R') 	                 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                 (ycut : forall (l : L') (r1 : R'), yL l < yR r1)	                 (fyL : L' -> No) (fyR : R' -> No)	                 (fycut : forall (l : L') (r1 : R'), fyR r1 < fyL l)	                 (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                 (dp : {{ fyR | fyL // fun (r2 : R') (l : L') => fycut l r2 }} <=	                       fxR r1) =>	               lt_l fyR fyL (fun (r2 : R') (l : L') => fycut l r2) fxR fxL	                 (fun (r2 : R0) (l : L0) => fxcut l r2) r1 dp)	              No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	        end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) | 	  (fun l : Empty =>	   (fix No_ind_internal (x : Game) (xno : is_surreal x) {struct xno} : No :=	      match xno with	      | isno L R s xL xR i i0 g =>	          Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	            (fun (x0 y : GenNo S) (_ : x0 <= y) (a b : No) => b <= a)	            (fun (x0 y : GenNo S) (_ : x0 < y) (a b : No) => b < a)	            (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	               (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	               (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0) =>	             {{ fxR | fxL // fun (r0 : R0) (l0 : L0) => fxcut l0 r0 }})	            (fun (x0 y : GenNo S) (a b : No) (p : x0 <= y) 	               (q : y <= x0) (dp : b <= a) (dq : a <= b) =>	             transport_const (path_No x0 y p q) a @ path_No a b dq dp)	            (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	               (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	               (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (s' : InSort S L' R') 	               (yL : L' -> GenNo S) (yR : R' -> GenNo S)	               (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	               (dp : forall l0 : L0,	                     {{ fyR | fyL // fun (r0 : R') (l1 : L') => fycut l1 r0 }} <	                     fxL l0)	               (_ : forall r0 : R', {{ xL0 | xR0 // xcut }} < yR r0)	               (dq : forall r0 : R',	                     fyR r0 <	                     {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	             =>	             le_lr fyR fyL (fun (r0 : R') (l0 : L') => fycut l0 r0) fxR fxL	               (fun (r0 : R0) (l0 : L0) => fxcut l0 r0)	               (fun l0 : R' => dq l0) (fun r0 : L0 => dp r0))	            (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	               (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	               (xcut : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (s' : InSort S L' R') 	               (yL : L' -> GenNo S) (yR : R' -> GenNo S)	               (_ : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	               (dp : fyL l0 <=	                     {{ fxR | fxL // fun (r0 : R0) (l1 : L0) => fxcut l1 r0 }})	             =>	             lt_r fyR fyL (fun (r0 : R') (l1 : L') => fycut l1 r0) fxR fxL	               (fun (r0 : R0) (l1 : L0) => fxcut l1 r0) l0 dp)	            (fun (L0 R0 : Type) (s0 : InSort S L0 R0) 	               (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	               (_ : forall (l0 : L0) (r0 : R0), xL0 l0 < xR0 r0)	               (fxL : L0 -> No) (fxR : R0 -> No)	               (fxcut : forall (l0 : L0) (r0 : R0), fxR r0 < fxL l0)	               (L' R' : Type) (s' : InSort S L' R') 	               (yL : L' -> GenNo S) (yR : R' -> GenNo S)	               (ycut : forall (l0 : L') (r0 : R'), yL l0 < yR r0)	               (fyL : L' -> No) (fyR : R' -> No)	               (fycut : forall (l0 : L') (r0 : R'), fyR r0 < fyL l0)	               (r0 : R0) (_ : xR0 r0 <= {{ yL | yR // ycut }})	               (dp : {{ fyR | fyL // fun (r1 : R') (l0 : L') => fycut l0 r1 }} <=	                     fxR r0) =>	             lt_l fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR fxL	               (fun (r1 : R0) (l0 : L0) => fxcut l0 r1) r0 dp)	            No_ind_internal (opt L R s xL xR) (isno L R s xL xR i i0 g)	      end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l))) // 	  fun r0 l : Empty =>	  match	    No_Empty_admitted	    return	      ((fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	          match xno with	          | isno L R s xL xR i i0 g =>	              Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	                (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                 {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                (fun (x1 y : GenNo S) (a b : No) (p : x1 <= y) 	                   (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                 transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                   (dp : forall l0 : L0,	                         {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                         fycut l1 r1 }} < 	                         fxL l0)	                   (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                   (dq : forall r1 : R',	                         fyR r1 <	                         {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                         fxcut l0 r2 }}) =>	                 le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                   fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                   (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                   (dp : fyL l0 <=	                         {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                         fxcut l1 r1 }}) =>	                 lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                   fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                   (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                         fycut l0 r2 }} <= 	                         fxR r1) =>	                 lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                   fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                No_ind_internal (opt L R s xL xR) 	                (isno L R s xL xR i i0 g)	          end) (game_of (Empty_rec r0)) (isno_game_of (Empty_rec r0)) <	       (fix No_ind_internal (x0 : Game) (xno : is_surreal x0) {struct xno} :	            No :=	          match xno with	          | isno L R s xL xR i i0 g =>	              Core.Surreals.No_ind_internal_step (fun _ : GenNo S => No)	                (fun (x1 y : GenNo S) (_ : x1 <= y) (a b : No) => b <= a)	                (fun (x1 y : GenNo S) (_ : x1 < y) (a b : No) => b < a)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0) =>	                 {{ fxR | fxL // fun (r1 : R0) (l0 : L0) => fxcut l0 r1 }})	                (fun (x1 y : GenNo S) (a b : No) (p : x1 <= y) 	                   (q : y <= x1) (dp : b <= a) (dq : a <= b) =>	                 transport_const (path_No x1 y p q) a @ path_No a b dq dp)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (_ : forall l0 : L0, xL0 l0 < {{ yL | yR // ycut }})	                   (dp : forall l0 : L0,	                         {{ fyR | fyL // fun (r1 : R') (l1 : L') =>	                                         fycut l1 r1 }} < 	                         fxL l0)	                   (_ : forall r1 : R', {{ xL0 | xR0 // xcut }} < yR r1)	                   (dq : forall r1 : R',	                         fyR r1 <	                         {{ fxR | fxL // fun (r2 : R0) (l0 : L0) =>	                                         fxcut l0 r2 }}) =>	                 le_lr fyR fyL (fun (r1 : R') (l0 : L') => fycut l0 r1) fxR	                   fxL (fun (r1 : R0) (l0 : L0) => fxcut l0 r1)	                   (fun l0 : R' => dq l0) (fun r1 : L0 => dp r1))	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (xcut : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (_ : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (l0 : L') (_ : {{ xL0 | xR0 // xcut }} <= yL l0)	                   (dp : fyL l0 <=	                         {{ fxR | fxL // fun (r1 : R0) (l1 : L0) =>	                                         fxcut l1 r1 }}) =>	                 lt_r fyR fyL (fun (r1 : R') (l1 : L') => fycut l1 r1) fxR	                   fxL (fun (r1 : R0) (l1 : L0) => fxcut l1 r1) l0 dp)	                (fun (L0 R0 : Type) (s0 : InSort S L0 R0)	                   (xL0 : L0 -> GenNo S) (xR0 : R0 -> GenNo S)	                   (_ : forall (l0 : L0) (r1 : R0), xL0 l0 < xR0 r1)	                   (fxL : L0 -> No) (fxR : R0 -> No)	                   (fxcut : forall (l0 : L0) (r1 : R0), fxR r1 < fxL l0)	                   (L' R' : Type) (s' : InSort S L' R') 	                   (yL : L' -> GenNo S) (yR : R' -> GenNo S)	                   (ycut : forall (l0 : L') (r1 : R'), yL l0 < yR r1)	                   (fyL : L' -> No) (fyR : R' -> No)	                   (fycut : forall (l0 : L') (r1 : R'), fyR r1 < fyL l0)	                   (r1 : R0) (_ : xR0 r1 <= {{ yL | yR // ycut }})	                   (dp : {{ fyR | fyL // fun (r2 : R') (l0 : L') =>	                                         fycut l0 r2 }} <= 	                         fxR r1) =>	                 lt_l fyR fyL (fun (r2 : R') (l0 : L') => fycut l0 r2) fxR	                   fxL (fun (r2 : R0) (l0 : L0) => fxcut l0 r2) r1 dp)	                No_ind_internal (opt L R s xL xR) 	                (isno L R s xL xR i i0 g)	          end) (game_of (Empty_rec l)) (isno_game_of (Empty_rec l)))	  with	  end }}	";
            responses[i]=data;
          

            i = 64;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "1 goal (ID 46)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  ============================	  {nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l) &	  negate {{ xL | xR // xcut }} =	  {{ fun r : R => negate (xR r) | (fun l : L => negate (xL l)) // nxcut }}}	";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "1 focused goal	(shelved: 1) (ID 49)	  	  S : OptionSort	  H : HasNegation S	  No := GenNo S : Type	  H0 : InSort S Empty Empty	  H1 : InSort S Unit Empty	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  ============================	  negate {{ xL | xR // xcut }} =	  {{ fun r : R => negate (xR r) | (fun l : L => negate (xL l)) // 	  ?nxcut }}	";
            responses[i]=data;
          

            i = 73;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Spaces.No.Negation</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.No.Core.html#"><span class="id" title="library">HoTT.Spaces.No.Core</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a id="lab380"></a><h1 class="section">Negation of surreal numbers</h1>
<div class="doc" scenenumber="4"> </div>

 Negation requires the option sorts to be symmetric. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      ">
<span class="id" title="keyword">Class</span> <a id="HasNegation" class="idref" href="#HasNegation"><span class="id" title="record">HasNegation</span></a> (<a id="S:1" class="idref" href="#S:1"><span class="id" title="binder">S</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort</span></a>) <br>
  := <a id="symmetric_options" class="idref" href="#symmetric_options"><span class="id" title="projection">symmetric_options</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="L:3" class="idref" href="#L:3"><span class="id" title="binder">L</span></a> <a id="R:4" class="idref" href="#R:4"><span class="id" title="binder">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#S:1"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#L:3"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#R:4"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#S:1"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#R:4"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#L:3"><span class="id" title="variable">L</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">symmetric_options</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="hasnegation_maxsort" class="idref" href="#hasnegation_maxsort"><span class="id" title="instance">hasnegation_maxsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation"><span class="id" title="class">HasNegation</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#MaxSort"><span class="id" title="definition">MaxSort</span></a><br>
  := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="hasnegation_decsort" class="idref" href="#hasnegation_decsort"><span class="id" title="instance">hasnegation_decsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation"><span class="id" title="class">HasNegation</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#DecSort"><span class="id" title="definition">DecSort</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> [? ?]; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a id="HasNegation" class="idref" href="#HasNegation"><span class="id" title="section">HasNegation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> {<a id="S:6" class="idref" href="#S:6"><span class="id" title="binder">S</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort</span></a>} `{<a id="H:7" class="idref" href="#H:7"><span class="id" title="binder">HasNegation</span></a> <a id="H:7" class="idref" href="#H:7"><span class="id" title="binder">S</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
  <span class="id" title="keyword">Let</span> <a id="HasNegation.No" class="idref" href="#HasNegation.No"><span class="id" title="variable">No</span></a> := <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.GenNo"><span class="id" title="record">GenNo</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.S"><span class="id" title="variable">S</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="negate" class="idref" href="#negate"><span class="id" title="definition">negate</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.No"><span class="id" title="variable">No</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.No"><span class="id" title="variable">No</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
    <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_rec"><span class="id" title="definition">No_rec</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.No"><span class="id" title="variable">No</span></a> (<span class="id" title="keyword">fun</span> <a id="x:14" class="idref" href="#x:14"><span class="id" title="binder">x</span></a> <a id="y:15" class="idref" href="#y:15"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Spaces.No.Negation.html#y:11"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#x:10"><span class="id" title="variable">x</span></a>) (<span class="id" title="keyword">fun</span> <a id="x:12" class="idref" href="#x:12"><span class="id" title="binder">x</span></a> <a id="y:13" class="idref" href="#y:13"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Spaces.No.Negation.html#y:9"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.::surreal_scope:x_'&lt;'_x"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#x:8"><span class="id" title="variable">x</span></a>)<br>
                          <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
    - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">fxR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">fxL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="keyword">fun</span> <a id="r:18" class="idref" href="#r:18"><span class="id" title="binder">r</span></a> <a id="l:19" class="idref" href="#l:19"><span class="id" title="binder">l</span></a> ⇒ <span class="id" title="var">fxcut</span> <a class="idref" href="HoTT.Spaces.No.Negation.html#l:17"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#r:16"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
    - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
    - <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">intros</span>; [ <span class="id" title="tactic">apply</span> <span class="id" title="var">dq</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">dp</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
    - <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
    - <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_l"><span class="id" title="definition">lt_l</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The following proof verifies that <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Core.html#No_rec"><span class="id" title="definition">No_rec</span></a></span> applied to a cut reduces definitionally to a cut with the expected options (although it does produce quite a large term). 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      ">
  <span class="id" title="keyword">Context</span> `{<a id="H0:20" class="idref" href="#H0:20"><span class="id" title="binder">InSort</span></a> <a id="H0:20" class="idref" href="#H0:20"><span class="id" title="binder">S</span></a> <a id="H0:20" class="idref" href="#H0:20"><span class="id" title="binder">Empty</span></a> <a id="H0:20" class="idref" href="#H0:20"><span class="id" title="binder">Empty</span></a>} `{<a id="H1:21" class="idref" href="#H1:21"><span class="id" title="binder">InSort</span></a> <a id="H1:21" class="idref" href="#H1:21"><span class="id" title="binder">S</span></a> <a id="H1:21" class="idref" href="#H1:21"><span class="id" title="binder">Unit</span></a> <a id="H1:21" class="idref" href="#H1:21"><span class="id" title="binder">Empty</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
  <span class="id" title="keyword">Goal</span> <a id="Unnamed_thm" class="idref" href="#Unnamed_thm"><span class="id" title="definition">negate</span></a> <a id="Unnamed_thm" class="idref" href="#Unnamed_thm"><span class="id" title="definition">one</span></a> <a id="Unnamed_thm" class="idref" href="#Unnamed_thm"><span class="id" title="definition">=</span></a> <a id="Unnamed_thm" class="idref" href="#Unnamed_thm"><span class="id" title="definition">minusone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">intros</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
Since <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a></span> only proves inequality of cuts, this would not work if <span class="inlinecode"><a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#negate"><span class="id" title="projection">negate</span></a></span> didn't compute to a cut when applied to a cut. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      ">
    - <span class="id" title="tactic">elim</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(60, '0_3_15');
      "><br>
    - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(61, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(62, '0_3_15');
      "><br>
    - <span class="id" title="tactic">elim</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(63, '0_3_15');
      "><br>
    - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(64, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(65, '0_3_15');
      "><br>
  <span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(66, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
More useful is the following rewriting lemma. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(70, '0_3_19');
      ">
  <span class="id" title="keyword">Definition</span> <a id="negate_cut" class="idref" href="#negate_cut"><span class="id" title="definition">negate_cut</span></a><br>
             {<a id="L:22" class="idref" href="#L:22"><span class="id" title="binder">L</span></a> <a id="R:23" class="idref" href="#R:23"><span class="id" title="binder">R</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<a id="Sx:24" class="idref" href="#Sx:24"><span class="id" title="binder">Sx</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#L:22"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#R:23"><span class="id" title="variable">R</span></a>}<br>
             (<a id="xL:25" class="idref" href="#xL:25"><span class="id" title="binder">xL</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#L:22"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.No"><span class="id" title="variable">No</span></a>) (<a id="xR:26" class="idref" href="#xR:26"><span class="id" title="binder">xR</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#R:23"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation.No"><span class="id" title="variable">No</span></a>)<br>
             (<a id="xcut:29" class="idref" href="#xcut:29"><span class="id" title="binder">xcut</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="l:27" class="idref" href="#l:27"><span class="id" title="binder">l</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#L:22"><span class="id" title="variable">L</span></a>) (<a id="r:28" class="idref" href="#r:28"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Spaces.No.Negation.html#R:23"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#xL:25"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#l:27"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.::surreal_scope:x_'&lt;'_x"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#xR:26"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#r:28"><span class="id" title="variable">r</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <a id="nxcut:32" class="idref" href="#nxcut:32"><span class="id" title="binder">nxcut</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="r:30" class="idref" href="#r:30"><span class="id" title="binder">r</span></a> <a id="l:31" class="idref" href="#l:31"><span class="id" title="binder">l</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> (<a class="idref" href="HoTT.Spaces.No.Negation.html#xR:26"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#r:30"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.::surreal_scope:x_'&lt;'_x"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> (<a class="idref" href="HoTT.Spaces.No.Negation.html#xL:25"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#l:31"><span class="id" title="variable">l</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
        <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#xL:25"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#xR:26"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#xcut:29"><span class="id" title="variable">xcut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
        <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="r:33" class="idref" href="#r:33"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> (<a class="idref" href="HoTT.Spaces.No.Negation.html#xR:26"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#r:33"><span class="id" title="variable">r</span></a>)<a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="l:34" class="idref" href="#l:34"><span class="id" title="binder">l</span></a> ⇒ <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> (<a class="idref" href="HoTT.Spaces.No.Negation.html#xL:25"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#l:34"><span class="id" title="variable">l</span></a>)<a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#nxcut:32"><span class="id" title="variable">nxcut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(71, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(72, '0_3_19');
      "><br>
    <span class="id" title="tactic">eexists</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(73, '0_3_19');
      "><br>
    <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(74, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(75, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation"><span class="id" title="section">HasNegation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(76, '0_3_19');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
