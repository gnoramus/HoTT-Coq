<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "1 goal (ID 8)	  	  A : Sequence	  a : A 0	  k : Graph.graph0 sequence_graph	  ============================	  A k	";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "2 goals (ID 12)	  	  A : Sequence	  a : A 0	  ============================	  A 0		goal 2 (ID 15) is:	 A k.+1	";
            responses[i]=data;
          

            i = 25;
            data = "1 goal (ID 12)	  	  A : Sequence	  a : A 0	  ============================	  A 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 15) is:	 A k.+1	";
            responses[i]=data;
          

            i = 26;
            data = "1 goal (ID 15)	  	  A : Sequence	  a : A 0	  k : nat	  q : A k	  ============================	  A k.+1	No more goals.	";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "1 goal (ID 13)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "1 goal (ID 19)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "2 goals (ID 23)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}		goal 2 (ID 26) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 40;
            data = "1 goal (ID 23)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 26) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 41;
            data = "1 goal (ID 26)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  y : {x : _ & A x}	  ============================	  {x : _ & A x}	No more goals.	";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "1 goal (ID 29)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "2 goals (ID 33)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)		goal 2 (ID 36) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 48;
            data = "1 goal (ID 33)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 36) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 49;
            data = "1 goal (ID 36)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  q : ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	  ============================	  ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	No more goals.	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "1 goal (ID 44)	  	  A : Sequence	  a : A 0	  k : nat	  ============================	  ((0; a)) ^++ (k) = (k; (a) ^+ (k))	";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "2 goals (ID 48)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))		goal 2 (ID 51) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 54;
            data = "1 goal (ID 48)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 51) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 55;
            data = "1 goal (ID 51)	  	  A : Sequence	  a : A 0	  k : nat	  q : ((0; a)) ^++ (k) = (k; (a) ^+ (k))	  ============================	  ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	No more goals.	";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "1 goal (ID 111)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  ============================	  F == G	";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "1 goal (ID 129)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport (fun w : Colimit A => F w = G w) (colimp n n.+1 1 a)	    (h n.+1 (a) ^+) = h n a	";
            responses[i]=data;
          

            i = 66;
            data = "1 goal (ID 145)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall p : F (inj A n.+1 (a) ^+) = G (inj A n.+1 (a) ^+),	  ap F 1 @ p = h n.+1 (a) ^+ @ ap G 1 ->	  transport (fun w : Colimit A => F w = G w) 1 (h n.+1 (a) ^+) = p	";
            responses[i]=data;
          

            i = 67;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "<infomsg>succ_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "<infomsg>shift_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "1 goal (ID 139)	  	  A : Sequence	  ============================	  Colimit (succ_seq A) -> Colimit A	";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "2 goals (ID 171)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A		goal 2 (ID 173) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (succ_seq A) _f g == ?legs i	";
            responses[i]=data;
          

            i = 86;
            data = "1 goal (ID 171)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 173) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) j	 o (succ_seq A) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) i	";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 173)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    j o (succ_seq A) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    i	No more goals.	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "1 goal (ID 158)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap (colim_succ_seq_to_colim_seq A) (glue (succ_seq A) n a) = glue A n.+1 a	";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "1 goal (ID 186)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : succ_seq A n	  p : a1 = a2	  ============================	  ap (colim_succ_seq_to_colim_seq A) (ap (inj (succ_seq A) n) p) =	  ap (inj A n.+1) p	";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "1 goal (ID 191)	  	  A : Sequence	  ============================	  IsEquiv (colim_succ_seq_to_colim_seq A)	";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "3 goals (ID 217)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)		goal 2 (ID 219) is:	 colim_succ_seq_to_colim_seq A o ?g == idmap	goal 3 (ID 221) is:	 ?g o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 217)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)	2 goals (ID 253)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)		goal 2 (ID 255) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 101;
            data = "1 goal (ID 253)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 255) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) i	goal 2 (ID 219) is:	 colim_succ_seq_to_colim_seq A	 o Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n : Graph.graph0 sequence_graph) (a : A n) =>	         inj (succ_seq A) n (a) ^+;	       legs_comm := ?legs_comm	     |} == idmap	goal 3 (ID 221) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm := ?legs_comm	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 102;
            data = "1 goal (ID 255)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 219) is:	 colim_succ_seq_to_colim_seq A	 o Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n : Graph.graph0 sequence_graph) (a : A n) =>	         inj (succ_seq A) n (a) ^+;	       legs_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) (a : A n) =>	         match	           p as p0 in (_ = y)	           return	             (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	         with	         | 1 => glue (succ_seq A) n (a) ^+	         end	     |} == idmap	goal 2 (ID 221) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) (a : A n) =>	       match	         p as p0 in (_ = y)	         return	           (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	       with	       | 1 => glue (succ_seq A) n (a) ^+	       end	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 103;
            data = "1 goal (ID 219)	  	  A : Sequence	  ============================	  colim_succ_seq_to_colim_seq A	  o Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n : Graph.graph0 sequence_graph) (a : A n) =>	          inj (succ_seq A) n (a) ^+;	        legs_comm :=	          fun (n m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n m) 	            (a : A n) =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a) ^+ =	               inj (succ_seq A) n (a) ^+)	          with	          | 1 => glue (succ_seq A) n (a) ^+	          end	      |} == idmap	2 goals (ID 319)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	          legs :=	            fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	            inj (succ_seq A) n0 (a) ^+;	          legs_comm :=	            fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) 	              (a : A n0) =>	            match	              p as p0 in (_ = y)	              return	                (inj (succ_seq A) y ((A _f p0) a) ^+ =	                 inj (succ_seq A) n0 (a) ^+)	            with	            | 1 => glue (succ_seq A) n0 (a) ^+	            end	        |} x)) o inj A n == idmap o inj A n		goal 2 (ID 321) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	           legs :=	             fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	             inj (succ_seq A) n0 (a0) ^+;	           legs_comm :=	             fun (n0 m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n0 m) 	               (a0 : A n0) =>	             match	               p as p0 in (_ = y)	               return	                 (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                  inj (succ_seq A) n0 (a0) ^+)	             with	             | 1 => glue (succ_seq A) n0 (a0) ^+	             end	         |} x)) (glue A n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue A n a)	";
            responses[i]=data;
          

            i = 104;
            data = "1 goal (ID 319)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	          legs :=	            fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	            inj (succ_seq A) n0 (a) ^+;	          legs_comm :=	            fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) 	              (a : A n0) =>	            match	              p as p0 in (_ = y)	              return	                (inj (succ_seq A) y ((A _f p0) a) ^+ =	                 inj (succ_seq A) n0 (a) ^+)	            with	            | 1 => glue (succ_seq A) n0 (a) ^+	            end	        |} x)) o inj A n == idmap o inj A n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 321) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	           legs :=	             fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	             inj (succ_seq A) n0 (a0) ^+;	           legs_comm :=	             fun (n0 m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n0 m) 	               (a0 : A n0) =>	             match	               p as p0 in (_ = y)	               return	                 (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                  inj (succ_seq A) n0 (a0) ^+)	             with	             | 1 => glue (succ_seq A) n0 (a0) ^+	             end	         |} x)) (glue A n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	   (a) ^+ @ ap idmap (glue A n a)	goal 2 (ID 221) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) (a : A n) =>	       match	         p as p0 in (_ = y)	         return	           (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	       with	       | 1 => glue (succ_seq A) n (a) ^+	       end	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 105;
            data = "1 goal (ID 321)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  ap	    (fun x : Colimit A =>	     colim_succ_seq_to_colim_seq A	       (Colimit_rec (Colimit (succ_seq A))	          {|	            legs :=	              fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	              inj (succ_seq A) n0 (a0) ^+;	            legs_comm :=	              fun (n0 m : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph n0 m) 	                (a0 : A n0) =>	              match	                p as p0 in (_ = y)	                return	                  (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                   inj (succ_seq A) n0 (a0) ^+)	              with	              | 1 => glue (succ_seq A) n0 (a0) ^+	              end	          |} x)) (glue A n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	    (a) ^+ @ ap idmap (glue A n a)	1 goal (ID 347)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  ap (colim_succ_seq_to_colim_seq A)	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => colimp n0 n0.+1 1 (a0) ^+	           end	       |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 106;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 221) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) (a : A n) =>	       match	         p as p0 in (_ = y)	         return	           (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	       with	       | 1 => glue (succ_seq A) n (a) ^+	       end	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 107;
            data = "1 goal (ID 221)	  	  A : Sequence	  ============================	  Colimit_rec (Colimit (succ_seq A))	    {|	      legs :=	        fun (n : Graph.graph0 sequence_graph) (a : A n) =>	        inj (succ_seq A) n (a) ^+;	      legs_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) (a : A n) =>	        match	          p as p0 in (_ = y)	          return	            (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	        with	        | 1 => glue (succ_seq A) n (a) ^+	        end	    |} o colim_succ_seq_to_colim_seq A == idmap	2 goals (ID 385)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+;	       legs_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) 	           (a : A n0) =>	         match	           p as p0 in (_ = y)	           return	             (inj (succ_seq A) y ((A _f p0) a) ^+ =	              inj (succ_seq A) n0 (a) ^+)	         with	         | 1 => glue (succ_seq A) n0 (a) ^+	         end	     |} (colim_succ_seq_to_colim_seq A x)) o inj (succ_seq A) n ==	  idmap o inj (succ_seq A) n		goal 2 (ID 387) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	          inj (succ_seq A) n0 (a0) ^+;	        legs_comm :=	          fun (n0 m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n0 m) 	            (a0 : A n0) =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a0) ^+ =	               inj (succ_seq A) n0 (a0) ^+)	          with	          | 1 => glue (succ_seq A) n0 (a0) ^+	          end	      |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @ 	 ?h n a = ?h n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 108;
            data = "1 goal (ID 385)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+;	       legs_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) 	           (a : A n0) =>	         match	           p as p0 in (_ = y)	           return	             (inj (succ_seq A) y ((A _f p0) a) ^+ =	              inj (succ_seq A) n0 (a) ^+)	         with	         | 1 => glue (succ_seq A) n0 (a) ^+	         end	     |} (colim_succ_seq_to_colim_seq A x)) o inj (succ_seq A) n ==	  idmap o inj (succ_seq A) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 387) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	          inj (succ_seq A) n0 (a0) ^+;	        legs_comm :=	          fun (n0 m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n0 m) 	            (a0 : A n0) =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a0) ^+ =	               inj (succ_seq A) n0 (a0) ^+)	          with	          | 1 => glue (succ_seq A) n0 (a0) ^+	          end	      |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 109;
            data = "1 goal (ID 387)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	  ap	    (fun x : Colimit (succ_seq A) =>	     Colimit_rec (Colimit (succ_seq A))	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => glue (succ_seq A) n0 (a0) ^+	           end	       |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	1 goal (ID 413)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap	    (Colimit_rec (Colimit (succ_seq A))	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => colimp n0 n0.+1 1 (a0) ^+	           end	       |})	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	           inj A n0.+1 a0;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) =>	           match	             p as p0 in (_ = y)	             return	               ((fun x : succ_seq A n0 => inj A y.+1 (((succ_seq A) _f p0) x)) ==	                (fun a0 : succ_seq A n0 => inj A n0.+1 a0))	           with	           | 1 => colimp n0.+1 n0.+2 1	           end	       |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 110;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>equiv_colim_succ_seq_to_colim_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 113;
            data = "";
            responses[i]=data;
          

            i = 114;
            data = "";
            responses[i]=data;
          

            i = 115;
            data = "";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "1 goal (ID 207)	  	  A : Sequence	  n : nat	  ============================	  Colimit (shift_seq A n) -> Colimit A	";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "2 goals (ID 239)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A		goal 2 (ID 241) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (shift_seq A n) _f g == ?legs i	";
            responses[i]=data;
          

            i = 120;
            data = "1 goal (ID 239)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 241) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n)%nat a) j o (shift_seq A n) _f g ==	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n)%nat a) i	";
            responses[i]=data;
          

            i = 121;
            data = "1 goal (ID 241)	  	  A : Sequence	  n : nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n)%nat a) j o (shift_seq A n) _f g ==	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n)%nat a) i	No more goals.	";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "1 goal (ID 228)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a : shift_seq A n k	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (glue (shift_seq A n) k a) =	  glue A (k + n)%nat a	";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "1 goal (ID 258)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a1, a2 : shift_seq A n k	  p : a1 = a2	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (ap (inj (shift_seq A n) k) p) =	  ap (inj A (k + n)%nat) p	";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "1 goal (ID 290)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  I : forall x : X, Y x -> Z	  p : x1 = x2	  ============================	  I x2 y = I x1 (coe (ap Y p^) y)	";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 134;
            data = "";
            responses[i]=data;
          

            i = 135;
            data = "1 goal (ID 343)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  y : Y x1	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  p : x1 = x2	  ============================	  G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)	";
            responses[i]=data;
          

            i = 136;
            data = "";
            responses[i]=data;
          

            i = 137;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 138;
            data = "";
            responses[i]=data;
          

            i = 139;
            data = "1 goal (ID 474)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  I : forall x : X, Y x -> Z	  p : x1 = x2	  Q : forall (x : X) (y : Y x), I (F x) (G x y) = I x y	  ============================	  Q x2 y @ J p =	  J (ap F p) @	  (ap (I (F x1)) (K F G p^ @ ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @	   Q x1 (coe (ap Y p^) y))	";
            responses[i]=data;
          

            i = 140;
            data = "";
            responses[i]=data;
          

            i = 141;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 142;
            data = "";
            responses[i]=data;
          

            i = 143;
            data = "1 goal (ID 482)	  	  H : Funext	  A : Sequence	  n : nat	  ============================	  IsEquiv (colim_shift_seq_to_colim_seq A n)	";
            responses[i]=data;
          

            i = 144;
            data = "";
            responses[i]=data;
          

            i = 145;
            data = "4 goals (ID 505)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A		goal 2 (ID 509) is:	 ?f == colim_shift_seq_to_colim_seq A 0	goal 3 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 4 (ID 529) is:	 ?f0 == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 146;
            data = "1 goal (ID 505)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A	2 goals (ID 615)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A		goal 2 (ID 617) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 147;
            data = "1 goal (ID 615)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A	2 goals (ID 663)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i		goal 2 (ID 665) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A 0) _f g) x)	";
            responses[i]=data;
          

            i = 148;
            data = "1 goal (ID 663)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	5 goals		goal 1 (ID 665) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) i x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) j	   (((shift_seq A 0) _f g) x)	goal 2 (ID 617) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^);	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	goal 3 (ID 509) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph =>	           coe (ap A (nat_plus_n_O k)^);	         DiagramMap_comm := ?DiagramMap_comm	       |};	     diag_equiv_isequiv := ?H	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 4 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 5 (ID 529) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 149;
            data = "1 goal (ID 665)	  	  H : Funext	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	  (A _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) i	       x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) j	    (((shift_seq A 0) _f g) x)	1 goal (ID 710)	  	  H : Funext	  A : Sequence	  k : Graph.graph0 sequence_graph	  a : shift_seq A 0 k	  ============================	  coe (ap A (ap S (nat_plus_n_O k)^))	    ((fun (n : nat) (a0 : A n) => (a0) ^+) (k + 0)%nat a) =	  coe (ap A (nat_plus_n_O k.+1)^) (a) ^+	";
            responses[i]=data;
          

            i = 150;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 617) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A 0 k) =>	        match	          p as p0 in (_ = y)	          return	            ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	             coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	        with	        | 1 =>	            K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_plus_n_O k)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	        end	    |} i)	goal 2 (ID 509) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph =>	           coe (ap A (nat_plus_n_O k)^);	         DiagramMap_comm :=	           fun (k l : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph k l) 	             (a : shift_seq A 0 k) =>	           match	             p as p0 in (_ = y)	             return	               ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	           with	           | 1 =>	               K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_plus_n_O k)^ @	               ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	           end	       |};	     diag_equiv_isequiv := ?H	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 3 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 4 (ID 529) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 151;
            data = "1 goal (ID 617)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^);	       DiagramMap_comm :=	         fun (k l : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph k l) (a : shift_seq A 0 k) =>	         match	           p as p0 in (_ = y)	           return	             ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	              coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	         with	         | 1 =>	             K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_plus_n_O k)^ @	             ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	         end	     |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 509) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph =>	           coe (ap A (nat_plus_n_O k)^);	         DiagramMap_comm :=	           fun (k l : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph k l) 	             (a : shift_seq A 0 k) =>	           match	             p as p0 in (_ = y)	             return	               ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	           with	           | 1 =>	               K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_plus_n_O k)^ @	               ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	           end	       |};	     diag_equiv_isequiv :=	       fun k : Graph.graph0 sequence_graph =>	       isequiv_path (ap A (nat_plus_n_O k)^)	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 2 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 3 (ID 529) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 152;
            data = "1 goal (ID 509)	  	  H : Funext	  A : Sequence	  ============================	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_plus_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                 coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_plus_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_plus_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	  colim_shift_seq_to_colim_seq A 0	2 goals (ID 823)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_plus_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                 coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_plus_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_plus_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n		goal 2 (ID 825) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @ ?h0 n a =	 ?h0 n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_O k)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l) 	                (a0 : shift_seq A 0 k) =>	              match	                p as p0 in (_ = y)	                return	                  ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a0) =	                   coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a0))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                    (nat_plus_n_O k)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a0) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_plus_n_O k)^)	      |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 823)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_plus_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                 coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_plus_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_plus_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 825) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	  J (nat_plus_n_O k)) n a =	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	  J (nat_plus_n_O k)) n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_O k)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l) 	                (a0 : shift_seq A 0 k) =>	              match	                p as p0 in (_ = y)	                return	                  ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a0) =	                   coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a0))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                    (nat_plus_n_O k)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k)))) (a0) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_plus_n_O k)^)	      |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	goal 2 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 3 (ID 529) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 154;
            data = "1 goal (ID 825)	  	  H : Funext	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	  ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	   J (nat_plus_n_O k)) n a =	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	   J (nat_plus_n_O k)) n.+1 (a) ^+ @	  ap	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_plus_n_O k)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l) 	                 (a0 : shift_seq A 0 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a0) =	                    coe (ap A (nat_plus_n_O y)^) (((shift_seq A 0) _f p0) a0))	               with	               | 1 =>	                   K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                     (nat_plus_n_O k)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k))))	                     (a0) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_plus_n_O k)^)	       |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	    (glue (shift_seq A 0) n a)	";
            responses[i]=data;
          

            i = 155;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 525) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 2 (ID 529) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	1 goal (ID 525)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit A	2 goals (ID 872)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))		goal 2 (ID 873) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	";
            responses[i]=data;
          

            i = 156;
            data = "1 goal (ID 872)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))	2 goals (ID 959)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))		goal 2 (ID 961) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 157;
            data = "1 goal (ID 959)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))	2 goals (ID 1007)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i		goal 2 (ID 1009) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A n.+1) _f g) x)	";
            responses[i]=data;
          

            i = 158;
            data = "1 goal (ID 1007)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1009) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	      i x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	   (((shift_seq A n.+1) _f g) x)	goal 2 (ID 961) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph =>	        coe (ap A (nat_plus_n_Sm k n)^);	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	goal 3 (ID 873) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 4 (ID 529) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_Sm k n)^);	            DiagramMap_comm := ?DiagramMap_comm	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 159;
            data = "1 goal (ID 1009)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 goal (ID 1009)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 goal (ID 1055)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  coe (ap A (ap S (nat_plus_n_Sm k n)^)) (a) ^+ =	  coe (ap A (nat_plus_n_Sm k.+1 n)^) (a) ^+	";
            responses[i]=data;
          

            i = 160;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 961) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph =>	        coe (ap A (nat_plus_n_Sm k n)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	        match	          p as p0 in (_ = y)	          return	            (((succ_seq (shift_seq A n)) _f p0)	               (coe (ap A (nat_plus_n_Sm k n)^) a) =	             coe (ap A (nat_plus_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	        with	        | 1 =>	            K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_plus_n_Sm k n)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n)))) (a) ^+	        end	    |} i)	goal 2 (ID 873) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 3 (ID 529) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_plus_n_Sm k n)^) a) =	                   coe (ap A (nat_plus_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_plus_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 161;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 961) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph =>	        coe (ap A (nat_plus_n_Sm k n)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	        match	          p as p0 in (_ = y)	          return	            (((succ_seq (shift_seq A n)) _f p0)	               (coe (ap A (nat_plus_n_Sm k n)^) a) =	             coe (ap A (nat_plus_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	        with	        | 1 =>	            K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_plus_n_Sm k n)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n)))) (a) ^+	        end	    |} i)	goal 2 (ID 873) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 3 (ID 529) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_plus_n_Sm k n)^) a) =	                   coe (ap A (nat_plus_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_plus_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	1 goal (ID 961)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun k : Graph.graph0 sequence_graph =>	         coe (ap A (nat_plus_n_Sm k n)^);	       DiagramMap_comm :=	         fun (k l : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	         match	           p as p0 in (_ = y)	           return	             (((succ_seq (shift_seq A n)) _f p0)	                (coe (ap A (nat_plus_n_Sm k n)^) a) =	              coe (ap A (nat_plus_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	         with	         | 1 =>	             K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_plus_n_Sm k n)^ @	             ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n)))) (a) ^+	         end	     |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 873) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 2 (ID 529) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_plus_n_Sm k n)^) a) =	                   coe (ap A (nat_plus_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_plus_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_plus_n_Sm k n)^)	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 162;
            data = "1 goal (ID 873)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (succ_seq (shift_seq A n)) <~> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 529) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_plus_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_plus_n_Sm k n)^) a) =	                   coe (ap A (nat_plus_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_plus_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_plus_n_Sm k n)^)	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n))))	   (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	      {| equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e |}) ==	 colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 163;
            data = "1 goal (ID 529)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_plus_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_plus_n_Sm k n)^) a) =	                    coe (ap A (nat_plus_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                     (nat_plus_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_plus_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) == colim_shift_seq_to_colim_seq A n.+1	2 goals (ID 1184)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_plus_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_plus_n_Sm k n)^) a) =	                    coe (ap A (nat_plus_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a0 : A n1) => (a0) ^+)	                     (nat_plus_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_plus_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) n0		goal 2 (ID 1186) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 ?h n0 a =	 ?h n0.+1 (a) ^+ @	 ap	   (transitive_equiv (Colimit (shift_seq A n.+1))	      (Colimit (succ_seq (shift_seq A n))) (Colimit A)	      (equiv_functor_colimit	         {|	           diag_equiv_map :=	             {|	               DiagramMap_obj :=	                 fun k : Graph.graph0 sequence_graph =>	                 coe (ap A (nat_plus_n_Sm k n)^);	               DiagramMap_comm :=	                 fun (k l : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph k l)	                   (a0 : shift_seq A n.+1 k) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (((succ_seq (shift_seq A n)) _f p0)	                        (coe (ap A (nat_plus_n_Sm k n)^) a0) =	                      coe (ap A (nat_plus_n_Sm y n)^)	                        (((shift_seq A n.+1) _f p0) a0))	                 with	                 | 1 =>	                     K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                       (nat_plus_n_Sm k n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                       (a0) ^+	                 end	             |};	           diag_equiv_isequiv :=	             fun k : Graph.graph0 sequence_graph =>	             isequiv_path (ap A (nat_plus_n_Sm k n)^)	         |} (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	           equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	         |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 164;
            data = "1 goal (ID 1184)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_plus_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_plus_n_Sm k n)^) a) =	                    coe (ap A (nat_plus_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a0 : A n1) => (a0) ^+)	                     (nat_plus_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_plus_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) n0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 1186) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	  J (nat_plus_n_Sm k n)) n0 a =	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	  J (nat_plus_n_Sm k n)) n0.+1 (a) ^+ @	 ap	   (transitive_equiv (Colimit (shift_seq A n.+1))	      (Colimit (succ_seq (shift_seq A n))) (Colimit A)	      (equiv_functor_colimit	         {|	           diag_equiv_map :=	             {|	               DiagramMap_obj :=	                 fun k : Graph.graph0 sequence_graph =>	                 coe (ap A (nat_plus_n_Sm k n)^);	               DiagramMap_comm :=	                 fun (k l : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph k l)	                   (a0 : shift_seq A n.+1 k) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (((succ_seq (shift_seq A n)) _f p0)	                        (coe (ap A (nat_plus_n_Sm k n)^) a0) =	                      coe (ap A (nat_plus_n_Sm y n)^)	                        (((shift_seq A n.+1) _f p0) a0))	                 with	                 | 1 =>	                     K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                       (nat_plus_n_Sm k n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                       (a0) ^+	                 end	             |};	           diag_equiv_isequiv :=	             fun k : Graph.graph0 sequence_graph =>	             isequiv_path (ap A (nat_plus_n_Sm k n)^)	         |} (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	           equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	         |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 165;
            data = "1 goal (ID 1186)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	  ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	   J (nat_plus_n_Sm k n)) n0 a =	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	   J (nat_plus_n_Sm k n)) n0.+1 (a) ^+ @	  ap	    (transitive_equiv (Colimit (shift_seq A n.+1))	       (Colimit (succ_seq (shift_seq A n))) (Colimit A)	       (equiv_functor_colimit	          {|	            diag_equiv_map :=	              {|	                DiagramMap_obj :=	                  fun k : Graph.graph0 sequence_graph =>	                  coe (ap A (nat_plus_n_Sm k n)^);	                DiagramMap_comm :=	                  fun (k l : Graph.graph0 sequence_graph)	                    (p : Graph.graph1 sequence_graph k l)	                    (a0 : shift_seq A n.+1 k) =>	                  match	                    p as p0 in (_ = y)	                    return	                      (((succ_seq (shift_seq A n)) _f p0)	                         (coe (ap A (nat_plus_n_Sm k n)^) a0) =	                       coe (ap A (nat_plus_n_Sm y n)^)	                         (((shift_seq A n.+1) _f p0) a0))	                  with	                  | 1 =>	                      K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                        (nat_plus_n_Sm k n)^ @	                      ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                        (a0) ^+	                  end	              |};	            diag_equiv_isequiv :=	              fun k : Graph.graph0 sequence_graph =>	              isequiv_path (ap A (nat_plus_n_Sm k n)^)	          |} (iscolimit_colimit (shift_seq A n.+1))	          (iscolimit_colimit (succ_seq (shift_seq A n))))	       (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	          {|	            equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	          |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 166;
            data = "1 goal (ID 1253)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  ap	    (fun x : Colimit (shift_seq A n.+1) =>	     colim_shift_seq_to_colim_seq A n	       (colim_succ_seq_to_colim_seq (shift_seq A n)	          (functor_colimit	             {|	               DiagramMap_obj :=	                 fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	               DiagramMap_comm :=	                 fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (match	                        p0 in (_ = y0)	                        return (A (k0 + n).+1 -> A (y0 + n).+1)	                      with	                      | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                      end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                      coe (ap A (nat_plus_n_Sm y n)^)	                        (match	                           p0 in (_ = y0)	                           return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                         with	                         | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                         end a0))	                 with	                 | 1 =>	                     K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                       (nat_plus_n_Sm k0 n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                       (a0) ^+	                 end	             |} (iscolimit_colimit (shift_seq A n.+1))	             (iscolimit_colimit (succ_seq (shift_seq A n))) x)))	    (colimp k k.+1 1 a)	";
            responses[i]=data;
          

            i = 167;
            data = "";
            responses[i]=data;
          

            i = 168;
            data = "";
            responses[i]=data;
          

            i = 169;
            data = "1 goal (ID 1308)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (ap (iscolimit_colimit (succ_seq (shift_seq A n)) k.+1)	           (DiagramMap_comm	              {|	                DiagramMap_obj :=	                  fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	                DiagramMap_comm :=	                  fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat)	                  =>	                  match	                    p as p0 in (_ = y)	                    return	                      (match	                         p0 in (_ = y0)	                         return (A (k0 + n).+1 -> A (y0 + n).+1)	                       with	                       | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                       end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                       coe (ap A (nat_plus_n_Sm y n)^)	                         (match	                            p0 in (_ = y0)	                            return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                          with	                          | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                          end a0))	                  with	                  | 1 =>	                      K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                        (nat_plus_n_Sm k0 n)^ @	                      ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                        (a0) ^+	                  end	              |} 1 a)^)) @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	              DiagramMap_obj :=	                fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	                match	                  p as p0 in (_ = y)	                  return	                    (match	                       p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                     with	                     | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                     end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_plus_n_Sm y n)^)	                       (match	                          p0 in (_ = y0)	                          return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                        with	                        | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                        end a0))	                with	                | 1 =>	                    K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                      (nat_plus_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                      (a0) ^+	                end	            |} k a))))	";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "1 goal (ID 1312)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (inj A (k.+2 + n)%nat)	     (DiagramMap_comm	        {|	          DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	          DiagramMap_comm :=	            fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	            match	              p as p0 in (_ = y)	              return	                (match	                   p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                 with	                 | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                 end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                 coe (ap A (nat_plus_n_Sm y n)^)	                   (match	                      p0 in (_ = y0)	                      return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                    with	                    | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                    end a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                  (nat_plus_n_Sm k0 n)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                  (a0) ^+	            end	        |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	              DiagramMap_obj :=	                fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	                match	                  p as p0 in (_ = y)	                  return	                    (match	                       p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                     with	                     | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                     end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_plus_n_Sm y n)^)	                       (match	                          p0 in (_ = y0)	                          return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                        with	                        | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                        end a0))	                with	                | 1 =>	                    K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                      (nat_plus_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                      (a0) ^+	                end	            |} k a))))	1 goal (ID 1313)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (inj A (k.+2 + n)%nat)	     (DiagramMap_comm	        {|	          DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	          DiagramMap_comm :=	            fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	            match	              p as p0 in (_ = y)	              return	                (match	                   p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                 with	                 | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                 end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                 coe (ap A (nat_plus_n_Sm y n)^)	                   (match	                      p0 in (_ = y0)	                      return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                    with	                    | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                    end a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                  (nat_plus_n_Sm k0 n)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                  (a0) ^+	            end	        |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (colimp k.+1 k.+2 1	        ({|	           DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	           DiagramMap_comm :=	             fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)%nat) =>	             match	               p as p0 in (_ = y)	               return	                 (match	                    p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                  with	                  | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                  end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                  coe (ap A (nat_plus_n_Sm y n)^)	                    (match	                       p0 in (_ = y0)	                       return (A (k0 + n.+1)%nat -> A (y0 + n.+1)%nat)	                     with	                     | 1 => fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                     end a0))	             with	             | 1 =>	                 K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                   (nat_plus_n_Sm k0 n)^ @	                 ap10 (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                   (a0) ^+	             end	         |} k a)))	No more goals.	";
            responses[i]=data;
          

            i = 172;
            data = "";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "<infomsg>equiv_colim_shift_seq_to_colim_seq is defined</infomsg>	1 goal (ID 500)	  	  H : Funext	  A : Sequence	  ============================	  (forall k : Graph.graph0 sequence_graph, Contr (A k)) -> Contr (Colimit A)	1 goal (ID 505)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit A)	2 goals (ID 519)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A		goal 2 (ID 521) is:	 Contr (Colimit unit_seq)	1 goal (ID 519)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A	1 goal (ID 588)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  A ~d~ unit_seq	2 goals (ID 663)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i		goal 2 (ID 665) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g) (?DiagramMap_obj i x) = ?DiagramMap_obj j ((A _f g) x)	1 goal (ID 663)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 665) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g)	   ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	 (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	goal 2 (ID 521) is:	 Contr (Colimit unit_seq)	1 goal (ID 665)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  (unit_seq _f g)	    ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	  (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 521) is:	 Contr (Colimit unit_seq)	1 goal (ID 521)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit unit_seq)	1 goal (ID 697)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall y : Colimit unit_seq, y = inj unit_seq 0 tt	2 goals (ID 731)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n		goal 2 (ID 733) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 186;
            data = "1 goal (ID 731)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n	2 goals (ID 743)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt		goal 2 (ID 746) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	";
            responses[i]=data;
          

            i = 187;
            data = "1 goal (ID 743)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 746) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	goal 2 (ID 733) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         ?Goal@{n:=n1}) n0	  end) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         ?Goal@{n:=n1}) n0	  end) n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 188;
            data = "1 goal (ID 746)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  n : nat	  r : inj unit_seq n tt = inj unit_seq 0 tt	  ============================	  inj unit_seq n.+1 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 733) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         glue unit_seq n1 tt @ r) n0	  end) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         glue unit_seq n1 tt @ r) n0	  end) n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 189;
            data = "1 goal (ID 733)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	  ap idmap (glue unit_seq n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end) n.+1 (a) ^+ @	  ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	No more goals.	";
            responses[i]=data;
          

            i = 190;
            data = "";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "";
            responses[i]=data;
          

            i = 195;
            data = "<infomsg>FibSequence is defined</infomsg>	<infomsg>FibSequence_rect is defined</infomsg>	<infomsg>FibSequence_ind is defined</infomsg>	<infomsg>FibSequence_rec is defined</infomsg>	<infomsg>FibSequence_sind is defined</infomsg>	<infomsg>fibSequence is defined</infomsg>	<infomsg>fibSequenceArr is defined</infomsg>	";
            responses[i]=data;
          

            i = 196;
            data = "<infomsg>fibSequence is now a coercion</infomsg>	";
            responses[i]=data;
          

            i = 197;
            data = "";
            responses[i]=data;
          

            i = 198;
            data = "";
            responses[i]=data;
          

            i = 199;
            data = "";
            responses[i]=data;
          

            i = 200;
            data = "";
            responses[i]=data;
          

            i = 201;
            data = "";
            responses[i]=data;
          

            i = 202;
            data = "";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "1 goal (ID 504)	  	  A : Sequence	  B : FibSequence A	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "2 goals (ID 508)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type		goal 2 (ID 510) is:	 forall n : nat, ?X n -> ?X n.+1	";
            responses[i]=data;
          

            i = 207;
            data = "1 goal (ID 508)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 510) is:	 forall n : nat,	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	";
            responses[i]=data;
          

            i = 208;
            data = "1 goal (ID 510)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall n : nat,	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	No more goals.	";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "1 goal (ID 511)	  	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> Colimit A	";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "2 goals (ID 543)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A		goal 2 (ID 545) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 217;
            data = "1 goal (ID 543)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 545) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	 (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	";
            responses[i]=data;
          

            i = 218;
            data = "1 goal (ID 545)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	  (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	No more goals.	";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "1 goal (ID 517)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "4 goals (ID 533)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type		goal 2 (ID 536) is:	 {x : _ & A x} -> Type	goal 3 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 1 x	goal 4 (ID 543) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+2 x	";
            responses[i]=data;
          

            i = 227;
            data = "1 goal (ID 533)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 536) is:	 {x : _ & A x} -> Type	goal 2 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 1 x	goal 3 (ID 543) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+1	   x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+2	   x	";
            responses[i]=data;
          

            i = 228;
            data = "1 goal (ID 536)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : {x : _ & A x} -> Type	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 1 x	goal 2 (ID 543) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 229;
            data = "1 goal (ID 540)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 0 x ->	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 1 x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 543) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 230;
            data = "1 goal (ID 543)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : forall x : {x : _ & A x},	      nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k x ->	      nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k.+1 x	  ============================	  forall x : {x : _ & A x},	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+1 x ->	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+2 x	No more goals.	";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "<infomsg>fib_seq_to_seq' is defined</infomsg>	";
            responses[i]=data;
          

            i = 237;
            data = "1 goal (ID 537)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  fib_seq_to_seq B x ~d~ fib_seq_to_seq' B x	";
            responses[i]=data;
          

            i = 238;
            data = "";
            responses[i]=data;
          

            i = 239;
            data = "2 goals (ID 560)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)		goal 2 (ID 562) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 240;
            data = "1 goal (ID 560)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)	2 goals (ID 608)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i		goal 2 (ID 610) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g) (?DiagramMap_obj i x0) =	 ?DiagramMap_obj j (((fib_seq_to_seq B x) _f g) x0)	";
            responses[i]=data;
          

            i = 241;
            data = "1 goal (ID 608)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i	2 goals (ID 617)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0		goal 2 (ID 620) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	";
            responses[i]=data;
          

            i = 242;
            data = "1 goal (ID 617)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 620) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	goal 2 (ID 610) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	        ?Goal@{n:=n0}) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	     ?Goal@{n:=n0}) n x) j (((fib_seq_to_seq B x) _f g) x0)	goal 3 (ID 562) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0) =>	           ?Goal@{n:=n0}) n x;	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 243;
            data = "1 goal (ID 620)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x}, fib_seq_to_seq B x n -> fib_seq_to_seq' B x n	  ============================	  forall x : {x : _ & A x},	  fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 610) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	          (x1 : {x : _ & A x}) =>	        coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	   (((fib_seq_to_seq B x) _f g) x0)	goal 2 (ID 562) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 244;
            data = "1 goal (ID 610)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	  ((fib_seq_to_seq' B x) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      nat_rect	        (fun n0 : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n0 : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	           (x1 : {x : _ & A x}) =>	         coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	  (fun n : Graph.graph0 sequence_graph =>	   nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	    (((fib_seq_to_seq B x) _f g) x0)	2 goals (ID 655)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+		goal 2 (ID 658) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	";
            responses[i]=data;
          

            i = 245;
            data = "1 goal (ID 655)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 658) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	goal 2 (ID 562) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n,	             ((fib_seq_to_seq' B x) _f p0)	               (nat_rect	                  (fun n0 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n0 : nat)	                     (e : forall x1 : {x : _ & A x},	                          fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                   => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                  n x x0) =	             nat_rect	               (fun n0 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x1 : {x : _ & A x},	                       fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            nat_rect	              (fun n0 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	               (nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0 x0 x1) ^+ =	               nat_rect	                 (fun n1 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n1 : nat)	                    (e : forall x2 : {x : _ & A x},	                         fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                  => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                 n0.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n0 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n0),	                       (nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                       nat_rect	                         (fun n1 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n1 : nat)	                            (e : forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                          coe (ap B (seq_pair_shift_assoc x2 n1))	                            (e (x2) ^++ x3)) n0.+1 x0 	                         (x1) ^+) => ?Goal@{n:=n0; p:=p0}) n x	        end	    |} i)	";
            responses[i]=data;
          

            i = 246;
            data = "1 goal (ID 658)	  	  A : Sequence	  B : FibSequence A	  n : nat	  p : forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n),	      (nat_rect	         (fun n : nat =>	          forall x1 : {x : _ & A x},	          fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	         (fun x1 : {x : _ & A x} => idmap)	         (fun (n : nat)	            (e : forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	            (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	          coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n x x0) ^+ =	      nat_rect	        (fun n : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	           (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	         coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n.+1 x	        (x0) ^+	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	  (nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 562) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n,	             ((fib_seq_to_seq' B x) _f p0)	               (nat_rect	                  (fun n0 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n0 : nat)	                     (e : forall x1 : {x : _ & A x},	                          fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                   => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                  n x x0) =	             nat_rect	               (fun n0 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x1 : {x : _ & A x},	                       fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            nat_rect	              (fun n0 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	               (nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0 x0 x1) ^+ =	               nat_rect	                 (fun n1 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n1 : nat)	                    (e : forall x2 : {x : _ & A x},	                         fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                  => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                 n0.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n0 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n0),	                       (nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                       nat_rect	                         (fun n1 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n1 : nat)	                            (e : forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                          coe (ap B (seq_pair_shift_assoc x2 n1))	                            (e (x2) ^++ x3)) n0.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n0.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n0) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                 (p0 (x0) ^++ b)) n x	        end	    |} i)	";
            responses[i]=data;
          

            i = 247;
            data = "1 goal (ID 562)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} i)	2 goals (ID 693)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} 0)		goal 2 (ID 696) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n0 : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n1 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n1 : nat)	             (e0 : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	             (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	           coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	      DiagramMap_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n0,	             ((fib_seq_to_seq' B x) _f p0)	               (nat_rect	                  (fun n1 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e0 : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                   =>	                   coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                  n0 x x0) =	             nat_rect	               (fun n1 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n1 : nat)	                  (e0 : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            nat_rect	              (fun n1 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	               (nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1 x0 x1) ^+ =	               nat_rect	                 (fun n2 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n2 : nat)	                    (e0 : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                  => coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                 n1.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n1 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n1),	                       (nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                       nat_rect	                         (fun n2 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n2 : nat)	                            (e0 : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                          coe (ap B (seq_pair_shift_assoc x2 n2))	                            (e0 (x2) ^++ x3)) n1.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n1.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n1) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                 (p0 (x0) ^++ b)) n0 x	        end	    |} n.+1)	";
            responses[i]=data;
          

            i = 248;
            data = "1 goal (ID 693)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} 0)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 696) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n0 : Graph.graph0 sequence_graph =>	        nat_rect	          (fun n1 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n1 : nat)	             (e0 : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	             (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	           coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	      DiagramMap_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n0,	             ((fib_seq_to_seq' B x) _f p0)	               (nat_rect	                  (fun n1 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e0 : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                   =>	                   coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                  n0 x x0) =	             nat_rect	               (fun n1 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n1 : nat)	                  (e0 : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            nat_rect	              (fun n1 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	               (nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1 x0 x1) ^+ =	               nat_rect	                 (fun n2 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n2 : nat)	                    (e0 : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                  => coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                 n1.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n1 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n1),	                       (nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                       nat_rect	                         (fun n2 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n2 : nat)	                            (e0 : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                          coe (ap B (seq_pair_shift_assoc x2 n2))	                            (e0 (x2) ^++ x3)) n1.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n1.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n1) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                 (p0 (x0) ^++ b)) n0 x	        end	    |} n.+1)	";
            responses[i]=data;
          

            i = 249;
            data = "1 goal (ID 696)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x},	      IsEquiv	        ({|	           DiagramMap_obj :=	             fun n : Graph.graph0 sequence_graph =>	             nat_rect	               (fun n0 : nat =>	                forall x0 : {x : _ & A x},	                fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	               (fun x0 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x0 : {x : _ & A x},	                       fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                  (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	           DiagramMap_comm :=	             fun (n m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n m) =>	             match	               p as p0 in (_ = y)	               return	                 (forall x0 : fib_seq_to_seq B x n,	                  ((fib_seq_to_seq' B x) _f p0)	                    (nat_rect	                       (fun n0 : nat =>	                        forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                       (fun x1 : {x : _ & A x} => idmap)	                       (fun (n0 : nat)	                          (e : forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n0 ->	                               fib_seq_to_seq' B x1 n0) 	                          (x1 : {x : _ & A x})	                          (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                        coe (ap B (seq_pair_shift_assoc x1 n0))	                          (e (x1) ^++ x2)) n x x0) =	                  nat_rect	                    (fun n0 : nat =>	                     forall x1 : {x : _ & A x},	                     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                    (fun x1 : {x : _ & A x} => idmap)	                    (fun (n0 : nat)	                       (e : forall x1 : {x : _ & A x},	                            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                       (x1 : {x : _ & A x})	                       (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                    y x (((fib_seq_to_seq B x) _f p0) x0))	             with	             | 1 =>	                 nat_rect	                   (fun n0 : nat =>	                    forall (x0 : {x : _ & A x})	                    (x1 : fib_seq_to_seq B x0 n0),	                    (nat_rect	                       (fun n1 : nat =>	                        forall x2 : {x : _ & A x},	                        fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                       (fun x2 : {x : _ & A x} => idmap)	                       (fun (n1 : nat)	                          (e : forall x2 : {x : _ & A x},	                               fib_seq_to_seq B x2 n1 ->	                               fib_seq_to_seq' B x2 n1) 	                          (x2 : {x : _ & A x})	                          (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                        coe (ap B (seq_pair_shift_assoc x2 n1))	                          (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                    nat_rect	                      (fun n1 : nat =>	                       forall x2 : {x : _ & A x},	                       fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (fun x2 : {x : _ & A x} => idmap)	                      (fun (n1 : nat)	                         (e : forall x2 : {x : _ & A x},	                              fib_seq_to_seq B x2 n1 ->	                              fib_seq_to_seq' B x2 n1) 	                         (x2 : {x : _ & A x})	                         (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                       coe (ap B (seq_pair_shift_assoc x2 n1))	                         (e (x2) ^++ x3)) n0.+1 x0 	                      (x1) ^+)	                   (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) =>	                    1)	                   (fun (n0 : nat)	                      (p0 : forall (x0 : {x : _ & A x})	                            (x1 : fib_seq_to_seq B x0 n0),	                            (nat_rect	                               (fun n1 : nat =>	                                forall x2 : {x : _ & A x},	                                fib_seq_to_seq B x2 n1 ->	                                fib_seq_to_seq' B x2 n1)	                               (fun x2 : {x : _ & A x} => idmap)	                               (fun (n1 : nat)	                                  (e : forall x2 : {x : _ & A x},	                                       fib_seq_to_seq B x2 n1 ->	                                       fib_seq_to_seq' B x2 n1)	                                  (x2 : {x : _ & A x})	                                  (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                coe (ap B (seq_pair_shift_assoc x2 n1))	                                  (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                            nat_rect	                              (fun n1 : nat =>	                               forall x2 : {x : _ & A x},	                               fib_seq_to_seq B x2 n1 ->	                               fib_seq_to_seq' B x2 n1)	                              (fun x2 : {x : _ & A x} => idmap)	                              (fun (n1 : nat)	                                 (e : forall x2 : {x : _ & A x},	                                      fib_seq_to_seq B x2 n1 ->	                                      fib_seq_to_seq' B x2 n1)	                                 (x2 : {x : _ & A x})	                                 (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                               coe (ap B (seq_pair_shift_assoc x2 n1))	                                 (e (x2) ^++ x3)) n0.+1 x0 	                              (x1) ^+) (x0 : {x : _ & A x})	                      (b : fib_seq_to_seq B x0 n0.+1) =>	                    K seq_pair_shift (fibSequenceArr B)	                      (seq_pair_shift_assoc x0 n0) @	                    ap	                      (coe	                         (ap B	                            (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                      (p0 (x0) ^++ b)) n x	             end	         |} n)	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n0 : Graph.graph0 sequence_graph =>	         nat_rect	           (fun n1 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n1 : nat)	              (e0 : forall x0 : {x : _ & A x},	                    fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	            coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	       DiagramMap_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n0,	              ((fib_seq_to_seq' B x) _f p0)	                (nat_rect	                   (fun n1 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e0 : forall x1 : {x : _ & A x},	                            fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                   n0 x x0) =	              nat_rect	                (fun n1 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n1 : nat)	                   (e0 : forall x1 : {x : _ & A x},	                         fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                 => coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             nat_rect	               (fun n1 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	                (nat_rect	                   (fun n2 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n2 : nat)	                      (e0 : forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                    coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                   n1 x0 x1) ^+ =	                nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n1 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n1),	                        (nat_rect	                           (fun n2 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n2 : nat)	                              (e0 : forall x2 : {x : _ & A x},	                                    fib_seq_to_seq B x2 n2 ->	                                    fib_seq_to_seq' B x2 n2)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                            coe (ap B (seq_pair_shift_assoc x2 n2))	                              (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                        nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n1.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n1) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                  (p0 (x0) ^++ b)) n0 x	         end	     |} n.+1)	No more goals.	";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "1 goal (ID 543)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit A -> Type	";
            responses[i]=data;
          

            i = 256;
            data = "";
            responses[i]=data;
          

            i = 257;
            data = "2 goals (ID 575)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type		goal 2 (ID 577) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 258;
            data = "1 goal (ID 575)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 577) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) i	";
            responses[i]=data;
          

            i = 259;
            data = "1 goal (ID 577)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) i	1 goal (ID 597)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) <~>	  Colimit (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 260;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "1 goal (ID 573)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe (ap (fib_seq_to_type_fam B) (glue A n a)) =	  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "1 goal (ID 599)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           Colimit (fib_seq_to_seq B (n0; a0));	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (Colimit (fib_seq_to_seq B (y; (A _f p0) a0)) =	                Colimit (fib_seq_to_seq B (n0; a0)))	           with	           | 1 =>	               path_universe_uncurried	                 (equiv_colim_succ_seq_to_colim_seq	                    (fib_seq_to_seq B (n0; a0)))	           end	       |} n n.+1 1 a) = colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 265;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 266;
            data = "";
            responses[i]=data;
          

            i = 267;
            data = "1 goal (ID 609)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  (x1; y) = (x2; F y)	";
            responses[i]=data;
          

            i = 268;
            data = "";
            responses[i]=data;
          

            i = 269;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 270;
            data = "";
            responses[i]=data;
          

            i = 271;
            data = "1 goal (ID 649)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  ap pr1 (Delta p psi y) = p	";
            responses[i]=data;
          

            i = 272;
            data = "";
            responses[i]=data;
          

            i = 273;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 274;
            data = "";
            responses[i]=data;
          

            i = 275;
            data = "";
            responses[i]=data;
          

            i = 276;
            data = "";
            responses[i]=data;
          

            i = 277;
            data = "";
            responses[i]=data;
          

            i = 278;
            data = "";
            responses[i]=data;
          

            i = 279;
            data = "1 goal (ID 659)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> {x : _ & fib_seq_to_type_fam B x}	";
            responses[i]=data;
          

            i = 280;
            data = "";
            responses[i]=data;
          

            i = 281;
            data = "2 goals (ID 691)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}		goal 2 (ID 693) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 282;
            data = "1 goal (ID 691)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 693) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	 o (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	";
            responses[i]=data;
          

            i = 283;
            data = "1 goal (ID 693)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	  o (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	1 goal (ID 726)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  (inj A n.+1 ((a; b)) ^+.1;	  inj (fib_seq_to_seq B (n.+1; ((a; b)) ^+.1)) 0 ((a; b)) ^+.2) =	  (inj A n a; inj (fib_seq_to_seq B (n; a)) 1 (b) ^+)	";
            responses[i]=data;
          

            i = 284;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 285;
            data = "";
            responses[i]=data;
          

            i = 286;
            data = "1 goal (ID 725)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)) =	  Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	    (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+) @	  ap (exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B (n; a)) 0 b)	";
            responses[i]=data;
          

            i = 287;
            data = "";
            responses[i]=data;
          

            i = 288;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 289;
            data = "";
            responses[i]=data;
          

            i = 290;
            data = "";
            responses[i]=data;
          

            i = 291;
            data = "";
            responses[i]=data;
          

            i = 292;
            data = "";
            responses[i]=data;
          

            i = 293;
            data = "";
            responses[i]=data;
          

            i = 294;
            data = "";
            responses[i]=data;
          

            i = 295;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	";
            responses[i]=data;
          

            i = 296;
            data = "<infomsg>E is declared</infomsg>	";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>e is declared</infomsg>	";
            responses[i]=data;
          

            i = 298;
            data = "<infomsg>t is declared</infomsg>	";
            responses[i]=data;
          

            i = 299;
            data = "";
            responses[i]=data;
          

            i = 300;
            data = "";
            responses[i]=data;
          

            i = 301;
            data = "";
            responses[i]=data;
          

            i = 302;
            data = "";
            responses[i]=data;
          

            i = 303;
            data = "1 goal (ID 793)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)	";
            responses[i]=data;
          

            i = 304;
            data = "";
            responses[i]=data;
          

            i = 305;
            data = "2 goals (ID 797)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)		goal 2 (ID 800) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 306;
            data = "1 goal (ID 797)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 800) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 307;
            data = "1 goal (ID 800)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	No more goals.	";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "";
            responses[i]=data;
          

            i = 310;
            data = "";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "";
            responses[i]=data;
          

            i = 313;
            data = "1 goal (ID 868)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  transport (Z o exist Y x) p o transport Z q1 == transport Z q2	";
            responses[i]=data;
          

            i = 314;
            data = "";
            responses[i]=data;
          

            i = 315;
            data = "1 goal (ID 893)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1 : Y x	  z : {x : _ & Y x}	  ============================	  (fun x0 : Z z => transport Z 1 x0) == transport Z (1 @ 1)	";
            responses[i]=data;
          

            i = 316;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "1 goal (ID 979)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  transport (Z o exist Y x2) r o transport Z (Delta p psi y1) ==	  transport Z (Delta p psi y2) o transport (Z o exist Y x1) q	";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "";
            responses[i]=data;
          

            i = 323;
            data = "";
            responses[i]=data;
          

            i = 324;
            data = "";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "1 goal (ID 1018)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k),	  transport (E o exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B (n; a)) k b) (Q k.+1 n a (b) ^+) = 	  Q k n a b	";
            responses[i]=data;
          

            i = 327;
            data = "";
            responses[i]=data;
          

            i = 328;
            data = "2 goals (ID 1022)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b		goal 2 (ID 1025) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 329;
            data = "1 goal (ID 1022)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b	1 goal (ID 1034)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) 0	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) =	  transport E	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (e n.+1 (a) ^+ (b) ^+f)	";
            responses[i]=data;
          

            i = 330;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1025) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 331;
            data = "1 goal (ID 1025)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	1 goal (ID 1069)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) k.+1	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	       (inj (fib_seq_to_seq B (n.+1; (a) ^+)) k b))	    (transport	       (fun x : fib_seq_to_type_fam B (inj A n.+1 (a) ^+) =>	        E (inj A n.+1 (a) ^+; x)) (colimp k k.+1 1 b)	       (Q k.+1 n.+1 (a) ^+ (b) ^+))	";
            responses[i]=data;
          

            i = 332;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 333;
            data = "";
            responses[i]=data;
          

            i = 334;
            data = "";
            responses[i]=data;
          

            i = 335;
            data = "";
            responses[i]=data;
          

            i = 336;
            data = "";
            responses[i]=data;
          

            i = 337;
            data = "";
            responses[i]=data;
          

            i = 338;
            data = "1 goal (ID 1031)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall x : fib_seq_to_type_fam B (inj A n a), E (inj A n a; x)	";
            responses[i]=data;
          

            i = 339;
            data = "";
            responses[i]=data;
          

            i = 340;
            data = "2 goals (ID 1049)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : fib_seq_to_seq B (n; a) i),	  (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (inj (fib_seq_to_seq B (n; a)) i x)		goal 2 (ID 1051) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	 transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	   (colimp i j g x) (?q j (((fib_seq_to_seq B (n; a)) _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 341;
            data = "1 goal (ID 1049)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : fib_seq_to_seq B (n; a) i),	  (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (inj (fib_seq_to_seq B (n; a)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1051) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	 transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	   (colimp i j g x)	   ((fun k : Graph.graph0 sequence_graph => Q k n a) j	      (((fib_seq_to_seq B (n; a)) _f g) x)) =	 (fun k : Graph.graph0 sequence_graph => Q k n a) i x	";
            responses[i]=data;
          

            i = 342;
            data = "1 goal (ID 1051)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	  transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (colimp i j g x)	    ((fun k : Graph.graph0 sequence_graph => Q k n a) j	       (((fib_seq_to_seq B (n; a)) _f g) x)) =	  (fun k : Graph.graph0 sequence_graph => Q k n a) i x	No more goals.	";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "1 goal (ID 1050)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) 0	  ============================	  apD (F n a) (glue (fib_seq_to_seq B (n; a)) 0 b) = R 0 n a b	";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "1 goal (ID 1190)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  forall (u1 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))	  (u2 : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),	  apD G2 r @ u2 =	  (ap (transport (fun x : Y x2 => Z (x2; x)) r) u1 @ Epsilon p theta (G1 y1)) @	  ap (transport Z (Delta p psi y2)) (apD G1 q) ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) q	    u1 = u2	";
            responses[i]=data;
          

            i = 349;
            data = "";
            responses[i]=data;
          

            i = 350;
            data = "1 goal (ID 1215)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  apD G2 (ap F 1) @ u2 = u1 ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) 1	    u1 = u2	";
            responses[i]=data;
          

            i = 351;
            data = "1 goal (ID 1222)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  1 @ u2 = u1 -> u1 = u2	";
            responses[i]=data;
          

            i = 352;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "1 goal (ID 1223)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall y : fib_seq_to_type_fam B (inj A n.+1 (a) ^+),	  F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) y) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) y)	    (F n.+1 (a) ^+ y)	";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "2 goals (ID 1241)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w)) (inj (fib_seq_to_seq B (n.+1; (a) ^+)) i x)		goal 2 (ID 1243) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   (?q j (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 361;
            data = "1 goal (ID 1241)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w)) (inj (fib_seq_to_seq B (n.+1; (a) ^+)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1243) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   ((fun (k : Graph.graph0 sequence_graph)	       (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) j	      (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) =	 (fun (k : Graph.graph0 sequence_graph)	    (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) i x	";
            responses[i]=data;
          

            i = 362;
            data = "1 goal (ID 1243)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  transport	    (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp i j g x)	    ((fun (k : Graph.graph0 sequence_graph)	        (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) j	       (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) =	  (fun (k : Graph.graph0 sequence_graph)	     (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) i x	1 goal (ID 1255)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  transport	    (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp k k.+1 1 b) 1 = 1	";
            responses[i]=data;
          

            i = 363;
            data = "1 goal (ID 1354)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  apD (F n a) (colimp k.+1 k.+2 1 b) @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (glue A n a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (glue A n a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	";
            responses[i]=data;
          

            i = 364;
            data = "";
            responses[i]=data;
          

            i = 365;
            data = "1 goal (ID 1368)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	1 goal (ID 1403)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (R k n.+1 (a) ^+ b)	";
            responses[i]=data;
          

            i = 366;
            data = "";
            responses[i]=data;
          

            i = 367;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "";
            responses[i]=data;
          

            i = 370;
            data = "1 goal (ID 1284)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  psi : coe (ap Y p) = F	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : (fun x2 : X => idmap (Y x2)) x2, Z (x2; y)	  ============================	  transport	    (fun x : X => forall y : (fun x3 : X => idmap (Y x3)) x, Z (x; y)) p G1 =	  G2 <~> (forall y : Y x1, G2 (F y) = transport Z (Delta p psi y) (G1 y))	1 goal (ID 1301)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1 : X	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : Y x1, Z (x1; y)	  ============================	  transport (fun x : X => forall y : Y x, Z (x; y)) 1 G1 = G2 <~>	  (forall y : Y x1, G2 (coe (ap Y 1) y) = transport Z (Delta 1 1 y) (G1 y))	";
            responses[i]=data;
          

            i = 371;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 372;
            data = "";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "";
            responses[i]=data;
          

            i = 377;
            data = "1 goal (ID 1292)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (x : Colimit A) (y : fib_seq_to_type_fam B x), E (x; y)	";
            responses[i]=data;
          

            i = 378;
            data = "";
            responses[i]=data;
          

            i = 379;
            data = "1 goal (ID 1310)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport	    (fun w : Colimit A => forall y : fib_seq_to_type_fam B w, E (w; y))	    (colimp n n.+1 1 a) (F n.+1 (a) ^+) = F n a	";
            responses[i]=data;
          

            i = 380;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "1 goal (ID 1319)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  I (fib_seq_to_type_fam_beta_glue B n a)	    (apD seq_colim_sum_ind_cur (glue A n a)) = G n a	";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "";
            responses[i]=data;
          

            i = 392;
            data = "";
            responses[i]=data;
          

            i = 393;
            data = "";
            responses[i]=data;
          

            i = 394;
            data = "1 goal (ID 1321)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall x : {x : _ & fib_seq_to_type_fam B x}, E x	";
            responses[i]=data;
          

            i = 395;
            data = "";
            responses[i]=data;
          

            i = 396;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 397;
            data = "";
            responses[i]=data;
          

            i = 398;
            data = "1 goal (ID 1437)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  apD (G o exist Y x) p =	  (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta theta (G z)) @ apD G q2	";
            responses[i]=data;
          

            i = 399;
            data = "";
            responses[i]=data;
          

            i = 400;
            data = "1 goal (ID 1468)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  ============================	  forall x0 : q1 @ ap (exist Y x) p = q2,	  (fun y : q2 = q1 @ ap (exist Y x) p =>	   apD (G o exist Y x) p =	   (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta y (G z)) @ apD G q2)	    (equiv_path_inverse (q1 @ ap (exist Y x) p) q2 x0)	";
            responses[i]=data;
          

            i = 401;
            data = "1 goal (ID 1473)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p) (apD G q1)^ @	   Eta (equiv_path_inverse (q1 @ ap (exist Y x) p) (q1 @ ap (exist Y x) p) 1)	     (G z)) @ apD G (q1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 402;
            data = "1 goal (ID 1509)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  p : y1 = y2	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p)	     (apD G (equiv_path_inverse (x; y1) (x; y1) 1))^ @	   Eta	     (equiv_path_inverse	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p) 1)	     (G (x; y1))) @	  apD G (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 403;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 404;
            data = "";
            responses[i]=data;
          

            i = 405;
            data = "1 goal (ID 1515)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  G : forall z : {x2 : X & idmap (Y x2)}, Z z	  psi : coe (ap Y p) = F	  q : forall y : Y x1,	      (fun y0 : (fun x2 : X => idmap (Y x2)) x2 => G (x2; y0)) (F y) =	      transport Z (Delta p psi y)	        ((fun y0 : (fun x2 : X => idmap (Y x2)) x1 => G (x1; y0)) y)	  theta : I psi	            (apD	               (fun (x : X) (y : (fun x2 : X => idmap (Y x2)) x) => G (x; y))	               p) = q	  y : Y x1	  ============================	  apD G (Delta p psi y) = (q y)^	";
            responses[i]=data;
          

            i = 406;
            data = "";
            responses[i]=data;
          

            i = 407;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 408;
            data = "";
            responses[i]=data;
          

            i = 409;
            data = "";
            responses[i]=data;
          

            i = 410;
            data = "";
            responses[i]=data;
          

            i = 411;
            data = "";
            responses[i]=data;
          

            i = 412;
            data = "";
            responses[i]=data;
          

            i = 413;
            data = "1 goal (ID 1537)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "1 goal (ID 1541)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h := F_beta_glue n a b	   : apD (F n a) (glue (fib_seq_to_seq B (n; a)) 0 b) = R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 416;
            data = "1 goal (ID 1555)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         (apD seq_colim_sum_ind	            (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	               (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+)))^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "";
            responses[i]=data;
          

            i = 419;
            data = "1 goal (ID 1582)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         ((G n a (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+))^)^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	No more goals.	";
            responses[i]=data;
          

            i = 420;
            data = "";
            responses[i]=data;
          

            i = 421;
            data = "";
            responses[i]=data;
          

            i = 422;
            data = "";
            responses[i]=data;
          

            i = 423;
            data = "";
            responses[i]=data;
          

            i = 424;
            data = "";
            responses[i]=data;
          

            i = 425;
            data = "";
            responses[i]=data;
          

            i = 426;
            data = "";
            responses[i]=data;
          

            i = 427;
            data = "";
            responses[i]=data;
          

            i = 428;
            data = "";
            responses[i]=data;
          

            i = 429;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>E is declared</infomsg>	<infomsg>e is declared</infomsg>	<infomsg>t is declared</infomsg>	1 goal (ID 760)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> E	";
            responses[i]=data;
          

            i = 430;
            data = "";
            responses[i]=data;
          

            i = 431;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 432;
            data = "";
            responses[i]=data;
          

            i = 433;
            data = "1 goal (ID 785)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : (fun a0 : A n => B (n; a0)) a),	  ap seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 434;
            data = "";
            responses[i]=data;
          

            i = 435;
            data = "1 goal (ID 815)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  apD seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  transport_const	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (seq_colim_sum_rec	       (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n.+1 ((a; b)) ^+))) @	  t n a b	";
            responses[i]=data;
          

            i = 436;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 437;
            data = "";
            responses[i]=data;
          

            i = 438;
            data = "";
            responses[i]=data;
          

            i = 439;
            data = "";
            responses[i]=data;
          

            i = 440;
            data = "";
            responses[i]=data;
          

            i = 441;
            data = "";
            responses[i]=data;
          

            i = 442;
            data = "";
            responses[i]=data;
          

            i = 443;
            data = "1 goal (ID 766)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  ============================	  F o seq_colim_sum_to_sum_seq_colim B ==	  G o seq_colim_sum_to_sum_seq_colim B -> F == G	";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "1 goal (ID 790)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  h : F o seq_colim_sum_to_sum_seq_colim B ==	      G o seq_colim_sum_to_sum_seq_colim B	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  transport (fun x : {x : _ & fib_seq_to_type_fam B x} => F x = G x)	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    ((fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	        (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	      h (inj (sig_seq B) n0 (a0; b0))) n.+1 (a) ^+ 	       (b) ^+f) =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	     (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	   h (inj (sig_seq B) n0 (a0; b0))) n a b	";
            responses[i]=data;
          

            i = 446;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 447;
            data = "";
            responses[i]=data;
          

            i = 448;
            data = "";
            responses[i]=data;
          

            i = 449;
            data = "";
            responses[i]=data;
          

            i = 450;
            data = "";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "1 goal (ID 775)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "2 goals (ID 799)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap}		goal 2 (ID 800) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 455;
            data = "1 goal (ID 799)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap}	2 goals (ID 805)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B)		goal 2 (ID 807) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap) ?proj1	";
            responses[i]=data;
          

            i = 456;
            data = "1 goal (ID 805)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B)	2 goals (ID 835)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) -> Colimit (sig_seq B)		goal 2 (ID 837) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)), ?e n.+1 (a) ^+ (b) ^+f = ?e n a b	";
            responses[i]=data;
          

            i = 457;
            data = "1 goal (ID 835)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) -> Colimit (sig_seq B)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 837) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)),	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n a b	goal 2 (ID 807) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap)	   (seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b)) ?t)	goal 3 (ID 800) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 458;
            data = "1 goal (ID 837)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n a b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 807) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap)	   (seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       glue (sig_seq B) n (a; b)))	goal 2 (ID 800) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 459;
            data = "1 goal (ID 807)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	   (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	   idmap)	    (seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        inj (sig_seq B) n (a; b))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        glue (sig_seq B) n (a; b)))	2 goals (ID 888)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B (Colimit (sig_seq B))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n		goal 2 (ID 890) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 460;
            data = "1 goal (ID 888)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B (Colimit (sig_seq B))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 890) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap idmap (glue (sig_seq B) n a)	goal 2 (ID 800) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 461;
            data = "1 goal (ID 890)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap	    (fun x : Colimit (sig_seq B) =>	     seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap idmap (glue (sig_seq B) n a)	1 goal (ID 921)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : sig_seq B n	  ============================	  ap	    (seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => colimp n0 n0.+1 1 (a0; b)))	    (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 a)) =	  colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 462;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 800) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 463;
            data = "1 goal (ID 800)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	      G o seq_colim_sum_to_sum_seq_colim B == idmap}	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	1 goal (ID 981)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	      G o seq_colim_sum_to_sum_seq_colim B == idmap}	  ============================	  (fun x : {x : _ & fib_seq_to_type_fam B x} =>	   seq_colim_sum_to_sum_seq_colim B (L.1 x))	  o seq_colim_sum_to_sum_seq_colim B ==	  idmap o seq_colim_sum_to_sum_seq_colim B	";
            responses[i]=data;
          

            i = 464;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 465;
            data = "";
            responses[i]=data;
          

            i = 466;
            data = "<infomsg>equiv_seq_colim_sum_to_sum_seq_colim is defined</infomsg>	";
            responses[i]=data;
          

            i = 467;
            data = "";
            responses[i]=data;
          

            i = 468;
            data = "";
            responses[i]=data;
          

            i = 469;
            data = "";
            responses[i]=data;
          

            i = 470;
            data = "";
            responses[i]=data;
          

            i = 471;
            data = "1 goal (ID 811)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  pr1 o seq_colim_sum_to_sum_seq_colim B == seq_colim_sum_to_seq_colim_fst B	";
            responses[i]=data;
          

            i = 472;
            data = "";
            responses[i]=data;
          

            i = 473;
            data = "2 goals (ID 845)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n		goal 2 (ID 847) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 474;
            data = "1 goal (ID 845)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 847) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 475;
            data = "1 goal (ID 847)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	1 goal (ID 884)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap pr1	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	           (inj A n0 X.1; inj (fib_seq_to_seq B (n0; X.1)) 0 X.2);	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (x : sig_seq B n0) =>	           match	             p as p0 in (_ = y)	             return	               ((inj A y (((sig_seq B) _f p0) (x.1; x.2)).1;	                inj	                  (fib_seq_to_seq B (y; (((sig_seq B) _f p0) (x.1; x.2)).1))	                  0 (((sig_seq B) _f p0) (x.1; x.2)).2) =	                (inj A n0 x.1; inj (fib_seq_to_seq B (n0; x.1)) 0 x.2))	           with	           | 1 =>	               Delta (colimp n0 n0.+1 1 x.1)	                 (fib_seq_to_type_fam_beta_glue B n0 x.1)	                 (inj (fib_seq_to_seq B (n0.+1; ((x.1; x.2)) ^+.1)) 0	                    ((x.1; x.2)) ^+.2) @	               ap (exist (fib_seq_to_type_fam B) (inj A n0 x.1))	                 (colimp 0 1 1 x.2)	           end	       |} n n.+1 1 (a; b)) =	  legs_comm	    {|	      legs :=	        fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	        inj A n0 X.1;	      legs_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (x : sig_seq B n0) =>	        match	          p as p0 in (_ = y)	          return (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 = inj A n0 x.1)	        with	        | 1 => colimp n0 n0.+1 1 x.1	        end	    |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 476;
            data = "1 goal (ID 903)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  colimp n n.+1 1 a @	  ap pr1 (ap (exist (fib_seq_to_type_fam B) (inj A n a)) (colimp 0 1 1 b)) =	  legs_comm	    {|	      legs :=	        fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	        inj A n0 X.1;	      legs_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (x : sig_seq B n0) =>	        match	          p as p0 in (_ = y)	          return (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 = inj A n0 x.1)	        with	        | 1 => colimp n0 n0.+1 1 x.1	        end	    |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 477;
            data = "1 goal (ID 962)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap (fun _ : Colimit (fib_seq_to_seq B (n; a)) => inj A n a)	    (colimp 0 1 1 b) = 1	";
            responses[i]=data;
          

            i = 478;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 479;
            data = "";
            responses[i]=data;
          

            i = 480;
            data = "";
            responses[i]=data;
          

            i = 481;
            data = "";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "";
            responses[i]=data;
          

            i = 484;
            data = "<infomsg>path_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 485;
            data = "1 goal (ID 841)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 486;
            data = "";
            responses[i]=data;
          

            i = 487;
            data = "1 goal (ID 866)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 488;
            data = "2 goals (ID 879)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)		goal 2 (ID 880) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 489;
            data = "1 goal (ID 879)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)	2 goals (ID 941)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)		goal 2 (ID 943) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	";
            responses[i]=data;
          

            i = 490;
            data = "1 goal (ID 941)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 943) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	goal 2 (ID 880) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 491;
            data = "1 goal (ID 943)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  Contr {y : Colimit A & fib_seq_to_type_fam B y}	1 goal (ID 978)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  Contr (Colimit (sig_seq B))	";
            responses[i]=data;
          

            i = 492;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 880) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 493;
            data = "1 goal (ID 880)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	1 goal (ID 1146)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_seq' B (0; a2) ~d~ path_seq A a1 a2	";
            responses[i]=data;
          

            i = 494;
            data = "2 goals (ID 1171)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)		goal 2 (ID 1173) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 495;
            data = "1 goal (ID 1171)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)	2 goals (ID 1268)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i		goal 2 (ID 1270) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((fib_seq_to_seq' B (0; a2)) _f g) x)	";
            responses[i]=data;
          

            i = 496;
            data = "1 goal (ID 1268)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 1270) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	 (fun n : Graph.graph0 sequence_graph =>	  coe (ap B (seq_shift_pair_from_zero a2 n))) j	   (((fib_seq_to_seq' B (0; a2)) _f g) x)	goal 2 (ID 1173) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        coe (ap B (seq_shift_pair_from_zero a2 n));	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 497;
            data = "1 goal (ID 1270)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	  ((path_seq A a1 a2) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	  (fun n : Graph.graph0 sequence_graph =>	   coe (ap B (seq_shift_pair_from_zero a2 n))) j	    (((fib_seq_to_seq' B (0; a2)) _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 1173) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        coe (ap B (seq_shift_pair_from_zero a2 n));	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m)	          (b : fib_seq_to_seq' B (0; a2) n) =>	        match	          p as p0 in (_ = y)	          return	            (((path_seq A a1 a2) _f p0)	               (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	             coe (ap B (seq_shift_pair_from_zero a2 y))	               (((fib_seq_to_seq' B (0; a2)) _f p0) b))	        with	        | 1 =>	            K seq_pair_shift (fibSequenceArr B)	              (seq_shift_pair_from_zero a2 n)	        end	    |} i)	";
            responses[i]=data;
          

            i = 498;
            data = "1 goal (ID 1173)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         coe (ap B (seq_shift_pair_from_zero a2 n));	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m)	           (b : fib_seq_to_seq' B (0; a2) n) =>	         match	           p as p0 in (_ = y)	           return	             (((path_seq A a1 a2) _f p0)	                (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	              coe (ap B (seq_shift_pair_from_zero a2 y))	                (((fib_seq_to_seq' B (0; a2)) _f p0) b))	         with	         | 1 =>	             K seq_pair_shift (fibSequenceArr B)	               (seq_shift_pair_from_zero a2 n)	         end	     |} i)	No more goals.	";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "";
            responses[i]=data;
          

            i = 501;
            data = "";
            responses[i]=data;
          

            i = 502;
            data = "";
            responses[i]=data;
          

            i = 503;
            data = "";
            responses[i]=data;
          

            i = 504;
            data = "1 goal (ID 851)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj A n a1 = inj A n a2 <~> Colimit (path_seq (shift_seq A n) a1 a2)	";
            responses[i]=data;
          

            i = 505;
            data = "";
            responses[i]=data;
          

            i = 506;
            data = "1 goal (ID 875)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj (shift_seq A n) 0 a1 = inj (shift_seq A n) 0 a2 <~>	  inj A n a1 = inj A n a2	";
            responses[i]=data;
          

            i = 507;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 508;
            data = "";
            responses[i]=data;
          

            i = 509;
            data = "";
            responses[i]=data;
          

            i = 510;
            data = "";
            responses[i]=data;
          

            i = 511;
            data = "";
            responses[i]=data;
          

            i = 512;
            data = "";
            responses[i]=data;
          

            i = 513;
            data = "";
            responses[i]=data;
          

            i = 514;
            data = "1 goal (ID 858)	  	  H : Univalence	  A : Sequence	  k : trunc_index	  ============================	  (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	  IsTrunc k (Colimit A)	";
            responses[i]=data;
          

            i = 515;
            data = "";
            responses[i]=data;
          

            i = 516;
            data = "2 goals (ID 864)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)		goal 2 (ID 867) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 517;
            data = "1 goal (ID 864)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 867) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 518;
            data = "1 goal (ID 867)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  IsTrunc k.+1 (Colimit A)	2 goals (ID 899)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)		goal 2 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x) (?q j ((A _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 519;
            data = "1 goal (ID 899)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)	2 goals (ID 910)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)		goal 2 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	";
            responses[i]=data;
          

            i = 520;
            data = "1 goal (ID 910)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)	2 goals (ID 934)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)		goal 2 (ID 936) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x) 	   (?q j ((A _f g) x)) = ?q i x	";
            responses[i]=data;
          

            i = 521;
            data = "1 goal (ID 934)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)	2 goals (ID 950)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)		goal 2 (ID 953) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 522;
            data = "1 goal (ID 950)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	1 goal (ID 957)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a, b : A 0%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	";
            responses[i]=data;
          

            i = 523;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 953) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	goal 2 (ID 936) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) =>	        ?Goal0@{m:=m0}) m A trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) => 	     ?Goal0@{m:=m0}) m A trH a b) i x	goal 3 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 4 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	              ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	           ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 524;
            data = "1 goal (ID 953)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 goal (ID 953)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 goal (ID 984)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 525;
            data = "1 goal (ID 1001)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  IsTrunc k (inj A 1%nat (a) ^+ = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 526;
            data = "1 goal (ID 1142)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  inj (succ_seq A) 0%nat (a) ^+ = inj (succ_seq A) m b <~>	  inj A 1%nat (a) ^+ = inj A (m.+1)%nat b	";
            responses[i]=data;
          

            i = 527;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 936) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	goal 2 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 3 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 528;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 936) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	goal 2 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 3 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 goal (ID 936)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	1 goal (ID 936)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 2 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 913) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 2 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 goal (ID 913)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  ============================	  forall A : Sequence,	  (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	  forall (x : A (n.+1)%nat) (y : Colimit A),	  (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	     match n0 with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A (n.+1)%nat x = y)	1 goal (ID 1218)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A (n.+1)%nat	  ============================	  forall a0 : Colimit (succ_seq A),	  (fun b : Colimit A =>	   (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	      match n0 with	      | -2 => Contr_internal A0	      | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	      end) k (inj A (n.+1)%nat a = b)) (colim_succ_seq_to_colim_seq A a0)	";
            responses[i]=data;
          

            i = 529;
            data = "";
            responses[i]=data;
          

            i = 530;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 901) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	          (trH0 : forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	        functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	          (fun x0 : Colimit (succ_seq A0) =>	           trunc_equiv' (inj (succ_seq A0) n0 a = x0)	             (equiv_ap (colim_succ_seq_to_colim_seq A0)	                (inj (succ_seq A0) n0 a) x0))) n A trH) j 	      ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	       (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	       (a : A0 (n0.+1)%nat) =>	     functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	       (fun x0 : Colimit (succ_seq A0) =>	        trunc_equiv' (inj (succ_seq A0) n0 a = x0)	          (equiv_ap (colim_succ_seq_to_colim_seq A0) 	             (inj (succ_seq A0) n0 a) x0))) n A trH) i x	1 goal (ID 901)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     forall y : Colimit A,	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	        end) k (w = y)) (colimp i j g x)	    ((fun n : Graph.graph0 sequence_graph =>	      nat_rect	        (fun n0 : nat =>	         forall A0 : Sequence,	         (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	         forall (x0 : A0 n0) (y : Colimit A0),	         (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	              Type :=	            match n1 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	            end) k (inj A0 n0 x0 = y))	        (fun (A0 : Sequence)	           (trH0 : forall n0 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	         Colimit_ind	           (fun w : Colimit A0 =>	            (fix IsTrunc_internal	               (n0 : trunc_index) (A1 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A1	               | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	               end) k (inj A0 0%nat a = w))	           (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	            nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                  match n0 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	               trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n0 : trunc_index) (A2 : Type) {struct n0} :	                             Type :=	                           match n0 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              m A0 trH0 a b)	           (fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) 	              (b : A0 n0) =>	            path_ishprop	              (transport	                 (fun w : Colimit A0 =>	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a = w)) 	                 (colimp n0 m p b)	                 ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                   nat_rect	                     (fun m1 : nat =>	                      forall A1 : Sequence,	                      (forall n1 : Graph.graph0 sequence_graph,	                       IsTrunc k.+1 (A1 n1)) ->	                      forall (a0 : A1 0%nat) (b1 : A1 m1),	                      (fix IsTrunc_internal	                         (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                         match n1 with	                         | -2 => Contr_internal A2	                         | n'.+1 =>	                             forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                         end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (fun (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 b1 : A1 0%nat) =>	                      trunc_equiv'	                        (Colimit (path_seq (shift_seq A1 0) a0 b1))	                        (equiv_path_colim 0%nat a0 b1)^-1)	                     (fun (m1 : nat)	                        (IHm : forall A1 : Sequence,	                               (forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) ->	                               forall (a0 : A1 0%nat) 	                               (b1 : A1 m1),	                               (fix IsTrunc_internal	                                  (n1 : trunc_index) (A2 : Type) {struct n1} :	                                    Type :=	                                  match n1 with	                                  | -2 => Contr_internal A2	                                  | n'.+1 =>	                                      forall x0 y : A2,	                                      IsTrunc_internal n' (x0 = y)	                                  end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                        (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                      trunc_equiv'	                        (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                        (equiv_concat_l (glue A1 0%nat a0)	                           (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                    ((A0 _f p) b)))	              (nat_rect	                 (fun m0 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b0 : A1 m0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b0 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                    (equiv_path_colim 0%nat a0 b0)^-1)	                 (fun (m0 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b0 : A1 m0),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b0 : A1 (m0.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m0.+1)%nat b0))^-1) n0 A0 trH0 a b)))	        (fun (n0 : nat)	           (IHn : forall A0 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) ->	                  forall (x0 : A0 n0) (y : Colimit A0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                     end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	           (trH0 : forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	         functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	           (fun x0 : Colimit (succ_seq A0) =>	            trunc_equiv' (inj (succ_seq A0) n0 a = x0)	              (equiv_ap (colim_succ_seq_to_colim_seq A0)	                 (inj (succ_seq A0) n0 a) x0))) n A trH) j 	       ((A _f g) x)) =	  (fun n : Graph.graph0 sequence_graph =>	   nat_rect	     (fun n0 : nat =>	      forall A0 : Sequence,	      (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	      forall (x0 : A0 n0) (y : Colimit A0),	      (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	           Type :=	         match n1 with	         | -2 => Contr_internal A1	         | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	         end) k (inj A0 n0 x0 = y))	     (fun (A0 : Sequence)	        (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	        (a : A0 0%nat) =>	      Colimit_ind	        (fun w : Colimit A0 =>	         (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	              Type :=	            match n0 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a = w))	        (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	         nat_rect	           (fun m0 : nat =>	            forall A1 : Sequence,	            (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	            forall (a0 : A1 0%nat) (b0 : A1 m0),	            (fix IsTrunc_internal	               (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A2	               | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	               end) k (inj A1 0%nat a0 = inj A1 m0 b0))	           (fun (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	            trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	              (equiv_path_colim 0%nat a0 b0)^-1)	           (fun (m0 : nat)	              (IHm : forall A1 : Sequence,	                     (forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) ->	                     forall (a0 : A1 0%nat) (b0 : A1 m0),	                     (fix IsTrunc_internal	                        (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                        match n0 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	              (b0 : A1 (m0.+1)%nat) =>	            trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	              (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	           m A0 trH0 a b)	        (fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) 	           (b : A0 n0) =>	         path_ishprop	           (transport	              (fun w : Colimit A0 =>	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	              ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                nat_rect	                  (fun m1 : nat =>	                   forall A1 : Sequence,	                   (forall n1 : Graph.graph0 sequence_graph,	                    IsTrunc k.+1 (A1 n1)) ->	                   forall (a0 : A1 0%nat) (b1 : A1 m1),	                   (fix IsTrunc_internal	                      (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                      match n1 with	                      | -2 => Contr_internal A2	                      | n'.+1 =>	                          forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                      end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                  (fun (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 b1 : A1 0%nat) =>	                   trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                     (equiv_path_colim 0%nat a0 b1)^-1)	                  (fun (m1 : nat)	                     (IHm : forall A1 : Sequence,	                            (forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) ->	                            forall (a0 : A1 0%nat) 	                            (b1 : A1 m1),	                            (fix IsTrunc_internal	                               (n1 : trunc_index) (A2 : Type) {struct n1} :	                                 Type :=	                               match n1 with	                               | -2 => Contr_internal A2	                               | n'.+1 =>	                                   forall x0 y : A2,	                                   IsTrunc_internal n' (x0 = y)	                               end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                   trunc_equiv'	                     (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                     (equiv_concat_l (glue A1 0%nat a0)	                        (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                 ((A0 _f p) b)))	           (nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	               trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n1 : trunc_index) (A2 : Type) {struct n1} :	                             Type :=	                           match n1 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              n0 A0 trH0 a b)))	     (fun (n0 : nat)	        (IHn : forall A0 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	               forall (x0 : A0 n0) (y : Colimit A0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                  end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	        (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	        (a : A0 (n0.+1)%nat) =>	      functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	        (fun x0 : Colimit (succ_seq A0) =>	         trunc_equiv' (inj (succ_seq A0) n0 a = x0)	           (equiv_ap (colim_succ_seq_to_colim_seq A0)	              (inj (succ_seq A0) n0 a) x0))) n A trH) i x	2 goals (ID 1478)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  Funext		goal 2 (ID 1482) is:	 forall a0 : Colimit A,	 IsHProp	   ((fun a1 : Colimit A =>	     (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	          Type :=	        match n0 with	        | -2 => Contr_internal A0	        | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	        end) k (inj A n a = a1)) a0)	";
            responses[i]=data;
          

            i = 531;
            data = "1 goal (ID 1478)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  Funext	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1482) is:	 forall a0 : Colimit A,	 IsHProp	   ((fun a1 : Colimit A =>	     (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	          Type :=	        match n0 with	        | -2 => Contr_internal A0	        | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	        end) k (inj A n a = a1)) a0)	1 goal (ID 1482)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  forall a0 : Colimit A,	  IsHProp	    ((fun a1 : Colimit A =>	      (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	           Type :=	         match n0 with	         | -2 => Contr_internal A0	         | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	         end) k (inj A n a = a1)) a0)	1 goal (ID 1482)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  forall a0 : Colimit A,	  IsHProp	    ((fun a1 : Colimit A =>	      (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	           Type :=	         match n0 with	         | -2 => Contr_internal A0	         | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	         end) k (inj A n a = a1)) a0)	No more goals.	No more goals.	";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Colimits.Sequential</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
We present a proof of the conjecture that sequential colimits in HoTT apropriately commute with Σ-types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(10, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(11, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(12, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#"><span class="id" title="library">Diagrams.Diagram</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#"><span class="id" title="library">Diagrams.Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#"><span class="id" title="library">Diagrams.Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.Nat.html#"><span class="id" title="library">Spaces.Nat</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.PathAny.html#"><span class="id" title="library">PathAny</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="coe" class="idref" href="#coe"><span class="id" title="abbreviation">coe</span></a> := (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="08eb96ff0845089548bf8ee31b997ae3" class="idref" href="#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">"</span></a>a ^+" := (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1 <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_from_zero_by" class="idref" href="#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> {<a id="A:1" class="idref" href="#A:1"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:2" class="idref" href="#a:2"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:1"><span class="id" title="variable">A</span></a> 0) <a id="k:3" class="idref" href="#k:3"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:1"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:3"><span class="id" title="variable">k</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="89dcb9d9e23f2b78dc8a1b1571e3a602" class="idref" href="#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">"</span></a>a ^+ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> <span class="id" title="var">a</span> <span class="id" title="var">k</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Shiftings; described in the paragraph after Lemma 3.7. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(33, '0_3_11');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift" class="idref" href="#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> {<a id="A:4" class="idref" href="#A:4"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:5" class="idref" href="#x:5"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:4"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:4"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(34, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">a</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_by" class="idref" href="#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> {<a id="A:6" class="idref" href="#A:6"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:7" class="idref" href="#x:7"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:6"><span class="id" title="variable">A</span></a>) (<a id="k:8" class="idref" href="#k:8"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:6"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(38, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(39, '0_3_11');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(40, '0_3_11');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(41, '0_3_11');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(42, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="18b94a88d8c66f36461830ed891d1ead" class="idref" href="#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">"</span></a>x ^++" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="9bb4541bd65c2f34599b9513bda9dddb" class="idref" href="#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">"</span></a>x ^++ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> <span class="id" title="var">x</span> <span class="id" title="var">k</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_assoc" class="idref" href="#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> {<a id="A:9" class="idref" href="#A:9"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:10" class="idref" href="#x:10"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:9"><span class="id" title="variable">A</span></a>) (<a id="k:11" class="idref" href="#k:11"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:10"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:11"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:10"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:11"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_pair_from_zero" class="idref" href="#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> {<a id="A:12" class="idref" href="#A:12"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:13" class="idref" href="#a:13"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:12"><span class="id" title="variable">A</span></a> 0) <a id="k:14" class="idref" href="#k:14"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:13"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:13"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="inj" class="idref" href="#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> := (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colim"><span class="id" title="constructor">colim</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="glue" class="idref" href="#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> := (<span class="id" title="keyword">fun</span> <a id="n:15" class="idref" href="#n:15"><span class="id" title="binder">n</span></a> ⇒ @<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:15"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:15"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The uniqueness principle for sequential colimits; Lemma 3.3. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(63, '0_3_15');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_uniq" class="idref" href="#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a> {<a id="A:16" class="idref" href="#A:16"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="E:17" class="idref" href="#E:17"><span class="id" title="binder">E</span></a> (<a id="F:18" class="idref" href="#F:18"><span class="id" title="binder">F</span></a> <a id="G:19" class="idref" href="#G:19"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:17"><span class="id" title="variable">E</span></a>)<br>
  (<a id="h:21" class="idref" href="#h:21"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:20" class="idref" href="#n:20"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:20"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:20"><span class="id" title="variable">n</span></a>)<br>
  (<a id="H:24" class="idref" href="#H:24"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:22" class="idref" href="#n:22"><span class="id" title="binder">n</span></a> <a id="a:23" class="idref" href="#a:23"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:21"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:21"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a>))<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(64, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(65, '0_3_15');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">h</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(66, '0_3_15');
      "><br>
  <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">generalize</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(67, '0_3_15');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(68, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(69, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
The successor sequence from Lemma 3.6. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(73, '0_3_19');
      ">
<span class="id" title="keyword">Definition</span> <a id="succ_seq" class="idref" href="#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a id="A:25" class="idref" href="#A:25"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:26" class="idref" href="#k:26"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#A:25"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:26"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:27" class="idref" href="#k:27"><span class="id" title="binder">k</span></a> <a id="a:28" class="idref" href="#a:28"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:28"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(74, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
The shifted sequence from Lemma 3.7. 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(78, '0_3_23');
      ">
<span class="id" title="keyword">Definition</span> <a id="shift_seq" class="idref" href="#shift_seq"><span class="id" title="definition">shift_seq</span></a> (<a id="A:29" class="idref" href="#A:29"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) <a id="n:30" class="idref" href="#n:30"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:31" class="idref" href="#k:31"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#A:29"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:31"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:30"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) (<span class="id" title="keyword">fun</span> <a id="k:32" class="idref" href="#k:32"><span class="id" title="binder">k</span></a> <a id="a:33" class="idref" href="#a:33"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:33"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(79, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
The canonical equivalence between the colimit of the succesor sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq" class="idref" href="#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a id="A:34" class="idref" href="#A:34"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:34"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:34"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
  + <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:37" class="idref" href="#n:37"><span class="id" title="binder">n</span></a> <a id="a:38" class="idref" href="#a:38"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:35"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:36"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
  + <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(89, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_beta_glue" class="idref" href="#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <a id="A:39" class="idref" href="#A:39"><span class="id" title="binder">A</span></a> <a id="n:40" class="idref" href="#n:40"><span class="id" title="binder">n</span></a> <a id="a:41" class="idref" href="#a:41"><span class="id" title="binder">a</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:40"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:41"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#n:40"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a:41"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(90, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(91, '0_3_27');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(92, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(93, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_ap_inj" class="idref" href="#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a> <a id="A:42" class="idref" href="#A:42"><span class="id" title="binder">A</span></a> <a id="n:43" class="idref" href="#n:43"><span class="id" title="binder">n</span></a> (<a id="a1:44" class="idref" href="#a1:44"><span class="id" title="binder">a1</span></a> <a id="a2:45" class="idref" href="#a2:45"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:42"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a>) (<a id="p:46" class="idref" href="#p:46"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:44"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:45"><span class="id" title="variable">a2</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:42"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:46"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:46"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(94, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(95, '0_3_27');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(96, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(97, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_succ_seq_to_colim_seq" class="idref" href="#isequiv_colim_succ_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:47"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(99, '0_3_27');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(100, '0_3_27');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(101, '0_3_27');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:50" class="idref" href="#n:50"><span class="id" title="binder">n</span></a> <a id="a:51" class="idref" href="#a:51"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:48"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:49"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(102, '0_3_27');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(103, '0_3_27');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(104, '0_3_27');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:54" class="idref" href="#n:54"><span class="id" title="binder">n</span></a> <a id="a:55" class="idref" href="#a:55"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:52"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:53"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(105, '0_3_27');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(106, '0_3_27');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(107, '0_3_27');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(108, '0_3_27');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:58" class="idref" href="#n:58"><span class="id" title="binder">n</span></a> <a id="a:59" class="idref" href="#a:59"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:56"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:57"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(109, '0_3_27');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(110, '0_3_27');
      "><br>
      <span class="id" title="tactic">rewrite</span> (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1); <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(111, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(112, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_succ_seq_to_colim_seq" class="idref" href="#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:60" class="idref" href="#A:60"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a><br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(113, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(117, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq" class="idref" href="#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a id="A:61" class="idref" href="#A:61"><span class="id" title="binder">A</span></a> <a id="n:62" class="idref" href="#n:62"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:61"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:62"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:61"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(118, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(119, '0_3_31');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(120, '0_3_31');
      "><br>
  + <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:65" class="idref" href="#k:65"><span class="id" title="binder">k</span></a> <a id="a:66" class="idref" href="#a:66"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:63"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:64"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(121, '0_3_31');
      "><br>
  + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">k</span><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(122, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(123, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_beta_glue" class="idref" href="#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a> <a id="A:67" class="idref" href="#A:67"><span class="id" title="binder">A</span></a> <a id="n:68" class="idref" href="#n:68"><span class="id" title="binder">n</span></a> <a id="k:69" class="idref" href="#k:69"><span class="id" title="binder">k</span></a> <a id="a:70" class="idref" href="#a:70"><span class="id" title="binder">a</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#k:69"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:70"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:69"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:70"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(124, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(125, '0_3_31');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(126, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(127, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_ap_inj" class="idref" href="#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a> <a id="A:71" class="idref" href="#A:71"><span class="id" title="binder">A</span></a> <a id="n:72" class="idref" href="#n:72"><span class="id" title="binder">n</span></a> <a id="k:73" class="idref" href="#k:73"><span class="id" title="binder">k</span></a> (<a id="a1:74" class="idref" href="#a1:74"><span class="id" title="binder">a1</span></a> <a id="a2:75" class="idref" href="#a2:75"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a>) (<a id="p:76" class="idref" href="#p:76"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:74"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:75"><span class="id" title="variable">a2</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:76"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:76"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(128, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(129, '0_3_31');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(130, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(131, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="J" class="idref" href="#J"><span class="id" title="definition">J</span></a> {<a id="X:77" class="idref" href="#X:77"><span class="id" title="binder">X</span></a> <a id="Y:78" class="idref" href="#Y:78"><span class="id" title="binder">Y</span></a> <a id="Z:79" class="idref" href="#Z:79"><span class="id" title="binder">Z</span></a>} {<a id="x1:80" class="idref" href="#x1:80"><span class="id" title="binder">x1</span></a> <a id="x2:81" class="idref" href="#x2:81"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:77"><span class="id" title="variable">X</span></a>} {<a id="y:82" class="idref" href="#y:82"><span class="id" title="binder">y</span></a>} {<a id="I:84" class="idref" href="#I:84"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:83" class="idref" href="#x:83"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:78"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:83"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:79"><span class="id" title="variable">Z</span></a>} (<a id="p:85" class="idref" href="#p:85"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:80"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:81"><span class="id" title="variable">x2</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#I:84"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:81"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:82"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:84"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:80"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:78"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:85"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:82"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(132, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(133, '0_3_31');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(134, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(135, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="K" class="idref" href="#K"><span class="id" title="definition">K</span></a> {<a id="X:86" class="idref" href="#X:86"><span class="id" title="binder">X</span></a> <a id="Y:87" class="idref" href="#Y:87"><span class="id" title="binder">Y</span></a>} {<a id="x1:88" class="idref" href="#x1:88"><span class="id" title="binder">x1</span></a> <a id="x2:89" class="idref" href="#x2:89"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:86"><span class="id" title="variable">X</span></a>} {<a id="y:90" class="idref" href="#y:90"><span class="id" title="binder">y</span></a>} <a id="F:91" class="idref" href="#F:91"><span class="id" title="binder">F</span></a> <a id="G:92" class="idref" href="#G:92"><span class="id" title="binder">G</span></a> (<a id="p:93" class="idref" href="#p:93"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:88"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:89"><span class="id" title="variable">x2</span></a>) :<br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#G:92"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:89"><span class="id" title="variable">x2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:87"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:93"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:90"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:87"><span class="id" title="variable">Y</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:91"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:93"><span class="id" title="variable">p</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:92"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:88"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:90"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(136, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(137, '0_3_31');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(138, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(139, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="L" class="idref" href="#L"><span class="id" title="definition">L</span></a> {<a id="X:94" class="idref" href="#X:94"><span class="id" title="binder">X</span></a> <a id="Y:95" class="idref" href="#Y:95"><span class="id" title="binder">Y</span></a> <a id="Z:96" class="idref" href="#Z:96"><span class="id" title="binder">Z</span></a>} {<a id="x1:97" class="idref" href="#x1:97"><span class="id" title="binder">x1</span></a> <a id="x2:98" class="idref" href="#x2:98"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:94"><span class="id" title="variable">X</span></a>} {<a id="y:99" class="idref" href="#y:99"><span class="id" title="binder">y</span></a>} {<a id="F:100" class="idref" href="#F:100"><span class="id" title="binder">F</span></a> <a id="G:101" class="idref" href="#G:101"><span class="id" title="binder">G</span></a>} {<a id="I:103" class="idref" href="#I:103"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:102" class="idref" href="#x:102"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:102"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:96"><span class="id" title="variable">Z</span></a>} {<a id="p:104" class="idref" href="#p:104"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a>}<br>
  (<a id="Q:107" class="idref" href="#Q:107"><span class="id" title="binder">Q</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:105" class="idref" href="#x:105"><span class="id" title="binder">x</span></a> <a id="y:106" class="idref" href="#y:106"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:106"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:106"><span class="id" title="variable">y</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#Q:107"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>))) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#Q:107"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(140, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(141, '0_3_31');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(142, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(143, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_shift_seq_to_colim_seq" class="idref" href="#isequiv_colim_shift_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:108" class="idref" href="#H:108"><span class="id" title="binder">Funext</span></a>} <a id="A:109" class="idref" href="#A:109"><span class="id" title="binder">A</span></a> <a id="n:110" class="idref" href="#n:110"><span class="id" title="binder">n</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:109"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:110"><span class="id" title="variable">n</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(144, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(145, '0_3_31');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>]; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_homotopic'"><span class="id" title="definition">isequiv_homotopic'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(146, '0_3_31');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(147, '0_3_31');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(148, '0_3_31');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:112" class="idref" href="#k:112"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:111"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(149, '0_3_31');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:115" class="idref" href="#n:115"><span class="id" title="binder">n</span></a> <a id="a:116" class="idref" href="#a:116"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:114"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(150, '0_3_31');
      "><br>
        <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(151, '0_3_31');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(152, '0_3_31');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(153, '0_3_31');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <span class="id" title="var">k</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(154, '0_3_31');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(155, '0_3_31');
      "><br>
  - <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(156, '0_3_31');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(157, '0_3_31');
      "><br>
      × <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(158, '0_3_31');
      "><br>
        { <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:118" class="idref" href="#k:118"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:117"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(159, '0_3_31');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:121" class="idref" href="#n:121"><span class="id" title="binder">n</span></a> <a id="a:122" class="idref" href="#a:122"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:120"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(160, '0_3_31');
      "><br>
          <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(161, '0_3_31');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(162, '0_3_31');
      "><br>
    + <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(163, '0_3_31');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(164, '0_3_31');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(165, '0_3_31');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(166, '0_3_31');
      "><br>
      <span class="id" title="tactic">rewrite</span> 2(<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose'"><span class="id" title="definition">ap_compose'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>)), <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>, 2<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(167, '0_3_31');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a>, <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(168, '0_3_31');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(169, '0_3_31');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(170, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(171, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_shift_seq_to_colim_seq" class="idref" href="#equiv_colim_shift_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:123" class="idref" href="#H:123"><span class="id" title="binder">Funext</span></a>} <a id="A:124" class="idref" href="#A:124"><span class="id" title="binder">A</span></a> <a id="n:125" class="idref" href="#n:125"><span class="id" title="binder">n</span></a><br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:125"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a><br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:125"><span class="id" title="variable">n</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(172, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
Corollary 7.7.1 for k := -2; implies Lemma 7.2. 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(176, '0_3_35');
      ">
<span class="id" title="keyword">Definition</span> <a id="contr_colim_contr_seq" class="idref" href="#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a> `{<a id="H:126" class="idref" href="#H:126"><span class="id" title="binder">Funext</span></a>} (<a id="A:127" class="idref" href="#A:127"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="k:128" class="idref" href="#k:128"><span class="id" title="binder">k</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:127"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:128"><span class="id" title="variable">k</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:127"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(177, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(178, '0_3_35');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">h_seqcontr</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">unit_seq</span> := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(179, '0_3_35');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <span class="id" title="var">unit_seq</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(180, '0_3_35');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(181, '0_3_35');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(182, '0_3_35');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(183, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(184, '0_3_35');
      "><br>
  - <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#Build_Contr"><span class="id" title="constructor">Build_Contr</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">unit_seq</span> 0 <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(185, '0_3_35');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(186, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">r</span>].</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(187, '0_3_35');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(188, '0_3_35');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">unit_seq</span> <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(189, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(190, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(191, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
Fibered sequences; Section 4. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      ">
<span class="id" title="keyword">Record</span> <a id="FibSequence" class="idref" href="#FibSequence"><span class="id" title="record">FibSequence</span></a> (<a id="A:129" class="idref" href="#A:129"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) := {<br>
  <a id="fibSequence" class="idref" href="#fibSequence"><span class="id" title="projection">fibSequence</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:129"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>;<br>
  <a id="fibSequenceArr" class="idref" href="#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <a id="x:132" class="idref" href="#x:132"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:131"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:132"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:131"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:132"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><br>
}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">:</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">Funclass</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
<br>
<span class="id" title="var">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
<span class="id" title="var">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="be7681fc4f0bf4f2eee9cf7f11f6ac16" class="idref" href="#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">"</span></a>b ^+f" := (<a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
The Sigma of a fibered type sequence; Definition 4.3. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(204, '0_3_43');
      ">
<span class="id" title="keyword">Definition</span> <a id="sig_seq" class="idref" href="#sig_seq"><span class="id" title="definition">sig_seq</span></a> {<a id="A:134" class="idref" href="#A:134"><span class="id" title="binder">A</span></a>} (<a id="B:135" class="idref" href="#B:135"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:134"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(205, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(206, '0_3_43');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(207, '0_3_43');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:138" class="idref" href="#n:138"><span class="id" title="binder">n</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a:139" class="idref" href="#a:139"><span class="id" title="binder">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:137"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(208, '0_3_43');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(209, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(210, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(214, '0_3_47');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_seq_colim_fst" class="idref" href="#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> {<a id="A:140" class="idref" href="#A:140"><span class="id" title="binder">A</span></a>} (<a id="B:141" class="idref" href="#B:141"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:140"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:141"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:140"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(215, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(216, '0_3_47');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(217, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">_</span>]; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(218, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(219, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(220, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
Given a sequence fibered over A, aach point x : sig A induces a new type sequence; Section 4. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(224, '0_3_51');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq" class="idref" href="#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> {<a id="A:142" class="idref" href="#A:142"><span class="id" title="binder">A</span></a>} (<a id="B:143" class="idref" href="#B:143"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:142"><span class="id" title="variable">A</span></a>) (<a id="x:144" class="idref" href="#x:144"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:142"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(225, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(226, '0_3_51');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(227, '0_3_51');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:146" class="idref" href="#x:146"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">B</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:145"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(228, '0_3_51');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:148" class="idref" href="#x:148"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:147"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(229, '0_3_51');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:151" class="idref" href="#x:151"><span class="id" title="binder">x</span></a> <a id="b:152" class="idref" href="#b:152"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#b:150"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(230, '0_3_51');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:154" class="idref" href="#x:154"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:153"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(231, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(232, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
The induced sequence can be equivalently described by using shifting; Lemma 7.1. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(236, '0_3_55');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq'" class="idref" href="#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> {<a id="A:155" class="idref" href="#A:155"><span class="id" title="binder">A</span></a>} (<a id="B:156" class="idref" href="#B:156"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:155"><span class="id" title="variable">A</span></a>) (<a id="x:157" class="idref" href="#x:157"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:155"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:158" class="idref" href="#k:158"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#B:156"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:157"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:158"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:159" class="idref" href="#k:159"><span class="id" title="binder">k</span></a> <a id="b:160" class="idref" href="#b:160"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#b:160"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(237, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_fib_seq_to_seq" class="idref" href="#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> {<a id="A:161" class="idref" href="#A:161"><span class="id" title="binder">A</span></a>} (<a id="B:162" class="idref" href="#B:162"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:161"><span class="id" title="variable">A</span></a>) (<a id="x:163" class="idref" href="#x:163"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:161"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:162"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:163"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">¬</span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">d</span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:162"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:163"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(238, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(239, '0_3_55');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(240, '0_3_55');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(241, '0_3_55');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(242, '0_3_55');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(243, '0_3_55');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:165" class="idref" href="#x:165"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:164"><span class="id" title="variable">x</span></a> <span class="id" title="var">n</span>)) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <span class="id" title="var">e</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:164"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(244, '0_3_55');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(245, '0_3_55');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(246, '0_3_55');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:168" class="idref" href="#x:168"><span class="id" title="binder">x</span></a> <a id="b:169" class="idref" href="#b:169"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">p</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#x:166"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#b:167"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(247, '0_3_55');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(248, '0_3_55');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_idmap"><span class="id" title="instance">isequiv_idmap</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(249, '0_3_55');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(250, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(251, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
A fibered type sequence defines a type family; Section 4. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(255, '0_3_59');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam" class="idref" href="#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> `{<a id="H:170" class="idref" href="#H:170"><span class="id" title="binder">Univalence</span></a>} {<a id="A:171" class="idref" href="#A:171"><span class="id" title="binder">A</span></a>} (<a id="B:172" class="idref" href="#B:172"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:171"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:171"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(256, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(257, '0_3_59');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(258, '0_3_59');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:175" class="idref" href="#n:175"><span class="id" title="binder">n</span></a> <a id="a:176" class="idref" href="#a:176"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:173"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:174"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(259, '0_3_59');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(260, '0_3_59');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(261, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(262, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam_beta_glue" class="idref" href="#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> `{<a id="H:177" class="idref" href="#H:177"><span class="id" title="binder">Univalence</span></a>} {<a id="A:178" class="idref" href="#A:178"><span class="id" title="binder">A</span></a>} <a id="B:179" class="idref" href="#B:179"><span class="id" title="binder">B</span></a> <a id="n:180" class="idref" href="#n:180"><span class="id" title="binder">n</span></a> <a id="a:181" class="idref" href="#a:181"><span class="id" title="binder">a</span></a> :<br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:179"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:178"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:180"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:181"><span class="id" title="variable">a</span></a>))<a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:179"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:180"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:181"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(263, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(264, '0_3_59');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(265, '0_3_59');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Universe.html#transport_idmap_path_universe_uncurried"><span class="id" title="definition">transport_idmap_path_universe_uncurried</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(266, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(267, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta" class="idref" href="#Delta"><span class="id" title="definition">Delta</span></a> {<a id="X:182" class="idref" href="#X:182"><span class="id" title="binder">X</span></a> <a id="Y:183" class="idref" href="#Y:183"><span class="id" title="binder">Y</span></a>} {<a id="x1:184" class="idref" href="#x1:184"><span class="id" title="binder">x1</span></a> <a id="x2:185" class="idref" href="#x2:185"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:182"><span class="id" title="variable">X</span></a>} {<a id="F:186" class="idref" href="#F:186"><span class="id" title="binder">F</span></a>} (<a id="p:187" class="idref" href="#p:187"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:184"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:185"><span class="id" title="variable">x2</span></a>) (<a id="psi:188" class="idref" href="#psi:188"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:183"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:187"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:186"><span class="id" title="variable">F</span></a>) <a id="y:189" class="idref" href="#y:189"><span class="id" title="binder">y</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:184"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:189"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:185"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#F:186"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:189"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(268, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(269, '0_3_59');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(270, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(271, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta_proj" class="idref" href="#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> {<a id="X:190" class="idref" href="#X:190"><span class="id" title="binder">X</span></a> <a id="Y:191" class="idref" href="#Y:191"><span class="id" title="binder">Y</span></a>} {<a id="x1:192" class="idref" href="#x1:192"><span class="id" title="binder">x1</span></a> <a id="x2:193" class="idref" href="#x2:193"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:190"><span class="id" title="variable">X</span></a>} {<a id="F:194" class="idref" href="#F:194"><span class="id" title="binder">F</span></a>} (<a id="p:195" class="idref" href="#p:195"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:192"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:193"><span class="id" title="variable">x2</span></a>) (<a id="psi:196" class="idref" href="#psi:196"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:191"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:194"><span class="id" title="variable">F</span></a>) <a id="y:197" class="idref" href="#y:197"><span class="id" title="binder">y</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:196"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:197"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(272, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(273, '0_3_59');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(274, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(275, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(279, '0_3_63');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim" class="idref" href="#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:198" class="idref" href="#H:198"><span class="id" title="binder">Univalence</span></a>} {<a id="A:199" class="idref" href="#A:199"><span class="id" title="binder">A</span></a>} (<a id="B:200" class="idref" href="#B:200"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:199"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:200"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:200"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(280, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(281, '0_3_63');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(282, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(283, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(284, '0_3_63');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(285, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(286, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_beta_glue" class="idref" href="#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> `{<a id="H:201" class="idref" href="#H:201"><span class="id" title="binder">Univalence</span></a>} {<a id="A:202" class="idref" href="#A:202"><span class="id" title="binder">A</span></a>} <a id="B:203" class="idref" href="#B:203"><span class="id" title="binder">B</span></a> <a id="n:204" class="idref" href="#n:204"><span class="id" title="binder">n</span></a> <a id="a:205" class="idref" href="#a:205"><span class="id" title="binder">a</span></a> <a id="b:206" class="idref" href="#b:206"><span class="id" title="binder">b</span></a> :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:206"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:202"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:206"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(287, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(288, '0_3_63');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(289, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(290, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6. 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(294, '0_3_67');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumInd" class="idref" href="#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(295, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> `{<a id="H:207" class="idref" href="#H:207"><span class="id" title="binder">Univalence</span></a>} {<a id="A:208" class="idref" href="#A:208"><span class="id" title="binder">A</span></a>} (<a id="B:209" class="idref" href="#B:209"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:208"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(296, '0_3_67');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="E:210" class="idref" href="#E:210"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(297, '0_3_67');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="e:214" class="idref" href="#e:214"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:211" class="idref" href="#n:211"><span class="id" title="binder">n</span></a> <a id="a:212" class="idref" href="#a:212"><span class="id" title="binder">a</span></a> <a id="b:213" class="idref" href="#b:213"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:211"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:212"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:213"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(298, '0_3_67');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="t:218" class="idref" href="#t:218"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:215" class="idref" href="#n:215"><span class="id" title="binder">n</span></a> <a id="a:216" class="idref" href="#a:216"><span class="id" title="binder">a</span></a> <a id="b:217" class="idref" href="#b:217"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)<br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(299, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
The point-point case of the nested induction; corresponds to "h" in the paper. 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(303, '0_3_71');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Q" class="idref" href="#Q"><span class="id" title="definition">Q</span></a> <a id="k:219" class="idref" href="#k:219"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:220" class="idref" href="#n:220"><span class="id" title="binder">n</span></a> <a id="a:221" class="idref" href="#a:221"><span class="id" title="binder">a</span></a> <a id="b:222" class="idref" href="#b:222"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:220"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:221"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:219"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:222"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(304, '0_3_71');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(305, '0_3_71');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(306, '0_3_71');
      "><br>
    - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(307, '0_3_71');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(308, '0_3_71');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(309, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
The path-point case of the nested induction is just reflexivity; corresponds to "mu" in the paper. 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(313, '0_3_75');
      ">
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Eta" class="idref" href="#Eta"><span class="id" title="definition">Eta</span></a> {<a id="X:223" class="idref" href="#X:223"><span class="id" title="binder">X</span></a> <a id="Y:224" class="idref" href="#Y:224"><span class="id" title="binder">Y</span></a> <a id="Z:225" class="idref" href="#Z:225"><span class="id" title="binder">Z</span></a>} {<a id="x:226" class="idref" href="#x:226"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:223"><span class="id" title="variable">X</span></a>} {<a id="y1:227" class="idref" href="#y1:227"><span class="id" title="binder">y1</span></a> <a id="y2:228" class="idref" href="#y2:228"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a>} {<a id="z:229" class="idref" href="#z:229"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a>} {<a id="p:230" class="idref" href="#p:230"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:227"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:228"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="q1:231" class="idref" href="#q1:231"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:229"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:227"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:232" class="idref" href="#q2:232"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:229"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:228"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:233" class="idref" href="#theta:233"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:232"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:231"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:230"><span class="id" title="variable">p</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:230"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:231"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:232"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(314, '0_3_75');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(315, '0_3_75');
      "><br>
    <span class="id" title="tactic">symmetry</span> <span class="id" title="tactic">in</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(316, '0_3_75');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(317, '0_3_75');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(318, '0_3_75');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Epsilon" class="idref" href="#Epsilon"><span class="id" title="definition">Epsilon</span></a> {<a id="X:234" class="idref" href="#X:234"><span class="id" title="binder">X</span></a> <a id="Y:235" class="idref" href="#Y:235"><span class="id" title="binder">Y</span></a> <a id="Z:236" class="idref" href="#Z:236"><span class="id" title="binder">Z</span></a>} {<a id="x1:237" class="idref" href="#x1:237"><span class="id" title="binder">x1</span></a> <a id="x2:238" class="idref" href="#x2:238"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:234"><span class="id" title="variable">X</span></a>} {<a id="y1:239" class="idref" href="#y1:239"><span class="id" title="binder">y1</span></a> <a id="y2:240" class="idref" href="#y2:240"><span class="id" title="binder">y2</span></a>} {<a id="F:241" class="idref" href="#F:241"><span class="id" title="binder">F</span></a>} (<a id="p:242" class="idref" href="#p:242"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:237"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:238"><span class="id" title="variable">x2</span></a>) {<a id="q:243" class="idref" href="#q:243"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="psi:244" class="idref" href="#psi:244"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a>} {<a id="r:245" class="idref" href="#r:245"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>} (<a id="theta:246" class="idref" href="#theta:246"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:243"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:245"><span class="id" title="variable">r</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:238"><span class="id" title="variable">x2</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#r:245"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:244"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:244"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:237"><span class="id" title="variable">x1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:243"><span class="id" title="variable">q</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(319, '0_3_75');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(320, '0_3_75');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(321, '0_3_75');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(322, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
The point-path case of the nested induction; corresponds to "H" in the paper. 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(326, '0_3_79');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="R" class="idref" href="#R"><span class="id" title="definition">R</span></a> <a id="k:247" class="idref" href="#k:247"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:248" class="idref" href="#n:248"><span class="id" title="binder">n</span></a> <a id="a:249" class="idref" href="#a:249"><span class="id" title="binder">a</span></a> <a id="b:250" class="idref" href="#b:250"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(327, '0_3_79');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(328, '0_3_79');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(329, '0_3_79');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(330, '0_3_79');
      "><br>
      <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(331, '0_3_79');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(332, '0_3_79');
      "><br>
      <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(333, '0_3_79');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(334, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The point case of the nested induction; corresponds to "g" in the paper. 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(338, '0_3_83');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F" class="idref" href="#F"><span class="id" title="definition">F</span></a> <a id="n:251" class="idref" href="#n:251"><span class="id" title="binder">n</span></a> <a id="a:252" class="idref" href="#a:252"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:253" class="idref" href="#x:253"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:251"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:252"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:253"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(339, '0_3_83');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(340, '0_3_83');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(341, '0_3_83');
      "><br>
    - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:255" class="idref" href="#k:255"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:254"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(342, '0_3_83');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(343, '0_3_83');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(344, '0_3_83');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F_beta_glue" class="idref" href="#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <a id="n:256" class="idref" href="#n:256"><span class="id" title="binder">n</span></a> <a id="a:257" class="idref" href="#a:257"><span class="id" title="binder">a</span></a> <a id="b:258" class="idref" href="#b:258"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:256"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:257"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:258"><span class="id" title="variable">b</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#n:256"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:257"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:258"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(345, '0_3_83');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(346, '0_3_83');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(347, '0_3_83');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(348, '0_3_83');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Phi" class="idref" href="#Phi"><span class="id" title="definition">Phi</span></a> {<a id="X:259" class="idref" href="#X:259"><span class="id" title="binder">X</span></a> <a id="Y:260" class="idref" href="#Y:260"><span class="id" title="binder">Y</span></a> <a id="Z:261" class="idref" href="#Z:261"><span class="id" title="binder">Z</span></a>} {<a id="x1:262" class="idref" href="#x1:262"><span class="id" title="binder">x1</span></a> <a id="x2:263" class="idref" href="#x2:263"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:259"><span class="id" title="variable">X</span></a>} {<a id="y1:264" class="idref" href="#y1:264"><span class="id" title="binder">y1</span></a> <a id="y2:265" class="idref" href="#y2:265"><span class="id" title="binder">y2</span></a>} {<a id="F:266" class="idref" href="#F:266"><span class="id" title="binder">F</span></a>} (<a id="p:267" class="idref" href="#p:267"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:262"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:263"><span class="id" title="variable">x2</span></a>) {<a id="q:268" class="idref" href="#q:268"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="psi:269" class="idref" href="#psi:269"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:260"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a>} {<a id="G1:271" class="idref" href="#G1:271"><span class="id" title="binder">G1</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:270" class="idref" href="#y:270"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:262"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:270"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="G2:273" class="idref" href="#G2:273"><span class="id" title="binder">G2</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:272" class="idref" href="#y:272"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:263"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:272"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>}<br>
    {<a id="r:274" class="idref" href="#r:274"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>} (<a id="theta:275" class="idref" href="#theta:275"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u1:276" class="idref" href="#u1:276"><span class="id" title="binder">u1</span></a> <a id="u2:277" class="idref" href="#u2:277"><span class="id" title="binder">u2</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:273"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:277"><span class="id" title="variable">u2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#u1:276"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:275"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
                      <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:269"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>)) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a>)<br>
      <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="y:278" class="idref" href="#y:278"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#G2:273"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:269"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u1:276"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:277"><span class="id" title="variable">u2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(349, '0_3_83');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(350, '0_3_83');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">u1</span> <span class="id" title="var">u2</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(351, '0_3_83');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(352, '0_3_83');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(353, '0_3_83');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(354, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The path case of the nested induction; corresponds to "omega" in the paper. 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(358, '0_3_87');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="G" class="idref" href="#G"><span class="id" title="definition">G</span></a> <a id="n:279" class="idref" href="#n:279"><span class="id" title="binder">n</span></a> <a id="a:280" class="idref" href="#a:280"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:281" class="idref" href="#y:281"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:281"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:281"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(359, '0_3_87');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(360, '0_3_87');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(361, '0_3_87');
      "><br>
    - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:284" class="idref" href="#k:284"><span class="id" title="binder">k</span></a> <a id="b:285" class="idref" href="#b:285"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(362, '0_3_87');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(363, '0_3_87');
      "><br>
      <span class="id" title="var">snrapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Phi"><span class="id" title="definition">Phi</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(364, '0_3_87');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:288" class="idref" href="#k:288"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:286"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(365, '0_3_87');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:291" class="idref" href="#k:291"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:289"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(366, '0_3_87');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(367, '0_3_87');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(368, '0_3_87');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="I" class="idref" href="#I"><span class="id" title="definition">I</span></a> {<a id="X:292" class="idref" href="#X:292"><span class="id" title="binder">X</span></a> <a id="Y:293" class="idref" href="#Y:293"><span class="id" title="binder">Y</span></a> <a id="Z:294" class="idref" href="#Z:294"><span class="id" title="binder">Z</span></a>} {<a id="x1:295" class="idref" href="#x1:295"><span class="id" title="binder">x1</span></a> <a id="x2:296" class="idref" href="#x2:296"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:292"><span class="id" title="variable">X</span></a>} {<a id="p:297" class="idref" href="#p:297"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:295"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:296"><span class="id" title="variable">x2</span></a>} {<a id="F:298" class="idref" href="#F:298"><span class="id" title="binder">F</span></a>} (<a id="psi:299" class="idref" href="#psi:299"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:293"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:298"><span class="id" title="variable">F</span></a>) {<a id="G1:300" class="idref" href="#G1:300"><span class="id" title="binder">G1</span></a> <a id="G2:301" class="idref" href="#G2:301"><span class="id" title="binder">G2</span></a>}<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:302" class="idref" href="#x:302"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:303" class="idref" href="#y:303"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:294"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:302"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:303"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:300"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:301"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a><br>
      <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:304" class="idref" href="#y:304"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:301"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:298"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:299"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:300"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(369, '0_3_87');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(370, '0_3_87');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(371, '0_3_87');
      "><br>
    <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Forall.html#equiv_apD10"><span class="id" title="definition">equiv_apD10</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(372, '0_3_87');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(373, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The alternative induction rule in curried form; corresponds to curried "G" in
      the paper. 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(377, '0_3_91');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur" class="idref" href="#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:305" class="idref" href="#x:305"><span class="id" title="binder">x</span></a> <a id="y:306" class="idref" href="#y:306"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:305"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:306"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(378, '0_3_91');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(379, '0_3_91');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(380, '0_3_91');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(381, '0_3_91');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(382, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The computation rule for the alternative induction rule in curried form. 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(386, '0_3_95');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur_beta_glue" class="idref" href="#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <a id="n:307" class="idref" href="#n:307"><span class="id" title="binder">n</span></a> <a id="a:308" class="idref" href="#a:308"><span class="id" title="binder">a</span></a> :<br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G"><span class="id" title="definition">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(387, '0_3_95');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(388, '0_3_95');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveR_equiv_M"><span class="id" title="definition">moveR_equiv_M</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(389, '0_3_95');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(390, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
The alternative induction rule; corresponds to "G" in the paper. 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(394, '0_3_99');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind" class="idref" href="#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:309" class="idref" href="#x:309"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:309"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(395, '0_3_99');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(396, '0_3_99');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>]; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(397, '0_3_99');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(398, '0_3_99');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Xi" class="idref" href="#Xi"><span class="id" title="definition">Xi</span></a> {<a id="X:310" class="idref" href="#X:310"><span class="id" title="binder">X</span></a> <a id="Y:311" class="idref" href="#Y:311"><span class="id" title="binder">Y</span></a> <a id="Z:312" class="idref" href="#Z:312"><span class="id" title="binder">Z</span></a>} <a id="G:313" class="idref" href="#G:313"><span class="id" title="binder">G</span></a> {<a id="x:314" class="idref" href="#x:314"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:310"><span class="id" title="variable">X</span></a>} {<a id="y1:315" class="idref" href="#y1:315"><span class="id" title="binder">y1</span></a> <a id="y2:316" class="idref" href="#y2:316"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>} {<a id="z:317" class="idref" href="#z:317"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a>} {<a id="p:318" class="idref" href="#p:318"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:315"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:316"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="q1:319" class="idref" href="#q1:319"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:315"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:320" class="idref" href="#q2:320"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:316"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:321" class="idref" href="#theta:321"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:320"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:319"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:312"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:319"><span class="id" title="variable">q1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:321"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:320"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(399, '0_3_99');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(400, '0_3_99');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">theta</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(401, '0_3_99');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(402, '0_3_99');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">q1</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(403, '0_3_99');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(404, '0_3_99');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(405, '0_3_99');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Mu" class="idref" href="#Mu"><span class="id" title="definition">Mu</span></a> {<a id="X:322" class="idref" href="#X:322"><span class="id" title="binder">X</span></a> <a id="Y:323" class="idref" href="#Y:323"><span class="id" title="binder">Y</span></a> <a id="Z:324" class="idref" href="#Z:324"><span class="id" title="binder">Z</span></a>} {<a id="x1:325" class="idref" href="#x1:325"><span class="id" title="binder">x1</span></a> <a id="x2:326" class="idref" href="#x2:326"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:322"><span class="id" title="variable">X</span></a>} (<a id="p:327" class="idref" href="#p:327"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:325"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:326"><span class="id" title="variable">x2</span></a>) {<a id="F:328" class="idref" href="#F:328"><span class="id" title="binder">F</span></a>} (<a id="G:330" class="idref" href="#G:330"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="z:329" class="idref" href="#z:329"><span class="id" title="binder">z</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:324"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:329"><span class="id" title="variable">z</span></a>)<br>
    {<a id="psi:331" class="idref" href="#psi:331"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:323"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:328"><span class="id" title="variable">F</span></a>} {<a id="q:332" class="idref" href="#q:332"><span class="id" title="binder">q</span></a>} (<a id="theta:335" class="idref" href="#theta:335"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:331"><span class="id" title="variable">psi</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<span class="id" title="keyword">fun</span> <a id="x:333" class="idref" href="#x:333"><span class="id" title="binder">x</span></a> <a id="y:334" class="idref" href="#y:334"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#G:330"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:333"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:334"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:332"><span class="id" title="variable">q</span></a>) <a id="y:336" class="idref" href="#y:336"><span class="id" title="binder">y</span></a><br>
    : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:330"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:331"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:336"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#q:332"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:336"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(406, '0_3_99');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(407, '0_3_99');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(408, '0_3_99');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(409, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The computation rule for the alternative induction rule. 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(413, '0_3_103');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_beta_glue" class="idref" href="#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:337" class="idref" href="#n:337"><span class="id" title="binder">n</span></a> <a id="a:338" class="idref" href="#a:338"><span class="id" title="binder">a</span></a> <a id="b:339" class="idref" href="#b:339"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:337"><span class="id" title="variable">n</span></a> <span class="id" title="var">_</span>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:337"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:338"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:339"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(414, '0_3_103');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(415, '0_3_103');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(416, '0_3_103');
      "><br>
    <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Xi"><span class="id" title="definition">Xi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(417, '0_3_103');
      "><br>
    <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Mu"><span class="id" title="definition">Mu</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(418, '0_3_103');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(419, '0_3_103');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(420, '0_3_103');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(421, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
An alternative recursion principle for the sum of colimits; Lemma 5.3. 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(425, '0_3_107');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumRec" class="idref" href="#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(426, '0_3_107');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> `{<a id="H:340" class="idref" href="#H:340"><span class="id" title="binder">Univalence</span></a>} {<a id="A:341" class="idref" href="#A:341"><span class="id" title="binder">A</span></a>} (<a id="B:342" class="idref" href="#B:342"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:341"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(427, '0_3_107');
      "><br>
  <span class="id" title="keyword">Context</span> <a id="E:343" class="idref" href="#E:343"><span class="id" title="binder">E</span></a> (<a id="e:346" class="idref" href="#e:346"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:344" class="idref" href="#n:344"><span class="id" title="binder">n</span></a> <a id="a:345" class="idref" href="#a:345"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:344"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:345"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:343"><span class="id" title="variable">E</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(428, '0_3_107');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="t:350" class="idref" href="#t:350"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:347" class="idref" href="#n:347"><span class="id" title="binder">n</span></a> <a id="a:348" class="idref" href="#a:348"><span class="id" title="binder">a</span></a> (<a id="b:349" class="idref" href="#b:349"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:349"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:349"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(429, '0_3_107');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec" class="idref" href="#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.E"><span class="id" title="variable">E</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(430, '0_3_107');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(431, '0_3_107');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> (<span class="id" title="keyword">fun</span> <a id="n:354" class="idref" href="#n:354"><span class="id" title="binder">n</span></a> <a id="a:355" class="idref" href="#a:355"><span class="id" title="binder">a</span></a> <a id="b:356" class="idref" href="#b:356"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:351"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:352"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:353"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(432, '0_3_107');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(433, '0_3_107');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec_beta_glue" class="idref" href="#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:357" class="idref" href="#n:357"><span class="id" title="binder">n</span></a> <a id="a:358" class="idref" href="#a:358"><span class="id" title="binder">a</span></a> <a id="b:359" class="idref" href="#b:359"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:357"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:358"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:359"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:357"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:358"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:359"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(434, '0_3_107');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(435, '0_3_107');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" title="lemma">apD_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(436, '0_3_107');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(437, '0_3_107');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(438, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(439, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
Lemma 5.4. 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(443, '0_3_111');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_sum_uniq" class="idref" href="#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a> `{<a id="H:360" class="idref" href="#H:360"><span class="id" title="binder">Univalence</span></a>} {<a id="A:361" class="idref" href="#A:361"><span class="id" title="binder">A</span></a>} (<a id="B:362" class="idref" href="#B:362"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:361"><span class="id" title="variable">A</span></a>) <a id="E:363" class="idref" href="#E:363"><span class="id" title="binder">E</span></a><br>
  (<a id="F:364" class="idref" href="#F:364"><span class="id" title="binder">F</span></a> <a id="G:365" class="idref" href="#G:365"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:363"><span class="id" title="variable">E</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#F:364"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:365"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#F:364"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:365"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(444, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(445, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <span class="id" title="var">B</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">h</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(446, '0_3_111');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(447, '0_3_111');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(448, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1. 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(452, '0_3_115');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:366" class="idref" href="#H:366"><span class="id" title="binder">Univalence</span></a>} {<a id="A:367" class="idref" href="#A:367"><span class="id" title="binder">A</span></a>} (<a id="B:368" class="idref" href="#B:368"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:367"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:368"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(453, '0_3_115');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(454, '0_3_115');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="G:370" class="idref" href="#G:370"><span class="id" title="binder">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:369"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(455, '0_3_115');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(456, '0_3_115');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(457, '0_3_115');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:374" class="idref" href="#n:374"><span class="id" title="binder">n</span></a> <a id="a:375" class="idref" href="#a:375"><span class="id" title="binder">a</span></a> <a id="b:376" class="idref" href="#b:376"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:371"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:372"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:373"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(458, '0_3_115');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:380" class="idref" href="#n:380"><span class="id" title="binder">n</span></a> <a id="a:381" class="idref" href="#a:381"><span class="id" title="binder">a</span></a> <a id="b:382" class="idref" href="#b:382"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:377"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:378"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:379"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(459, '0_3_115');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(460, '0_3_115');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:385" class="idref" href="#n:385"><span class="id" title="binder">n</span></a> <a id="a:386" class="idref" href="#a:386"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(461, '0_3_115');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(462, '0_3_115');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(463, '0_3_115');
      "><br>
  - <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(464, '0_3_115');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(465, '0_3_115');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(466, '0_3_115');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#equiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">equiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:387" class="idref" href="#H:387"><span class="id" title="binder">Univalence</span></a>} {<a id="A:388" class="idref" href="#A:388"><span class="id" title="binder">A</span></a>} (<a id="B:389" class="idref" href="#B:389"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:388"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>)<br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(467, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1. 
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(471, '0_3_119');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_fst" class="idref" href="#seq_colim_sum_to_sum_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_fst</span></a> `{<a id="H:390" class="idref" href="#H:390"><span class="id" title="binder">Univalence</span></a>} {<a id="A:391" class="idref" href="#A:391"><span class="id" title="binder">A</span></a>} (<a id="B:392" class="idref" href="#B:392"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:391"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:392"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:392"><span class="id" title="variable">B</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(472, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(473, '0_3_119');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(474, '0_3_119');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:395" class="idref" href="#n:395"><span class="id" title="binder">n</span></a> <a id="a:396" class="idref" href="#a:396"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(475, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(476, '0_3_119');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>, (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(477, '0_3_119');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(478, '0_3_119');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(479, '0_3_119');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(480, '0_3_119');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
<div class="doc" scenenumber="121">
The characterization of path spaces in sequential colimits; Theorem 7.4, first part. 
</div>
<div scenenumber="123" class="code">
<span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(484, '0_3_123');
      ">
<span class="id" title="keyword">Definition</span> <a id="path_seq" class="idref" href="#path_seq"><span class="id" title="definition">path_seq</span></a> (<a id="A:397" class="idref" href="#A:397"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) (<a id="a1:398" class="idref" href="#a1:398"><span class="id" title="binder">a1</span></a> <a id="a2:399" class="idref" href="#a2:399"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:397"><span class="id" title="variable">A</span></a> 0)<br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:400" class="idref" href="#k:400"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a1:398"><span class="id" title="variable">a1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:400"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:399"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:400"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:401" class="idref" href="#k:401"><span class="id" title="binder">k</span></a> <a id="p:402" class="idref" href="#p:402"><span class="id" title="binder">p</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:403" class="idref" href="#a:403"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:403"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:402"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(485, '0_3_123');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim_zero" class="idref" href="#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> `{<a id="H:404" class="idref" href="#H:404"><span class="id" title="binder">Univalence</span></a>} {<a id="A:405" class="idref" href="#A:405"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a1:406" class="idref" href="#a1:406"><span class="id" title="binder">a1</span></a> <a id="a2:407" class="idref" href="#a2:407"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0) :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a1:406"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a2:407"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:406"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:407"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(486, '0_3_123');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(487, '0_3_123');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">B</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#Build_FibSequence"><span class="id" title="constructor">Build_FibSequence</span></a> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <a id="x:411" class="idref" href="#x:411"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">a1</span><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:408"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:408"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>) (<span class="id" title="keyword">fun</span> <a id="x:412" class="idref" href="#x:412"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:413" class="idref" href="#a:413"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:410"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(488, '0_3_123');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> 0 <span class="id" title="var">a2</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(489, '0_3_123');
      "><br>
  + <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.PathAny.html#equiv_path_from_contr"><span class="id" title="definition">equiv_path_from_contr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(490, '0_3_123');
      "><br>
    - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a1</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) 0 <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(491, '0_3_123');
      "><br>
    - <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv"><span class="id" title="lemma">contr_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(492, '0_3_123');
      "><br>
      <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Contractible.html#contr_basedpaths"><span class="id" title="instance">contr_basedpaths</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(493, '0_3_123');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a2</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(494, '0_3_123');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(495, '0_3_123');
      "><br>
    × <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(496, '0_3_123');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:415" class="idref" href="#n:415"><span class="id" title="binder">n</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:414"><span class="id" title="variable">n</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(497, '0_3_123');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(498, '0_3_123');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(499, '0_3_123');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(500, '0_3_123');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_123"><pre><span></span></pre></div>
<div class="doc" scenenumber="125">
The characterization of path spaces in sequential colimits; Theorem 7.4, second part. 
</div>
<div scenenumber="127" class="code">
<span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(504, '0_3_127');
      ">
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim" class="idref" href="#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> `{<a id="H:416" class="idref" href="#H:416"><span class="id" title="binder">Univalence</span></a>} {<a id="A:417" class="idref" href="#A:417"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="n:418" class="idref" href="#n:418"><span class="id" title="binder">n</span></a> (<a id="a1:419" class="idref" href="#a1:419"><span class="id" title="binder">a1</span></a> <a id="a2:420" class="idref" href="#a2:420"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a>) :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:419"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:420"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a1:419"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:420"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(505, '0_3_127');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(506, '0_3_127');
      "><br>
  <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(507, '0_3_127');
      "><br>
  <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(508, '0_3_127');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(509, '0_3_127');
      "><br>
<br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(510, '0_3_127');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_127"><pre><span></span></pre></div>
<div class="doc" scenenumber="129">
Corollary 7.7.1, second part. 
</div>
<div scenenumber="131" class="code">
<span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(514, '0_3_131');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="trunc_seq_colim" class="idref" href="#trunc_seq_colim"><span class="id" title="instance">trunc_seq_colim</span></a> `{<a id="H:421" class="idref" href="#H:421"><span class="id" title="binder">Univalence</span></a>} {<a id="A:422" class="idref" href="#A:422"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="k:423" class="idref" href="#k:423"><span class="id" title="binder">k</span></a> :<br>
  <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:424" class="idref" href="#n:424"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:423"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:422"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:424"><span class="id" title="variable">n</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:423"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:422"><span class="id" title="variable">A</span></a>) | 100.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(515, '0_3_131');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(516, '0_3_131');
      "><br>
  <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">IHk</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(517, '0_3_131');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(518, '0_3_131');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(519, '0_3_131');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(520, '0_3_131');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(521, '0_3_131');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">a</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">m</span> <span class="id" title="var">IHm</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(522, '0_3_131');
      "><br>
          { <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(523, '0_3_131');
      "><br>
            <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))). }</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(524, '0_3_131');
      "><br>
          { <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(525, '0_3_131');
      "><br>
            <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(526, '0_3_131');
      "><br>
            <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHm</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> 0%<span class="id" title="var">nat</span> <span class="id" title="var">_</span> 1%<span class="id" title="var">path</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(527, '0_3_131');
      "><br>
            <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)). }}</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(528, '0_3_131');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Forall.html#functor_forall_equiv_pb"><span class="id" title="definition">functor_forall_equiv_pb</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(529, '0_3_131');
      "><br>
        <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHn</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span>)); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(530, '0_3_131');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Types.Forall.html#trunc_forall"><span class="id" title="instance">trunc_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(531, '0_3_131');
      "><br>
      { <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
      { <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(532, '0_3_131');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_131"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
