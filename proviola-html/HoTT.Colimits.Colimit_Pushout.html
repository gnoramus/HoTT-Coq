<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>C is declared</infomsg>	";
            responses[i]=data;
          

            i = 33;
            data = "1 goal (ID 31)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  Cocone (span f g) Z	";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "2 goals (ID 44)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Z		goal 2 (ID 46) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j),	 ?legs j o Diagram.arr (span f g) g0 == ?legs i	";
            responses[i]=data;
          

            i = 36;
            data = "1 goal (ID 44)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Z	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 46) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j),	 (fun i0 : Graph.graph0 span_graph =>	  match i0 as s return (Diagram.obj (span f g) s -> Z) with	  | inl a => unit_name (inr' o g) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1 return (Diagram.obj (span f g) (inr b1) -> Z)	       then inl'	       else inr') b	  end) j o Diagram.arr (span f g) g0 ==	 (fun i0 : Graph.graph0 span_graph =>	  match i0 as s return (Diagram.obj (span f g) s -> Z) with	  | inl a => unit_name (inr' o g) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1 return (Diagram.obj (span f g) (inr b1) -> Z)	       then inl'	       else inr') b	  end) i	";
            responses[i]=data;
          

            i = 37;
            data = "1 goal (ID 46)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j),	  (fun i0 : Graph.graph0 span_graph =>	   match i0 as s return (Diagram.obj (span f g) s -> Z) with	   | inl a => unit_name (inr' o g) a	   | inr b =>	       (fun b0 : Bool =>	        if b0 as b1 return (Diagram.obj (span f g) (inr b1) -> Z)	        then inl'	        else inr') b	   end) j o Diagram.arr (span f g) g0 ==	  (fun i0 : Graph.graph0 span_graph =>	   match i0 as s return (Diagram.obj (span f g) s -> Z) with	   | inl a => unit_name (inr' o g) a	   | inr b =>	       (fun b0 : Bool =>	        if b0 as b1 return (Diagram.obj (span f g) (inr b1) -> Z)	        then inl'	        else inr') b	   end) i	1 goal (ID 94)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  b : Bool	  ============================	  (fun x : A =>	   (if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr')	     ((if b as b0 return (Unit -> A -> if b0 then B else C)	       then unit_name f	       else unit_name g) tt x)) == (fun x : A => inr' (g x))	";
            responses[i]=data;
          

            i = 38;
            data = "2 goals (ID 98)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  (fun x : A => inl' (f x)) == (fun x : A => inr' (g x))		goal 2 (ID 99) is:	 (fun x : A => inr' (g x)) == (fun x : A => inr' (g x))	";
            responses[i]=data;
          

            i = 39;
            data = "1 goal (ID 98)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  (fun x : A => inl' (f x)) == (fun x : A => inr' (g x))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 99) is:	 (fun x : A => inr' (g x)) == (fun x : A => inr' (g x))	";
            responses[i]=data;
          

            i = 40;
            data = "1 goal (ID 99)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  (fun x : A => inr' (g x)) == (fun x : A => inr' (g x))	No more goals.	";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "<infomsg>pol' is defined</infomsg>	";
            responses[i]=data;
          

            i = 43;
            data = "<infomsg>por' is defined</infomsg>	";
            responses[i]=data;
          

            i = 44;
            data = "<infomsg>popp' is defined</infomsg>	";
            responses[i]=data;
          

            i = 45;
            data = "<infomsg>is_PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 46;
            data = "<infomsg>PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>f is declared</infomsg>	<infomsg>g is declared</infomsg>	";
            responses[i]=data;
          

            i = 48;
            data = "<infomsg>pol is defined</infomsg>	";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>por is defined</infomsg>	";
            responses[i]=data;
          

            i = 50;
            data = "<infomsg>popp is defined</infomsg>	";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "1 goal (ID 165)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall w : PO f g, P w	";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "2 goals (ID 183)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : Graph.graph0 span_graph) (x : Diagram.obj (span f g) i),	  P (colim i x)		goal 2 (ID 185) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j)	 (x : Diagram.obj (span f g) i),	 transport P (colimp i j g0 x) (?q j (Diagram.arr (span f g) g0 x)) = ?q i x	";
            responses[i]=data;
          

            i = 62;
            data = "1 goal (ID 183)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : Graph.graph0 span_graph) (x : Diagram.obj (span f g) i),	  P (colim i x)	3 goals (ID 202)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : Diagram.obj (span f g) (inl tt)	  ============================	  P (colim (inl tt) x)		goal 2 (ID 203) is:	 P (colim (inr true) x)	goal 3 (ID 204) is:	 P (colim (inr false) x)	";
            responses[i]=data;
          

            i = 63;
            data = "1 goal (ID 202)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : Diagram.obj (span f g) (inl tt)	  ============================	  P (colim (inl tt) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 203) is:	 P (colim (inr true) x)	goal 2 (ID 204) is:	 P (colim (inr false) x)	goal 3 (ID 185) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j)	 (x : Diagram.obj (span f g) i),	 transport P (colimp i j g0 x)	   ((fun i0 : Graph.graph0 span_graph =>	     match	       i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	     with	     | inl a =>	         (fun u : Unit =>	          match	            u as u0	            return	              (forall x0 : Diagram.obj (span f g) (inl u0),	               P (colim (inl u0) x0))	          with	          | tt =>	              fun x0 : Diagram.obj (span f g) (inl tt) =>	              transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	          end) a	     | inr b =>	         (fun b0 : Bool =>	          if b0 as b1	           return	             (forall x0 : Diagram.obj (span f g) (inr b1),	              P (colim (inr b1) x0))	          then fun x0 : Diagram.obj (span f g) (inr true) => ?Goal@{x:=x0}	          else fun x0 : Diagram.obj (span f g) (inr false) => ?Goal0@{x:=x0})	           b	     end) j (Diagram.arr (span f g) g0 x)) =	 (fun i0 : Graph.graph0 span_graph =>	  match	    i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	  with	  | inl a =>	      (fun u : Unit =>	       match	         u as u0	         return	           (forall x0 : Diagram.obj (span f g) (inl u0),	            P (colim (inl u0) x0))	       with	       | tt =>	           fun x0 : Diagram.obj (span f g) (inl tt) =>	           transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	       end) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1	        return	          (forall x0 : Diagram.obj (span f g) (inr b1), P (colim (inr b1) x0))	       then fun x0 : Diagram.obj (span f g) (inr true) => ?Goal@{x:=x0}	       else fun x0 : Diagram.obj (span f g) (inr false) => ?Goal0@{x:=x0}) b	  end) i x	";
            responses[i]=data;
          

            i = 64;
            data = "1 goal (ID 203)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : Diagram.obj (span f g) (inr true)	  ============================	  P (colim (inr true) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 204) is:	 P (colim (inr false) x)	goal 2 (ID 185) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j)	 (x : Diagram.obj (span f g) i),	 transport P (colimp i j g0 x)	   ((fun i0 : Graph.graph0 span_graph =>	     match	       i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	     with	     | inl a =>	         (fun u : Unit =>	          match	            u as u0	            return	              (forall x0 : Diagram.obj (span f g) (inl u0),	               P (colim (inl u0) x0))	          with	          | tt =>	              fun x0 : Diagram.obj (span f g) (inl tt) =>	              transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	          end) a	     | inr b =>	         (fun b0 : Bool =>	          if b0 as b1	           return	             (forall x0 : Diagram.obj (span f g) (inr b1),	              P (colim (inr b1) x0))	          then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	          else fun x0 : Diagram.obj (span f g) (inr false) => ?Goal@{x:=x0})	           b	     end) j (Diagram.arr (span f g) g0 x)) =	 (fun i0 : Graph.graph0 span_graph =>	  match	    i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	  with	  | inl a =>	      (fun u : Unit =>	       match	         u as u0	         return	           (forall x0 : Diagram.obj (span f g) (inl u0),	            P (colim (inl u0) x0))	       with	       | tt =>	           fun x0 : Diagram.obj (span f g) (inl tt) =>	           transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	       end) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1	        return	          (forall x0 : Diagram.obj (span f g) (inr b1), P (colim (inr b1) x0))	       then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	       else fun x0 : Diagram.obj (span f g) (inr false) => ?Goal@{x:=x0}) b	  end) i x	";
            responses[i]=data;
          

            i = 65;
            data = "1 goal (ID 204)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : Diagram.obj (span f g) (inr false)	  ============================	  P (colim (inr false) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 185) is:	 forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j)	 (x : Diagram.obj (span f g) i),	 transport P (colimp i j g0 x)	   ((fun i0 : Graph.graph0 span_graph =>	     match	       i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	     with	     | inl a =>	         (fun u : Unit =>	          match	            u as u0	            return	              (forall x0 : Diagram.obj (span f g) (inl u0),	               P (colim (inl u0) x0))	          with	          | tt =>	              fun x0 : Diagram.obj (span f g) (inl tt) =>	              transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	          end) a	     | inr b =>	         (fun b0 : Bool =>	          if b0 as b1	           return	             (forall x0 : Diagram.obj (span f g) (inr b1),	              P (colim (inr b1) x0))	          then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	          else fun x0 : Diagram.obj (span f g) (inr false) => r' x0) b	     end) j (Diagram.arr (span f g) g0 x)) =	 (fun i0 : Graph.graph0 span_graph =>	  match	    i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	  with	  | inl a =>	      (fun u : Unit =>	       match	         u as u0	         return	           (forall x0 : Diagram.obj (span f g) (inl u0),	            P (colim (inl u0) x0))	       with	       | tt =>	           fun x0 : Diagram.obj (span f g) (inl tt) =>	           transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	       end) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1	        return	          (forall x0 : Diagram.obj (span f g) (inr b1), P (colim (inr b1) x0))	       then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	       else fun x0 : Diagram.obj (span f g) (inr false) => r' x0) b	  end) i x	";
            responses[i]=data;
          

            i = 66;
            data = "1 goal (ID 185)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i j : Graph.graph0 span_graph) (g0 : Graph.graph1 span_graph i j)	  (x : Diagram.obj (span f g) i),	  transport P (colimp i j g0 x)	    ((fun i0 : Graph.graph0 span_graph =>	      match	        i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	      with	      | inl a =>	          (fun u : Unit =>	           match	             u as u0	             return	               (forall x0 : Diagram.obj (span f g) (inl u0),	                P (colim (inl u0) x0))	           with	           | tt =>	               fun x0 : Diagram.obj (span f g) (inl tt) =>	               transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	           end) a	      | inr b =>	          (fun b0 : Bool =>	           if b0 as b1	            return	              (forall x0 : Diagram.obj (span f g) (inr b1),	               P (colim (inr b1) x0))	           then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	           else fun x0 : Diagram.obj (span f g) (inr false) => r' x0) b	      end) j (Diagram.arr (span f g) g0 x)) =	  (fun i0 : Graph.graph0 span_graph =>	   match	     i0 as s return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	   with	   | inl a =>	       (fun u : Unit =>	        match	          u as u0	          return	            (forall x0 : Diagram.obj (span f g) (inl u0),	             P (colim (inl u0) x0))	        with	        | tt =>	            fun x0 : Diagram.obj (span f g) (inl tt) =>	            transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	        end) a	   | inr b =>	       (fun b0 : Bool =>	        if b0 as b1	         return	           (forall x0 : Diagram.obj (span f g) (inr b1),	            P (colim (inr b1) x0))	        then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	        else fun x0 : Diagram.obj (span f g) (inr false) => r' x0) b	   end) i x	1 goal (ID 246)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  u : Unit	  b : Bool	  ============================	  forall x : A,	  transport P (colimp (inl u) (inr b) tt x)	    ((if b as b0	       return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	      then fun x0 : B => l' x0	      else fun x0 : C => r' x0)	       ((if b as b0 return (Unit -> A -> if b0 then B else C)	         then unit_name f	         else unit_name g) tt x)) =	  match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	  | tt =>	      fun x0 : A =>	      transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	  end x	";
            responses[i]=data;
          

            i = 67;
            data = "2 goals (ID 255)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))		goal 2 (ID 256) is:	 forall x : A,	 transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	 transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 68;
            data = "1 goal (ID 256)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 69;
            data = "1 goal (ID 259)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 70;
            data = "1 goal (ID 260)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  transport P (colimp (inl tt) (inr false) tt a) (r' (g a)) =	  transport P (colimp (inl tt) (inr true) tt a) (l' (f a))	";
            responses[i]=data;
          

            i = 71;
            data = "1 goal (ID 262)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P (colimp (inl tt) (inr false) tt a)^	    (transport P (colimp (inl tt) (inr true) tt a) (l' (f a)))	";
            responses[i]=data;
          

            i = 72;
            data = "1 goal (ID 279)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P	    (colimp (inl tt) (inr true) tt a @ (colimp (inl tt) (inr false) tt a)^)	    (l' (f a))	";
            responses[i]=data;
          

            i = 73;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "1 goal (ID 187)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A, apD (PO_ind P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "1 goal (ID 188)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 78;
            data = "2 focused goals	(shelved: 1) (ID 205)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = ?Goal		goal 2 (ID 206) is:	 ?Goal = pp' x	";
            responses[i]=data;
          

            i = 79;
            data = "1 goal (ID 206)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (Diagram.arr (span f g) tt x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 80;
            data = "2 goals (ID 226)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1		goal 2 (ID 227) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (Diagram.arr (span f g) tt x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	";
            responses[i]=data;
          

            i = 81;
            data = "1 goal (ID 226)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	1 goal (ID 228)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD	    (Colimit_ind P	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	        with	        | inl a =>	            match	              a as u	              return	                (forall x0 : Diagram.obj (span f g) (inl u),	                 P (colim (inl u) x0))	            with	            | tt =>	                fun x0 : Diagram.obj (span f g) (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return	               (forall x0 : Diagram.obj (span f g) (inr b0),	                P (colim (inr b0) x0))	            then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	            else fun x0 : Diagram.obj (span f g) (inr false) => r' x0	        end)	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return	            (forall (j : Graph.graph0 span_graph)	             (g0 : Graph.graph1 span_graph s j)	             (x0 : Diagram.obj (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0	                  return	                    (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	                with	                | inl a =>	                    match	                      a as u	                      return	                        (forall x1 : Diagram.obj (span f g) (inl u),	                         P (colim (inl u) x1))	                    with	                    | tt =>	                        fun x1 : Diagram.obj (span f g) (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : Diagram.obj (span f g) (inr b0),	                        P (colim (inr b0) x1))	                    then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                    else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                end (Diagram.arr (span f g) g0 x0)) =	             match	               s as s0	               return	                 (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	             with	             | inl a =>	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : Diagram.obj (span f g) (inr b0),	                     P (colim (inr b0) x1))	                 then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                 else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	             end x0)	        with	        | inl a =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inl a) s)	                 (x0 : Diagram.obj (span f g) (inl a)),	                 transport P (colimp (inl a) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a0 =>	                        match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b0),	                            P (colim (inr b0) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl a0 =>	                fun g0 : Graph.graph1 span_graph (inl a) (inl a0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inl a0) e x0)	                       (match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     match	                       a as u	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u),	                          P (colim (inl u) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : Graph.graph1 span_graph (inl a) (inr b) =>	                match	                  g0 as u	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inr b) u x0)	                       ((if b as b0	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b0),	                             P (colim (inr b0) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) u x0)) =	                     match	                       a as u0	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u0),	                          P (colim (inl u0) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      a as u	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u as u0	                           return (forall x1 : A, P (colim (inl u0) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a0 : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a0) 	                           (r' (g a0))	                           (transport P (colimp (inl tt) (inr true) tt a0)	                              (l' (f a0)))	                           ((pp' a0)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a0)	                              (colimp (inl tt) (inr false) tt a0)^	                              (l' (f a0)))	                    end	                end	            end	        | inr b =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inr b) s)	                 (x0 : Diagram.obj (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a =>	                        match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b1),	                            P (colim (inr b1) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 (if b as b0	                   return	                     (forall x1 : Diagram.obj (span f g) (inr b0),	                      P (colim (inr b0) x1))	                  then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                  else fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                   x0)	            with	            | inl a =>	                fun g0 : Graph.graph1 span_graph (inr b) (inl a) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inl a) e x0)	                       (match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     (if b as b0	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b0),	                          P (colim (inr b0) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            | inr b0 =>	                fun g0 : Graph.graph1 span_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b1),	                             P (colim (inr b1) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) e x0)) =	                     (if b as b1	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b1),	                          P (colim (inr b1) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            end	        end)) (colimp (inl tt) (inr true) tt x) = 1	";
            responses[i]=data;
          

            i = 82;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 227) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (Diagram.arr (span f g) tt x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	1 goal (ID 227)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  X : apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (Diagram.arr (span f g) tt x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	1 goal (ID 237)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @ 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 83;
            data = "1 goal (ID 247)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (PO_ind P l' r' pp' (colim (inl tt) x))	    (PO_ind P l' r' pp' (colim (inr false) (g x)))	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 84;
            data = "1 goal (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (Colimit_ind P	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	        with	        | inl a =>	            match	              a as u	              return	                (forall x0 : Diagram.obj (span f g) (inl u),	                 P (colim (inl u) x0))	            with	            | tt =>	                fun x0 : Diagram.obj (span f g) (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return	               (forall x0 : Diagram.obj (span f g) (inr b0),	                P (colim (inr b0) x0))	            then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	            else fun x0 : Diagram.obj (span f g) (inr false) => r' x0	        end)	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return	            (forall (j : Graph.graph0 span_graph)	             (g0 : Graph.graph1 span_graph s j)	             (x0 : Diagram.obj (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0	                  return	                    (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	                with	                | inl a =>	                    match	                      a as u	                      return	                        (forall x1 : Diagram.obj (span f g) (inl u),	                         P (colim (inl u) x1))	                    with	                    | tt =>	                        fun x1 : Diagram.obj (span f g) (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : Diagram.obj (span f g) (inr b0),	                        P (colim (inr b0) x1))	                    then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                    else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                end (Diagram.arr (span f g) g0 x0)) =	             match	               s as s0	               return	                 (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	             with	             | inl a =>	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : Diagram.obj (span f g) (inr b0),	                     P (colim (inr b0) x1))	                 then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                 else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	             end x0)	        with	        | inl a =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inl a) s)	                 (x0 : Diagram.obj (span f g) (inl a)),	                 transport P (colimp (inl a) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a0 =>	                        match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b0),	                            P (colim (inr b0) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl a0 =>	                fun g0 : Graph.graph1 span_graph (inl a) (inl a0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inl a0) e x0)	                       (match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     match	                       a as u	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u),	                          P (colim (inl u) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : Graph.graph1 span_graph (inl a) (inr b) =>	                match	                  g0 as u	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inr b) u x0)	                       ((if b as b0	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b0),	                             P (colim (inr b0) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) u x0)) =	                     match	                       a as u0	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u0),	                          P (colim (inl u0) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      a as u	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u as u0	                           return (forall x1 : A, P (colim (inl u0) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a0 : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a0) 	                           (r' (g a0))	                           (transport P (colimp (inl tt) (inr true) tt a0)	                              (l' (f a0)))	                           ((pp' a0)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a0)	                              (colimp (inl tt) (inr false) tt a0)^	                              (l' (f a0)))	                    end	                end	            end	        | inr b =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inr b) s)	                 (x0 : Diagram.obj (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a =>	                        match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b1),	                            P (colim (inr b1) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 (if b as b0	                   return	                     (forall x1 : Diagram.obj (span f g) (inr b0),	                      P (colim (inr b0) x1))	                  then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                  else fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                   x0)	            with	            | inl a =>	                fun g0 : Graph.graph1 span_graph (inr b) (inl a) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inl a) e x0)	                       (match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     (if b as b0	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b0),	                          P (colim (inr b0) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            | inr b0 =>	                fun g0 : Graph.graph1 span_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b1),	                             P (colim (inr b1) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) e x0)) =	                     (if b as b1	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b1),	                          P (colim (inr b1) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            end	        end) (colim (inl tt) x))	    (Colimit_ind P	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	        with	        | inl a =>	            match	              a as u	              return	                (forall x0 : Diagram.obj (span f g) (inl u),	                 P (colim (inl u) x0))	            with	            | tt =>	                fun x0 : Diagram.obj (span f g) (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return	               (forall x0 : Diagram.obj (span f g) (inr b0),	                P (colim (inr b0) x0))	            then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	            else fun x0 : Diagram.obj (span f g) (inr false) => r' x0	        end)	       (fun i : Graph.graph0 span_graph =>	        match	          i as s	          return	            (forall (j : Graph.graph0 span_graph)	             (g0 : Graph.graph1 span_graph s j)	             (x0 : Diagram.obj (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0	                  return	                    (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	                with	                | inl a =>	                    match	                      a as u	                      return	                        (forall x1 : Diagram.obj (span f g) (inl u),	                         P (colim (inl u) x1))	                    with	                    | tt =>	                        fun x1 : Diagram.obj (span f g) (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : Diagram.obj (span f g) (inr b0),	                        P (colim (inr b0) x1))	                    then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                    else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                end (Diagram.arr (span f g) g0 x0)) =	             match	               s as s0	               return	                 (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	             with	             | inl a =>	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : Diagram.obj (span f g) (inr b0),	                     P (colim (inr b0) x1))	                 then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                 else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	             end x0)	        with	        | inl a =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inl a) s)	                 (x0 : Diagram.obj (span f g) (inl a)),	                 transport P (colimp (inl a) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a0 =>	                        match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b0),	                            P (colim (inr b0) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 match	                   a as u	                   return	                     (forall x1 : Diagram.obj (span f g) (inl u),	                      P (colim (inl u) x1))	                 with	                 | tt =>	                     fun x1 : Diagram.obj (span f g) (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl a0 =>	                fun g0 : Graph.graph1 span_graph (inl a) (inl a0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inl a0) e x0)	                       (match	                          a0 as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     match	                       a as u	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u),	                          P (colim (inl u) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : Graph.graph1 span_graph (inl a) (inr b) =>	                match	                  g0 as u	                  return	                    (forall x0 : Diagram.obj (span f g) (inl a),	                     transport P (colimp (inl a) (inr b) u x0)	                       ((if b as b0	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b0),	                             P (colim (inr b0) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) u x0)) =	                     match	                       a as u0	                       return	                         (forall x1 : Diagram.obj (span f g) (inl u0),	                          P (colim (inl u0) x1))	                     with	                     | tt =>	                         fun x1 : Diagram.obj (span f g) (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      a as u	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u as u0	                           return (forall x1 : A, P (colim (inl u0) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a0 : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a0) 	                           (r' (g a0))	                           (transport P (colimp (inl tt) (inr true) tt a0)	                              (l' (f a0)))	                           ((pp' a0)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a0)	                              (colimp (inl tt) (inr false) tt a0)^	                              (l' (f a0)))	                    end	                end	            end	        | inr b =>	            fun j : Graph.graph0 span_graph =>	            match	              j as s	              return	                (forall (g0 : Graph.graph1 span_graph (inr b) s)	                 (x0 : Diagram.obj (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return	                        (forall x1 : Diagram.obj (span f g) s0,	                         P (colim s0 x1))	                    with	                    | inl a =>	                        match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : Diagram.obj (span f g) (inr b1),	                            P (colim (inr b1) x1))	                        then	                         fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                        else	                         fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                    end (Diagram.arr (span f g) g0 x0)) =	                 (if b as b0	                   return	                     (forall x1 : Diagram.obj (span f g) (inr b0),	                      P (colim (inr b0) x1))	                  then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                  else fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                   x0)	            with	            | inl a =>	                fun g0 : Graph.graph1 span_graph (inr b) (inl a) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inl a) e x0)	                       (match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (Diagram.arr (span f g) e x0)) =	                     (if b as b0	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b0),	                          P (colim (inr b0) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            | inr b0 =>	                fun g0 : Graph.graph1 span_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : Diagram.obj (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b1),	                             P (colim (inr b1) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) (Diagram.arr (span f g) e x0)) =	                     (if b as b1	                       return	                         (forall x1 : Diagram.obj (span f g) (inr b1),	                          P (colim (inr b1) x1))	                      then	                       fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                      else	                       fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                       x0)	                with	                end	            end	        end) (colim (inr false) (g x)))	    (apD	       (Colimit_ind P	          (fun i : Graph.graph0 span_graph =>	           match	             i as s	             return (forall x0 : Diagram.obj (span f g) s, P (colim s x0))	           with	           | inl a =>	               match	                 a as u	                 return	                   (forall x0 : Diagram.obj (span f g) (inl u),	                    P (colim (inl u) x0))	               with	               | tt =>	                   fun x0 : Diagram.obj (span f g) (inl tt) =>	                   transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	               end	           | inr b =>	               if b as b0	                return	                  (forall x0 : Diagram.obj (span f g) (inr b0),	                   P (colim (inr b0) x0))	               then fun x0 : Diagram.obj (span f g) (inr true) => l' x0	               else fun x0 : Diagram.obj (span f g) (inr false) => r' x0	           end)	          (fun i : Graph.graph0 span_graph =>	           match	             i as s	             return	               (forall (j : Graph.graph0 span_graph)	                (g0 : Graph.graph1 span_graph s j)	                (x0 : Diagram.obj (span f g) s),	                transport P (colimp s j g0 x0)	                  (match	                     j as s0	                     return	                       (forall x1 : Diagram.obj (span f g) s0,	                        P (colim s0 x1))	                   with	                   | inl a =>	                       match	                         a as u	                         return	                           (forall x1 : Diagram.obj (span f g) (inl u),	                            P (colim (inl u) x1))	                       with	                       | tt =>	                           fun x1 : Diagram.obj (span f g) (inl tt) =>	                           transport P (colimp (inl tt) (inr true) tt x1)	                             (l' (f x1))	                       end	                   | inr b =>	                       if b as b0	                        return	                          (forall x1 : Diagram.obj (span f g) (inr b0),	                           P (colim (inr b0) x1))	                       then	                        fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                       else	                        fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                   end (Diagram.arr (span f g) g0 x0)) =	                match	                  s as s0	                  return	                    (forall x1 : Diagram.obj (span f g) s0, P (colim s0 x1))	                with	                | inl a =>	                    match	                      a as u	                      return	                        (forall x1 : Diagram.obj (span f g) (inl u),	                         P (colim (inl u) x1))	                    with	                    | tt =>	                        fun x1 : Diagram.obj (span f g) (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : Diagram.obj (span f g) (inr b0),	                        P (colim (inr b0) x1))	                    then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                    else fun x1 : Diagram.obj (span f g) (inr false) => r' x1	                end x0)	           with	           | inl a =>	               fun j : Graph.graph0 span_graph =>	               match	                 j as s	                 return	                   (forall (g0 : Graph.graph1 span_graph (inl a) s)	                    (x0 : Diagram.obj (span f g) (inl a)),	                    transport P (colimp (inl a) s g0 x0)	                      (match	                         s as s0	                         return	                           (forall x1 : Diagram.obj (span f g) s0,	                            P (colim s0 x1))	                       with	                       | inl a0 =>	                           match	                             a0 as u	                             return	                               (forall x1 : Diagram.obj (span f g) (inl u),	                                P (colim (inl u) x1))	                           with	                           | tt =>	                               fun x1 : Diagram.obj (span f g) (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b =>	                           if b as b0	                            return	                              (forall x1 : Diagram.obj (span f g) (inr b0),	                               P (colim (inr b0) x1))	                           then	                            fun x1 : Diagram.obj (span f g) (inr true) =>	                            l' x1	                           else	                            fun x1 : Diagram.obj (span f g) (inr false) =>	                            r' x1	                       end (Diagram.arr (span f g) g0 x0)) =	                    match	                      a as u	                      return	                        (forall x1 : Diagram.obj (span f g) (inl u),	                         P (colim (inl u) x1))	                    with	                    | tt =>	                        fun x1 : Diagram.obj (span f g) (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end x0)	               with	               | inl a0 =>	                   fun g0 : Graph.graph1 span_graph (inl a) (inl a0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : Diagram.obj (span f g) (inl a),	                        transport P (colimp (inl a) (inl a0) e x0)	                          (match	                             a0 as u	                             return	                               (forall x1 : Diagram.obj (span f g) (inl u),	                                P (colim (inl u) x1))	                           with	                           | tt =>	                               fun x1 : Diagram.obj (span f g) (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (Diagram.arr (span f g) e x0)) =	                        match	                          a as u	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u),	                             P (colim (inl u) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   end	               | inr b =>	                   fun g0 : Graph.graph1 span_graph (inl a) (inr b) =>	                   match	                     g0 as u	                     return	                       (forall x0 : Diagram.obj (span f g) (inl a),	                        transport P (colimp (inl a) (inr b) u x0)	                          ((if b as b0	                             return	                               (forall x1 : Diagram.obj (span f g) (inr b0),	                                P (colim (inr b0) x1))	                            then	                             fun x1 : Diagram.obj (span f g) (inr true) =>	                             l' x1	                            else	                             fun x1 : Diagram.obj (span f g) (inr false) =>	                             r' x1) (Diagram.arr (span f g) u x0)) =	                        match	                          a as u0	                          return	                            (forall x1 : Diagram.obj (span f g) (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : Diagram.obj (span f g) (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   | tt =>	                       match	                         a as u	                         return	                           (forall x0 : A,	                            transport P (colimp (inl u) (inr b) tt x0)	                              ((if b as b0	                                 return	                                   (forall x1 : if b0 then B else C,	                                    P (colim (inr b0) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b as b0	                                    return (Unit -> A -> if b0 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            match	                              u as u0	                              return (forall x1 : A, P (colim (inl u0) x1))	                            with	                            | tt =>	                                fun x1 : A =>	                                transport P	                                  (colimp (inl tt) (inr true) tt x1)	                                  (l' (f x1))	                            end x0)	                       with	                       | tt =>	                           if b as b0	                            return	                              (forall x0 : A,	                               transport P (colimp (inl tt) (inr b0) tt x0)	                                 ((if b0 as b1	                                    return	                                      (forall x1 : if b1 then B else C,	                                       P (colim (inr b1) x1))	                                   then fun x1 : B => l' x1	                                   else fun x1 : C => r' x1)	                                    ((if b0 as b1	                                       return	                                         (Unit -> A -> if b1 then B else C)	                                      then unit_name f	                                      else unit_name g) tt x0)) =	                               transport P (colimp (inl tt) (inr true) tt x0)	                                 (l' (f x0)))	                           then fun x0 : A => 1	                           else	                            fun a0 : A =>	                            moveR_transport_p P	                              (colimp (inl tt) (inr false) tt a0) 	                              (r' (g a0))	                              (transport P (colimp (inl tt) (inr true) tt a0)	                                 (l' (f a0)))	                              ((pp' a0)^ @	                               transport_pp P	                                 (colimp (inl tt) (inr true) tt a0)	                                 (colimp (inl tt) (inr false) tt a0)^	                                 (l' (f a0)))	                       end	                   end	               end	           | inr b =>	               fun j : Graph.graph0 span_graph =>	               match	                 j as s	                 return	                   (forall (g0 : Graph.graph1 span_graph (inr b) s)	                    (x0 : Diagram.obj (span f g) (inr b)),	                    transport P (colimp (inr b) s g0 x0)	                      (match	                         s as s0	                         return	                           (forall x1 : Diagram.obj (span f g) s0,	                            P (colim s0 x1))	                       with	                       | inl a =>	                           match	                             a as u	                             return	                               (forall x1 : Diagram.obj (span f g) (inl u),	                                P (colim (inl u) x1))	                           with	                           | tt =>	                               fun x1 : Diagram.obj (span f g) (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b0 =>	                           if b0 as b1	                            return	                              (forall x1 : Diagram.obj (span f g) (inr b1),	                               P (colim (inr b1) x1))	                           then	                            fun x1 : Diagram.obj (span f g) (inr true) =>	                            l' x1	                           else	                            fun x1 : Diagram.obj (span f g) (inr false) =>	                            r' x1	                       end (Diagram.arr (span f g) g0 x0)) =	                    (if b as b0	                      return	                        (forall x1 : Diagram.obj (span f g) (inr b0),	                         P (colim (inr b0) x1))	                     then fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                     else	                      fun x1 : Diagram.obj (span f g) (inr false) => r' x1)	                      x0)	               with	               | inl a =>	                   fun g0 : Graph.graph1 span_graph (inr b) (inl a) =>	                   match	                     g0 as e	                     return	                       (forall x0 : Diagram.obj (span f g) (inr b),	                        transport P (colimp (inr b) (inl a) e x0)	                          (match	                             a as u	                             return	                               (forall x1 : Diagram.obj (span f g) (inl u),	                                P (colim (inl u) x1))	                           with	                           | tt =>	                               fun x1 : Diagram.obj (span f g) (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (Diagram.arr (span f g) e x0)) =	                        (if b as b0	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b0),	                             P (colim (inr b0) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) x0)	                   with	                   end	               | inr b0 =>	                   fun g0 : Graph.graph1 span_graph (inr b) (inr b0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : Diagram.obj (span f g) (inr b),	                        transport P (colimp (inr b) (inr b0) e x0)	                          ((if b0 as b1	                             return	                               (forall x1 : Diagram.obj (span f g) (inr b1),	                                P (colim (inr b1) x1))	                            then	                             fun x1 : Diagram.obj (span f g) (inr true) =>	                             l' x1	                            else	                             fun x1 : Diagram.obj (span f g) (inr false) =>	                             r' x1) (Diagram.arr (span f g) e x0)) =	                        (if b as b1	                          return	                            (forall x1 : Diagram.obj (span f g) (inr b1),	                             P (colim (inr b1) x1))	                         then	                          fun x1 : Diagram.obj (span f g) (inr true) => l' x1	                         else	                          fun x1 : Diagram.obj (span f g) (inr false) =>	                          r' x1) x0)	                   with	                   end	               end	           end)) (colimp (inl tt) (inr false) tt x))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 264)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       ((pp' x)^ @	        transport_pp P (colimp (inl tt) (inr true) tt x)	          (colimp (inl tt) (inr false) tt x)^ (l' (f x))))^ = 	  pp' x	1 goal (ID 268)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : r' (g x) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       q)^ = pp' x	1 goal (ID 273)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : r' (g x) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @ q^ = pp' x	";
            responses[i]=data;
          

            i = 88;
            data = "1 goal (ID 277)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((pp' x)^ @	   transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 89;
            data = "1 goal (ID 282)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((transport_pp P (colimp (inl tt) (inr true) tt x)	      (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ @ 	   ((pp' x)^)^) = pp' x	";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "<infomsg>PO_rec is defined</infomsg>	1 goal (ID 244)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  ============================	  forall x : A, ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "1 goal (ID 245)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 96;
            data = "1 goal (ID 255)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) =	     legs_comm (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 97;
            data = "1 goal (ID 265)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) =	     legs_comm (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  X0 := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	          (inl tt) (inr false) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr false) tt x) =	     legs_comm (Build_span_cocone l' r' pp') (inl tt) (inr false) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 98;
            data = "1 goal (ID 268)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) = pp' x	  X0 := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	          (inl tt) (inr false) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp')	    (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^) =	  pp' x	";
            responses[i]=data;
          

            i = 99;
            data = "1 goal (ID 295)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) = pp' x	  X0 := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	          (inl tt) (inr false) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr true) tt x) @	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x @ 1	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 306)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) = pp' x	  X0 := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	          (inl tt) (inr false) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 1	";
            responses[i]=data;
          

            i = 101;
            data = "1 goal (ID 318)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	         (inl tt) (inr true) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr true) tt x) = pp' x	  X0 := Colimit_rec_beta_colimp P (Build_span_cocone l' r' pp') 	          (inl tt) (inr false) tt x	   : ap (Colimit_rec P (Build_span_cocone l' r' pp'))	       (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ =	  (ap (Colimit_rec P (Build_span_cocone l' r' pp'))	     (colimp (inl tt) (inr false) tt x))^	";
            responses[i]=data;
          

            i = 102;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "1 goal (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  IsEquiv por	";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "3 goals (ID 276)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO f g -> C		goal 2 (ID 278) is:	 por o ?g == idmap	goal 3 (ID 280) is:	 ?g o por == idmap	";
            responses[i]=data;
          

            i = 111;
            data = "1 goal (ID 276)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO f g -> C	3 goals (ID 296)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  B -> C		goal 2 (ID 298) is:	 C -> C	goal 3 (ID 300) is:	 ?l' o f == ?r' o g	";
            responses[i]=data;
          

            i = 112;
            data = "1 goal (ID 296)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  B -> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 298) is:	 C -> C	goal 2 (ID 300) is:	 g o f^-1 o f == ?r' o g	goal 3 (ID 278) is:	 por o PO_rec C (g o f^-1) ?r' ?pp' == idmap	goal 4 (ID 280) is:	 PO_rec C (g o f^-1) ?r' ?pp' o por == idmap	";
            responses[i]=data;
          

            i = 113;
            data = "1 goal (ID 298)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  C -> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 300) is:	 g o f^-1 o f == idmap o g	goal 2 (ID 278) is:	 por o PO_rec C (g o f^-1) idmap ?pp' == idmap	goal 3 (ID 280) is:	 PO_rec C (g o f^-1) idmap ?pp' o por == idmap	";
            responses[i]=data;
          

            i = 114;
            data = "1 goal (ID 300)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  g o f^-1 o f == idmap o g	1 goal (ID 318)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  x : A	  ============================	  g (f^-1 (f x)) = g x	";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 278) is:	 por o PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) == idmap	goal 2 (ID 280) is:	 PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) o por == idmap	";
            responses[i]=data;
          

            i = 116;
            data = "1 goal (ID 278)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  por o PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) == idmap	3 goals (ID 344)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall b : B, por (g (f^-1 b)) = pol b		goal 2 (ID 345) is:	 forall c : C, por c = por c	goal 3 (ID 346) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) (?Goal (f a)) = ?Goal0 (g a)	";
            responses[i]=data;
          

            i = 117;
            data = "1 goal (ID 344)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall b : B, por (g (f^-1 b)) = pol b	1 goal (ID 347)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  por (g (f^-1 b)) = pol b	";
            responses[i]=data;
          

            i = 118;
            data = "1 goal (ID 359)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  pol (f (f^-1 b)) = pol b	";
            responses[i]=data;
          

            i = 119;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 345) is:	 forall c : C, por c = por c	goal 2 (ID 346) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	 ?Goal (g a)	goal 3 (ID 280) is:	 PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) o por == idmap	";
            responses[i]=data;
          

            i = 120;
            data = "1 goal (ID 345)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall c : C, por c = por c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 346) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	 (fun c : C => 1) (g a)	goal 2 (ID 280) is:	 PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) o por == idmap	";
            responses[i]=data;
          

            i = 121;
            data = "1 goal (ID 346)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall a : A,	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (f^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	  (fun c : C => 1) (g a)	1 goal (ID 368)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (f^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a))) = 1	";
            responses[i]=data;
          

            i = 122;
            data = "1 goal (ID 385)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap	      (fun x : PO f g =>	       por	         (PO_rec C (fun x0 : B => g (f^-1 x0)) idmap	            (fun x0 : A => ap g (eissect f x0)) x)) 	      (popp a))^ @ ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @	  popp a = 1	";
            responses[i]=data;
          

            i = 123;
            data = "1 goal (ID 396)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @ 	  popp a = 1	";
            responses[i]=data;
          

            i = 124;
            data = "1 goal (ID 399)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (f^-1 (f a)))^ @ ap pol (ap f (eissect f a)))) @ 	  popp a = 1	";
            responses[i]=data;
          

            i = 125;
            data = "1 goal (ID 465)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (1 @ ((popp (f^-1 (f a)))^ @ 1)) @ popp (f^-1 (f a)) = 1	";
            responses[i]=data;
          

            i = 126;
            data = "1 goal (ID 476)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (popp (f^-1 (f a)))^ @ popp (f^-1 (f a)) = 1	";
            responses[i]=data;
          

            i = 127;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 280) is:	 PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) o por == idmap	";
            responses[i]=data;
          

            i = 128;
            data = "1 goal (ID 280)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)) o por == idmap	No more goals.	";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "";
            responses[i]=data;
          

            i = 134;
            data = "";
            responses[i]=data;
          

            i = 135;
            data = "";
            responses[i]=data;
          

            i = 136;
            data = "";
            responses[i]=data;
          

            i = 137;
            data = "";
            responses[i]=data;
          

            i = 138;
            data = "";
            responses[i]=data;
          

            i = 139;
            data = "";
            responses[i]=data;
          

            i = 140;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>C is declared</infomsg>	<infomsg>f is declared</infomsg>	<infomsg>g is declared</infomsg>	";
            responses[i]=data;
          

            i = 141;
            data = "1 goal (ID 7)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_PO f g (Pushout f g)	";
            responses[i]=data;
          

            i = 142;
            data = "";
            responses[i]=data;
          

            i = 143;
            data = "2 goals (ID 26)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  Cocone (span f g) (Pushout f g)		goal 2 (ID 28) is:	 UniversalCocone ?C	";
            responses[i]=data;
          

            i = 144;
            data = "1 goal (ID 26)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  Cocone (span f g) (Pushout f g)	3 goals (ID 67)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  B -> Pushout f g		goal 2 (ID 69) is:	 C -> Pushout f g	goal 3 (ID 71) is:	 ?inl' o f == ?inr' o g	";
            responses[i]=data;
          

            i = 145;
            data = "1 goal (ID 67)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  B -> Pushout f g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 69) is:	 C -> Pushout f g	goal 2 (ID 71) is:	 push o inl o f == ?inr' o g	goal 3 (ID 28) is:	 UniversalCocone (Build_span_cocone (push o inl) ?inr' ?pp')	";
            responses[i]=data;
          

            i = 146;
            data = "1 goal (ID 69)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  C -> Pushout f g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 71) is:	 push o inl o f == push o inr o g	goal 2 (ID 28) is:	 UniversalCocone (Build_span_cocone (push o inl) (push o inr) ?pp')	";
            responses[i]=data;
          

            i = 147;
            data = "1 goal (ID 71)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  push o inl o f == push o inr o g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 28) is:	 UniversalCocone (Build_span_cocone (push o inl) (push o inr) pglue)	";
            responses[i]=data;
          

            i = 148;
            data = "1 goal (ID 28)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  UniversalCocone (Build_span_cocone (push o inl) (push o inr) pglue)	1 goal (ID 129)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  forall Y : Type,	  IsEquiv	    (cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue))	";
            responses[i]=data;
          

            i = 149;
            data = "3 goals (ID 401)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Cocone (span f g) Y -> Pushout f g -> Y		goal 2 (ID 403) is:	 cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) o ?g ==	 idmap	goal 3 (ID 405) is:	 ?g o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 150;
            data = "1 goal (ID 401)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Cocone (span f g) Y -> Pushout f g -> Y	1 goal (ID 406)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : Cocone (span f g) Y	  ============================	  Pushout f g -> Y	";
            responses[i]=data;
          

            i = 151;
            data = "3 goals (ID 447)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : Cocone (span f g) Y	  ============================	  B -> Y		goal 2 (ID 449) is:	 C -> Y	goal 3 (ID 451) is:	 forall a : A, ?pushb (f a) = ?pushc (g a)	";
            responses[i]=data;
          

            i = 152;
            data = "1 goal (ID 447)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : Cocone (span f g) Y	  ============================	  B -> Y	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	4 goals		goal 1 (ID 449) is:	 C -> Y	goal 2 (ID 451) is:	 forall a : A, pol' Co (f a) = ?pushc (g a)	goal 3 (ID 403) is:	 cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue)	 o (fun Co : Cocone (span f g) Y => Pushout_rec Y (pol' Co) ?pushc ?pusha) ==	 idmap	goal 4 (ID 405) is:	 (fun Co : Cocone (span f g) Y => Pushout_rec Y (pol' Co) ?pushc ?pusha)	 o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 449)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : Cocone (span f g) Y	  ============================	  C -> Y	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 451) is:	 forall a : A, pol' Co (f a) = por' Co (g a)	goal 2 (ID 403) is:	 cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue)	 o (fun Co : Cocone (span f g) Y => Pushout_rec Y (pol' Co) (por' Co) ?pusha) ==	 idmap	goal 3 (ID 405) is:	 (fun Co : Cocone (span f g) Y => Pushout_rec Y (pol' Co) (por' Co) ?pusha)	 o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 154;
            data = "1 goal (ID 451)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : Cocone (span f g) Y	  ============================	  forall a : A, pol' Co (f a) = por' Co (g a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 403) is:	 cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue)	 o (fun Co : Cocone (span f g) Y =>	    Pushout_rec Y (pol' Co) (por' Co) (popp' Co)) == idmap	goal 2 (ID 405) is:	 (fun Co : Cocone (span f g) Y =>	  Pushout_rec Y (pol' Co) (por' Co) (popp' Co))	 o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 155;
            data = "1 goal (ID 403)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue)	  o (fun Co : Cocone (span f g) Y =>	     Pushout_rec Y (pol' Co) (por' Co) (popp' Co)) == idmap	1 goal (ID 475)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  ============================	  cocone_postcompose	    (Build_span_cocone (fun x : B => push (inl x))	       (fun x : C => push (inr x)) pglue)	    (Pushout_rec Y (pol' {| legs := Co; legs_comm := Co' |})	       (por' {| legs := Co; legs_comm := Co' |})	       (popp' {| legs := Co; legs_comm := Co' |})) =	  {| legs := Co; legs_comm := Co' |}	";
            responses[i]=data;
          

            i = 156;
            data = "2 goals (ID 524)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   Pushout_rec Y (Co (inr true)) (Co (inr false))	     (popp' {| legs := Co; legs_comm := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> Pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> Pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i		goal 2 (ID 525) is:	 forall (i j : Unit + Bool)	 (g0 : match i with	       | inl _ =>	           fun X : Unit + Bool =>	           match X with	           | inl _ => Empty	           | inr _ => Unit	           end	       | inr _ =>	           fun X : Unit + Bool => match X with	                                  | inl _ | _ => Empty	                                  end	       end j)	 (x : match i with	      | inl _ => A	      | inr true => B	      | inr false => C	      end),	 ap	   (Pushout_rec Y (Co (inr true)) (Co (inr false))	      (popp' {| legs := Co; legs_comm := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	         (g1 : match s with	               | inl _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ => Empty	                   | inr _ => Unit	                   end	               | inr _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ | _ => Empty	                   end	               end j0),	         (fun	            x0 : match s with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end =>	          match	            j0 as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> Pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> Pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end	            (match	               s as s0	               return	                 (forall j1 : Unit + Bool,	                  match s0 with	                  | inl _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Unit	                      end	                  | inr _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ | _ => Empty	                      end	                  end j1 ->	                  match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end ->	                  match j1 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end)	             with	             | inl _ =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b =>	                     fun u : Unit =>	                     (if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u	                 end	             | inr b =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b0 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if b0 then B else C) u	                 end	             end j0 g1 x0)) ==	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> Pushout f g)	         with	         | inl _ => fun x0 : A => push (inr (g x0))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> Pushout f g)	             then fun x0 : B => push (inl x0)	             else fun x0 : C => push (inr x0)	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall g1 : match s with	                         | inl _ => Empty	                         | inr _ => Unit	                         end,	             (fun x0 : A =>	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> Pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b =>	                  if b as b0 return ((if b0 then B else C) -> Pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b =>	                     fun u : Unit =>	                     (if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u	                 end g1 x0)) == (fun x0 : A => push (inr (g x0))))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : A =>	                  push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                 (fun x0 : A => push (inr (g x0))))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u	              return	                ((fun x0 : A =>	                  (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    ((if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u x0)) ==	                 (fun x0 : A => push (inr (g x0))))	            with	            | tt =>	                if b as b0	                 return	                   ((fun x0 : A =>	                     (if b0 as b1	                       return ((if b1 then B else C) -> Pushout f g)	                      then fun x1 : B => push (inl x1)	                      else fun x1 : C => push (inr x1))	                       ((if b0 as b1	                          return (Unit -> A -> if b1 then B else C)	                         then unit_name f	                         else unit_name g) tt x0)) ==	                    (fun x0 : A => push (inr (g x0))))	                then pglue	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall g1 : match s with	                         | inl _ | _ => Empty	                         end,	             (fun x0 : if b then B else C =>	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> Pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b0 =>	                  if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b0 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if b0 then B else C) u	                 end g1 x0)) ==	             (if b as b0 return ((if b0 then B else C) -> Pushout f g)	              then fun x0 : B => push (inl x0)	              else fun x0 : C => push (inr x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : if b then B else C =>	                  push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                 (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                  then fun x0 : B => push (inl x0)	                  else fun x0 : C => push (inr x0)))	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : if b then B else C =>	                  (if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    (Empty_rect (fun _ : Empty => if b0 then B else C) e)) ==	                 (if b as b1 return ((if b1 then B else C) -> Pushout f g)	                  then fun x0 : B => push (inl x0)	                  else fun x0 : C => push (inr x0)))	            with	            end	        end	    end j g0 x) @ ?Goal i x =	 ?Goal j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool => match X with	                                    | inl _ | _ => Empty	                                    end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr b =>	            fun u : Unit =>	            (if b as b0 return (Unit -> A -> if b0 then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ | _ => Empty	             end ->	             (if b then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if b then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr b0 =>	            fun (u : Empty) (_ : if b then B else C) =>	            Empty_rect (fun _ : Empty => if b0 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	";
            responses[i]=data;
          

            i = 157;
            data = "1 goal (ID 524)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   Pushout_rec Y (Co (inr true)) (Co (inr false))	     (popp' {| legs := Co; legs_comm := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> Pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> Pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i	3 goals (ID 545)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : A	  ============================	  Co (inr false) (g x) = Co (inl tt) x		goal 2 (ID 546) is:	 Co (inr true) x = Co (inr true) x	goal 3 (ID 547) is:	 Co (inr false) x = Co (inr false) x	";
            responses[i]=data;
          

            i = 158;
            data = "2 goals (ID 546)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : B	  ============================	  Co (inr true) x = Co (inr true) x		goal 2 (ID 547) is:	 Co (inr false) x = Co (inr false) x	";
            responses[i]=data;
          

            i = 159;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 525) is:	 forall (i j : Unit + Bool)	 (g0 : match i with	       | inl _ =>	           fun X : Unit + Bool =>	           match X with	           | inl _ => Empty	           | inr _ => Unit	           end	       | inr _ =>	           fun X : Unit + Bool => match X with	                                  | inl _ | _ => Empty	                                  end	       end j)	 (x : match i with	      | inl _ => A	      | inr true => B	      | inr false => C	      end),	 ap	   (Pushout_rec Y (Co (inr true)) (Co (inr false))	      (popp' {| legs := Co; legs_comm := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	         (g1 : match s with	               | inl _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ => Empty	                   | inr _ => Unit	                   end	               | inr _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ | _ => Empty	                   end	               end j0),	         (fun	            x0 : match s with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end =>	          match	            j0 as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> Pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> Pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end	            (match	               s as s0	               return	                 (forall j1 : Unit + Bool,	                  match s0 with	                  | inl _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Unit	                      end	                  | inr _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ | _ => Empty	                      end	                  end j1 ->	                  match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end ->	                  match j1 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end)	             with	             | inl _ =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b =>	                     fun u : Unit =>	                     (if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u	                 end	             | inr b =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b0 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if b0 then B else C) u	                 end	             end j0 g1 x0)) ==	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> Pushout f g)	         with	         | inl _ => fun x0 : A => push (inr (g x0))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> Pushout f g)	             then fun x0 : B => push (inl x0)	             else fun x0 : C => push (inr x0)	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall g1 : match s with	                         | inl _ => Empty	                         | inr _ => Unit	                         end,	             (fun x0 : A =>	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> Pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b =>	                  if b as b0 return ((if b0 then B else C) -> Pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b =>	                     fun u : Unit =>	                     (if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u	                 end g1 x0)) == (fun x0 : A => push (inr (g x0))))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : A =>	                  push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                 (fun x0 : A => push (inr (g x0))))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u	              return	                ((fun x0 : A =>	                  (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    ((if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u x0)) ==	                 (fun x0 : A => push (inr (g x0))))	            with	            | tt =>	                if b as b0	                 return	                   ((fun x0 : A =>	                     (if b0 as b1	                       return ((if b1 then B else C) -> Pushout f g)	                      then fun x1 : B => push (inl x1)	                      else fun x1 : C => push (inr x1))	                       ((if b0 as b1	                          return (Unit -> A -> if b1 then B else C)	                         then unit_name f	                         else unit_name g) tt x0)) ==	                    (fun x0 : A => push (inr (g x0))))	                then pglue	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall g1 : match s with	                         | inl _ | _ => Empty	                         end,	             (fun x0 : if b then B else C =>	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> Pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b0 =>	                  if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr b0 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if b0 then B else C) u	                 end g1 x0)) ==	             (if b as b0 return ((if b0 then B else C) -> Pushout f g)	              then fun x0 : B => push (inl x0)	              else fun x0 : C => push (inr x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : if b then B else C =>	                  push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                 (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                  then fun x0 : B => push (inl x0)	                  else fun x0 : C => push (inr x0)))	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                ((fun _ : if b then B else C =>	                  (if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    (Empty_rect (fun _ : Empty => if b0 then B else C) e)) ==	                 (if b as b1 return ((if b1 then B else C) -> Pushout f g)	                  then fun x0 : B => push (inl x0)	                  else fun x0 : C => push (inr x0)))	            with	            end	        end	    end j g0 x) @	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        Pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| legs := Co; legs_comm := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> Pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> Pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl a =>	      (fun u : Unit =>	       match	         u as u0	         return	           ((fun x0 : A =>	             Pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| legs := Co; legs_comm := Co' |}) 	               (push (inr (g x0)))) == Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1	        return	          ((fun x0 : if b1 then B else C =>	            Pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| legs := Co; legs_comm := Co' |})	              ((if b1 as b2 return ((if b2 then B else C) -> Pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b1))	       then fun x0 : B => 1	       else fun x0 : C => 1) b	  end) i x =	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        Pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| legs := Co; legs_comm := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> Pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> Pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl a =>	      (fun u : Unit =>	       match	         u as u0	         return	           ((fun x0 : A =>	             Pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| legs := Co; legs_comm := Co' |}) 	               (push (inr (g x0)))) == Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end) a	  | inr b =>	      (fun b0 : Bool =>	       if b0 as b1	        return	          ((fun x0 : if b1 then B else C =>	            Pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| legs := Co; legs_comm := Co' |})	              ((if b1 as b2 return ((if b2 then B else C) -> Pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b1))	       then fun x0 : B => 1	       else fun x0 : C => 1) b	  end) j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool => match X with	                                    | inl _ | _ => Empty	                                    end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr b =>	            fun u : Unit =>	            (if b as b0 return (Unit -> A -> if b0 then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ | _ => Empty	             end ->	             (if b then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if b then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr b0 =>	            fun (u : Empty) (_ : if b then B else C) =>	            Empty_rect (fun _ : Empty => if b0 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	goal 2 (ID 405) is:	 (fun Co : Cocone (span f g) Y =>	  Pushout_rec Y (pol' Co) (por' Co) (popp' Co))	 o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 160;
            data = "1 goal (ID 525)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  ============================	  forall (i j : Unit + Bool)	  (g0 : match i with	        | inl _ =>	            fun X : Unit + Bool =>	            match X with	            | inl _ => Empty	            | inr _ => Unit	            end	        | inr _ =>	            fun X : Unit + Bool => match X with	                                   | inl _ | _ => Empty	                                   end	        end j)	  (x : match i with	       | inl _ => A	       | inr true => B	       | inr false => C	       end),	  ap	    (Pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| legs := Co; legs_comm := Co' |}))	    (match	       i as s	       return	         (forall (j0 : Unit + Bool)	          (g1 : match s with	                | inl _ =>	                    fun X : Unit + Bool =>	                    match X with	                    | inl _ => Empty	                    | inr _ => Unit	                    end	                | inr _ =>	                    fun X : Unit + Bool =>	                    match X with	                    | inl _ | _ => Empty	                    end	                end j0),	          (fun	             x0 : match s with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end =>	           match	             j0 as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> Pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> Pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end	             (match	                s as s0	                return	                  (forall j1 : Unit + Bool,	                   match s0 with	                   | inl _ =>	                       fun X : Unit + Bool =>	                       match X with	                       | inl _ => Empty	                       | inr _ => Unit	                       end	                   | inr _ =>	                       fun X : Unit + Bool =>	                       match X with	                       | inl _ | _ => Empty	                       end	                   end j1 ->	                   match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end ->	                   match j1 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end)	              with	              | inl _ =>	                  fun j1 : Unit + Bool =>	                  match	                    j1 as s0	                    return	                      (match s0 with	                       | inl _ => Empty	                       | inr _ => Unit	                       end ->	                       A ->	                       match s0 with	                       | inl _ => A	                       | inr true => B	                       | inr false => C	                       end)	                  with	                  | inl _ =>	                      fun (u : Empty) (_ : A) =>	                      Empty_rect (fun _ : Empty => A) u	                  | inr b =>	                      fun u : Unit =>	                      (if b as b0 return (Unit -> A -> if b0 then B else C)	                       then unit_name f	                       else unit_name g) u	                  end	              | inr b =>	                  fun j1 : Unit + Bool =>	                  match	                    j1 as s0	                    return	                      (match s0 with	                       | inl _ | _ => Empty	                       end ->	                       (if b then B else C) ->	                       match s0 with	                       | inl _ => A	                       | inr true => B	                       | inr false => C	                       end)	                  with	                  | inl _ =>	                      fun (u : Empty) (_ : if b then B else C) =>	                      Empty_rect (fun _ : Empty => A) u	                  | inr b0 =>	                      fun (u : Empty) (_ : if b then B else C) =>	                      Empty_rect (fun _ : Empty => if b0 then B else C) u	                  end	              end j0 g1 x0)) ==	          match	            s as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> Pushout f g)	          with	          | inl _ => fun x0 : A => push (inr (g x0))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> Pushout f g)	              then fun x0 : B => push (inl x0)	              else fun x0 : C => push (inr x0)	          end)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end,	              (fun x0 : A =>	               match	                 s as s0	                 return	                   (match s0 with	                    | inl _ => A	                    | inr true => B	                    | inr false => C	                    end -> Pushout f g)	               with	               | inl _ => fun x1 : A => push (inr (g x1))	               | inr b =>	                   if b as b0 return ((if b0 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)	               end	                 (match	                    s as s0	                    return	                      (match s0 with	                       | inl _ => Empty	                       | inr _ => Unit	                       end ->	                       A ->	                       match s0 with	                       | inl _ => A	                       | inr true => B	                       | inr false => C	                       end)	                  with	                  | inl _ =>	                      fun (u : Empty) (_ : A) =>	                      Empty_rect (fun _ : Empty => A) u	                  | inr b =>	                      fun u : Unit =>	                      (if b as b0 return (Unit -> A -> if b0 then B else C)	                       then unit_name f	                       else unit_name g) u	                  end g1 x0)) == (fun x0 : A => push (inr (g x0))))	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 ((fun _ : A =>	                   push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                  (fun x0 : A => push (inr (g x0))))	             with	             end	         | inr b =>	             fun g1 : Unit =>	             match	               g1 as u	               return	                 ((fun x0 : A =>	                   (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                    then fun x1 : B => push (inl x1)	                    else fun x1 : C => push (inr x1))	                     ((if b as b0 return (Unit -> A -> if b0 then B else C)	                       then unit_name f	                       else unit_name g) u x0)) ==	                  (fun x0 : A => push (inr (g x0))))	             with	             | tt =>	                 if b as b0	                  return	                    ((fun x0 : A =>	                      (if b0 as b1	                        return ((if b1 then B else C) -> Pushout f g)	                       then fun x1 : B => push (inl x1)	                       else fun x1 : C => push (inr x1))	                        ((if b0 as b1	                           return (Unit -> A -> if b1 then B else C)	                          then unit_name f	                          else unit_name g) tt x0)) ==	                     (fun x0 : A => push (inr (g x0))))	                 then pglue	                 else fun x0 : A => 1	             end	         end	     | inr b =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall g1 : match s with	                          | inl _ | _ => Empty	                          end,	              (fun x0 : if b then B else C =>	               match	                 s as s0	                 return	                   (match s0 with	                    | inl _ => A	                    | inr true => B	                    | inr false => C	                    end -> Pushout f g)	               with	               | inl _ => fun x1 : A => push (inr (g x1))	               | inr b0 =>	                   if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)	               end	                 (match	                    s as s0	                    return	                      (match s0 with	                       | inl _ | _ => Empty	                       end ->	                       (if b then B else C) ->	                       match s0 with	                       | inl _ => A	                       | inr true => B	                       | inr false => C	                       end)	                  with	                  | inl _ =>	                      fun (u : Empty) (_ : if b then B else C) =>	                      Empty_rect (fun _ : Empty => A) u	                  | inr b0 =>	                      fun (u : Empty) (_ : if b then B else C) =>	                      Empty_rect (fun _ : Empty => if b0 then B else C) u	                  end g1 x0)) ==	              (if b as b0 return ((if b0 then B else C) -> Pushout f g)	               then fun x0 : B => push (inl x0)	               else fun x0 : C => push (inr x0)))	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 ((fun _ : if b then B else C =>	                   push (inr (g (Empty_rect (fun _ : Empty => A) e)))) ==	                  (if b as b0 return ((if b0 then B else C) -> Pushout f g)	                   then fun x0 : B => push (inl x0)	                   else fun x0 : C => push (inr x0)))	             with	             end	         | inr b0 =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 ((fun _ : if b then B else C =>	                   (if b0 as b1 return ((if b1 then B else C) -> Pushout f g)	                    then fun x1 : B => push (inl x1)	                    else fun x1 : C => push (inr x1))	                     (Empty_rect (fun _ : Empty => if b0 then B else C) e)) ==	                  (if b as b1 return ((if b1 then B else C) -> Pushout f g)	                   then fun x0 : B => push (inl x0)	                   else fun x0 : C => push (inr x0)))	             with	             end	         end	     end j g0 x) @	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         Pushout_rec Y (Co (inr true)) (Co (inr false))	           (popp' {| legs := Co; legs_comm := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> Pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> Pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl a =>	       (fun u : Unit =>	        match	          u as u0	          return	            ((fun x0 : A =>	              Pushout_rec Y (Co (inr true)) (Co (inr false))	                (popp' {| legs := Co; legs_comm := Co' |})	                (push (inr (g x0)))) == Co (inl u0))	        with	        | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	        end) a	   | inr b =>	       (fun b0 : Bool =>	        if b0 as b1	         return	           ((fun x0 : if b1 then B else C =>	             Pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| legs := Co; legs_comm := Co' |})	               ((if b1 as b2 return ((if b2 then B else C) -> Pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)) x0)) == 	            Co (inr b1))	        then fun x0 : B => 1	        else fun x0 : C => 1) b	   end) i x =	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         Pushout_rec Y (Co (inr true)) (Co (inr false))	           (popp' {| legs := Co; legs_comm := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> Pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> Pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl a =>	       (fun u : Unit =>	        match	          u as u0	          return	            ((fun x0 : A =>	              Pushout_rec Y (Co (inr true)) (Co (inr false))	                (popp' {| legs := Co; legs_comm := Co' |})	                (push (inr (g x0)))) == Co (inl u0))	        with	        | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	        end) a	   | inr b =>	       (fun b0 : Bool =>	        if b0 as b1	         return	           ((fun x0 : if b1 then B else C =>	             Pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| legs := Co; legs_comm := Co' |})	               ((if b1 as b2 return ((if b2 then B else C) -> Pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)) x0)) == 	            Co (inr b1))	        then fun x0 : B => 1	        else fun x0 : C => 1) b	   end) j	    (match	       i as s	       return	         (forall j0 : Unit + Bool,	          match s with	          | inl _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Unit	              end	          | inr _ =>	              fun X : Unit + Bool => match X with	                                     | inl _ | _ => Empty	                                     end	          end j0 ->	          match s with	          | inl _ => A	          | inr true => B	          | inr false => C	          end ->	          match j0 with	          | inl _ => A	          | inr true => B	          | inr false => C	          end)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ => Empty	              | inr _ => Unit	              end ->	              A ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	         | inr b =>	             fun u : Unit =>	             (if b as b0 return (Unit -> A -> if b0 then B else C)	              then unit_name f	              else unit_name g) u	         end	     | inr b =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ | _ => Empty	              end ->	              (if b then B else C) ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : if b then B else C) =>	             Empty_rect (fun _ : Empty => A) u	         | inr b0 =>	             fun (u : Empty) (_ : if b then B else C) =>	             Empty_rect (fun _ : Empty => if b0 then B else C) u	         end	     end j g0 x) @ Co' i j g0 x	2 goals (ID 621)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : A	  ============================	  ap	    (Pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| legs := Co; legs_comm := Co' |})) 	    (pglue x) @ Co' (inl tt) (inr false) tt x =	  1 @ Co' (inl tt) (inr true) tt x		goal 2 (ID 622) is:	 1 @ Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr false) tt x	";
            responses[i]=data;
          

            i = 161;
            data = "1 goal (ID 621)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : A	  ============================	  ap	    (Pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| legs := Co; legs_comm := Co' |})) 	    (pglue x) @ Co' (inl tt) (inr false) tt x =	  1 @ Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 162;
            data = "1 goal (ID 638)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : A	  ============================	  ap	    (Pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| legs := Co; legs_comm := Co' |})) 	    (pglue x) @ Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 163;
            data = "1 goal (ID 644)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : Graph.graph0 span_graph, Diagram.obj (span f g) i -> Y	  Co' : forall (i j : Graph.graph0 span_graph)	        (g0 : Graph.graph1 span_graph i j),	        (fun x : Diagram.obj (span f g) i =>	         Co j (Diagram.arr (span f g) g0 x)) == Co i	  x : A	  ============================	  popp' {| legs := Co; legs_comm := Co' |} x @ Co' (inl tt) (inr false) tt x =	  Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 164;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 405) is:	 (fun Co : Cocone (span f g) Y =>	  Pushout_rec Y (pol' Co) (por' Co) (popp' Co))	 o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	 idmap	";
            responses[i]=data;
          

            i = 165;
            data = "1 goal (ID 405)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  (fun Co : Cocone (span f g) Y =>	   Pushout_rec Y (pol' Co) (por' Co) (popp' Co))	  o cocone_postcompose (Build_span_cocone (push o inl) (push o inr) pglue) ==	  idmap	1 goal (ID 772)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  ============================	  Pushout_rec Y	    (pol'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h))	    (por'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h))	    (popp'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h)) = h	";
            responses[i]=data;
          

            i = 166;
            data = "1 goal (ID 776)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  ============================	  Pushout_rec Y	    (pol'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h))	    (por'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h))	    (popp'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h)) == h	";
            responses[i]=data;
          

            i = 167;
            data = "3 goals (ID 822)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  ============================	  forall b : B,	  Pushout_rec Y (fun x : B => h (push (inl x)))	    (fun x : C => h (push (inr x)))	    (popp'	       (cocone_postcompose	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pglue) h)) 	    (pushl b) = h (pushl b)		goal 2 (ID 823) is:	 forall c : C,	 Pushout_rec Y (fun x : B => h (push (inl x)))	   (fun x : C => h (push (inr x)))	   (popp'	      (cocone_postcompose	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pglue) h)) 	   (pushr c) = h (pushr c)	goal 3 (ID 824) is:	 forall a : A,	 transport	   (fun w : Pushout f g =>	    Pushout_rec Y (fun x : B => h (push (inl x)))	      (fun x : C => h (push (inr x)))	      (popp'	         (cocone_postcompose	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pglue) h)) w = 	    h w) (pglue a) (?Goal (f a)) = ?Goal0 (g a)	";
            responses[i]=data;
          

            i = 168;
            data = "1 goal (ID 824)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  ============================	  forall a : A,	  transport	    (fun w : Pushout f g =>	     Pushout_rec Y (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x)))	       (popp'	          (cocone_postcompose	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pglue) h)) w = 	     h w) (pglue a) ((fun b : B => 1) (f a)) = (fun c : C => 1) (g a)	";
            responses[i]=data;
          

            i = 169;
            data = "1 goal (ID 830)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  a : A	  ============================	  transport	    (fun w : Pushout f g =>	     Pushout_rec Y (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x)))	       (popp'	          (cocone_postcompose	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pglue) h)) w = 	     h w) (pglue a) 1 = 1	";
            responses[i]=data;
          

            i = 170;
            data = "1 goal (ID 847)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  a : A	  ============================	  (ap	     (Pushout_rec Y (fun x : B => h (push (inl x)))	        (fun x : C => h (push (inr x)))	        (popp'	           (cocone_postcompose	              (Build_span_cocone (fun x : B => push (inl x))	                 (fun x : C => push (inr x)) pglue) h))) 	     (pglue a))^ @ ap h (pglue a) = 1	";
            responses[i]=data;
          

            i = 171;
            data = "1 goal (ID 856)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  a : A	  ============================	  (popp'	     (cocone_postcompose	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pglue) h) a)^ @ 	  ap h (pglue a) = 1	";
            responses[i]=data;
          

            i = 172;
            data = "1 goal (ID 866)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  a : A	  ============================	  ap h (pglue a) =	  popp'	    (cocone_postcompose	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pglue) h) a @ 1	";
            responses[i]=data;
          

            i = 173;
            data = "1 goal (ID 867)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : Pushout f g -> Y	  a : A	  ============================	  ap h (pglue a) =	  (legs_comm	     (cocone_postcompose	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pglue) h) (inl tt) 	     (inr true) tt a @	   (legs_comm	      (cocone_postcompose	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pglue) h) 	      (inl tt) (inr false) tt a)^) @ 1	";
            responses[i]=data;
          

            i = 174;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "1 goal (ID 14)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  Pushout f g <~> PO f g	";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "4 goals (ID 31)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  Graph.Graph		goal 2 (ID 32) is:	 Diagram.Diagram ?G	goal 3 (ID 36) is:	 IsColimit ?D (Pushout f g)	goal 4 (ID 38) is:	 IsColimit ?D (PO f g)	";
            responses[i]=data;
          

            i = 179;
            data = "1 goal (ID 38)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  IsColimit (span f g) (PO f g)	";
            responses[i]=data;
          

            i = 180;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "";
            responses[i]=data;
          

            i = 186;
            data = "";
            responses[i]=data;
          

            i = 187;
            data = "";
            responses[i]=data;
          

            i = 188;
            data = "";
            responses[i]=data;
          

            i = 189;
            data = "";
            responses[i]=data;
          

            i = 190;
            data = "";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Colimits.Colimit_Pushout</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Span.html#"><span class="id" title="library">Diagrams.Span</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#"><span class="id" title="library">Diagrams.Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(11, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Require</span> <a class="idref" href="HoTT.Colimits.Pushout.html#"><span class="id" title="library">Colimits.Pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(12, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(13, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a id="lab513"></a><h1 class="section">Pushout as a colimit</h1>
<div class="doc" scenenumber="4"> </div>

 In this file, we define <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a></span> the pushout of two maps as the colimit of a particular diagram, and then show that it is equivalent to <span class="inlinecode"><span class="id" title="var">pushout</span></span> the primitive pushout defined as an HIT. 
<div class="doc" scenenumber="10"> </div>
<a id="lab514"></a><h2 class="section"><span class="inlinecode"><a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a></span></h2>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      ">
<span class="id" title="keyword">Section</span> <a id="PO" class="idref" href="#PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> {<a id="A:1" class="idref" href="#A:1"><span class="id" title="binder">A</span></a> <a id="B:2" class="idref" href="#B:2"><span class="id" title="binder">B</span></a> <a id="C:3" class="idref" href="#C:3"><span class="id" title="binder">C</span></a> : <span class="id" title="keyword">Type</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="Build_span_cocone" class="idref" href="#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> {<a id="f:4" class="idref" href="#f:4"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<a id="g:5" class="idref" href="#g:5"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<a id="Z:6" class="idref" href="#Z:6"><span class="id" title="binder">Z</span></a> : <span class="id" title="keyword">Type</span>}<br>
             (<a id="inl':7" class="idref" href="#inl':7"><span class="id" title="binder">inl'</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:6"><span class="id" title="variable">Z</span></a>) (<a id="inr':8" class="idref" href="#inr':8"><span class="id" title="binder">inr'</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:6"><span class="id" title="variable">Z</span></a>)<br>
             (<a id="pp':9" class="idref" href="#pp':9"><span class="id" title="binder">pp'</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#inl':7"><span class="id" title="variable">inl'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:4"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#inr':8"><span class="id" title="variable">inr'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:5"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Diagrams.Cocone.html#Cocone"><span class="id" title="class">Cocone</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:4"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:5"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:6"><span class="id" title="variable">Z</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
    - <span class="id" title="tactic">intros</span> [|[]]; [ <span class="id" title="tactic">exact</span> (<span class="id" title="var">inr'</span> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <span class="id" title="var">g</span>) | <span class="id" title="tactic">exact</span> <span class="id" title="var">inl'</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">inr'</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
      + <span class="id" title="tactic">exact</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(42, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="pol'" class="idref" href="#pol'"><span class="id" title="definition">pol'</span></a> {<a id="f:10" class="idref" href="#f:10"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<a id="g:11" class="idref" href="#g:11"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<a id="Z:12" class="idref" href="#Z:12"><span class="id" title="binder">Z</span></a>} (<a id="Co:13" class="idref" href="#Co:13"><span class="id" title="binder">Co</span></a> : <a class="idref" href="HoTT.Diagrams.Cocone.html#Cocone"><span class="id" title="class">Cocone</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:10"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:11"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:12"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:12"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.Diagrams.Cocone.html#legs"><span class="id" title="method">legs</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:13"><span class="id" title="variable">Co</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(43, '0_3_7');
      "><br>
  <span class="id" title="keyword">Definition</span> <a id="por'" class="idref" href="#por'"><span class="id" title="definition">por'</span></a> {<a id="f:14" class="idref" href="#f:14"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<a id="g:15" class="idref" href="#g:15"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<a id="Z:16" class="idref" href="#Z:16"><span class="id" title="binder">Z</span></a>} (<a id="Co:17" class="idref" href="#Co:17"><span class="id" title="binder">Co</span></a> : <a class="idref" href="HoTT.Diagrams.Cocone.html#Cocone"><span class="id" title="class">Cocone</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:14"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:15"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:16"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:16"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.Diagrams.Cocone.html#legs"><span class="id" title="method">legs</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:17"><span class="id" title="variable">Co</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(44, '0_3_7');
      "><br>
  <span class="id" title="keyword">Definition</span> <a id="popp'" class="idref" href="#popp'"><span class="id" title="definition">popp'</span></a> {<a id="f:18" class="idref" href="#f:18"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<a id="g:19" class="idref" href="#g:19"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<a id="Z:20" class="idref" href="#Z:20"><span class="id" title="binder">Z</span></a>} (<a id="Co:21" class="idref" href="#Co:21"><span class="id" title="binder">Co</span></a> : <a class="idref" href="HoTT.Diagrams.Cocone.html#Cocone"><span class="id" title="class">Cocone</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:18"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:19"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Z:20"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:21"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:18"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por'"><span class="id" title="definition">por'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:21"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:19"><span class="id" title="variable">g</span></a><br>
    := <span class="id" title="keyword">fun</span> <a id="x:22" class="idref" href="#x:22"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Diagrams.Cocone.html#legs_comm"><span class="id" title="method">legs_comm</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:21"><span class="id" title="variable">Co</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:22"><span class="id" title="variable">x</span></a><br>
                <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Diagrams.Cocone.html#legs_comm"><span class="id" title="method">legs_comm</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Co:21"><span class="id" title="variable">Co</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:22"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(45, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="is_PO" class="idref" href="#is_PO"><span class="id" title="definition">is_PO</span></a> (<a id="f:23" class="idref" href="#f:23"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<a id="g:24" class="idref" href="#g:24"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.Colimits.Colimit.html#IsColimit"><span class="id" title="class">IsColimit</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:23"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:24"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(46, '0_3_7');
      "><br>
  <span class="id" title="keyword">Definition</span> <a id="PO" class="idref" href="#PO"><span class="id" title="definition">PO</span></a> (<a id="f:25" class="idref" href="#f:25"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<a id="g:26" class="idref" href="#g:26"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#f:25"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#g:26"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(47, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> {<a id="f:27" class="idref" href="#f:27"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<a id="g:28" class="idref" href="#g:28"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(48, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="pol" class="idref" href="#pol"><span class="id" title="definition">pol</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(49, '0_3_7');
      "><br>
  <span class="id" title="keyword">Definition</span> <a id="por" class="idref" href="#por"><span class="id" title="definition">por</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(50, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="popp" class="idref" href="#popp"><span class="id" title="definition">popp</span></a> (<a id="a:29" class="idref" href="#a:29"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pol"><span class="id" title="definition">pol</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:29"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por"><span class="id" title="definition">por</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:29"><span class="id" title="variable">a</span></a>)<br>
    := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:29"><span class="id" title="variable">a</span></a><br>
          <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:29"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(51, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The eliminators <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a></span>, <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a></span>, ... can be proven. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      ">
  <span class="id" title="keyword">Definition</span> <a id="PO_ind" class="idref" href="#PO_ind"><span class="id" title="definition">PO_ind</span></a> (<a id="P:30" class="idref" href="#P:30"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<a id="l':32" class="idref" href="#l':32"><span class="id" title="binder">l'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:31" class="idref" href="#b:31"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:30"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#b:31"><span class="id" title="variable">b</span></a>))<br>
    (<a id="r':34" class="idref" href="#r':34"><span class="id" title="binder">r'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="c:33" class="idref" href="#c:33"><span class="id" title="binder">c</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:30"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#c:33"><span class="id" title="variable">c</span></a>)) (<a id="pp':36" class="idref" href="#pp':36"><span class="id" title="binder">pp'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:35" class="idref" href="#a:35"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:35"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':32"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:35"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':34"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:35"><span class="id" title="variable">a</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="w:37" class="idref" href="#w:37"><span class="id" title="binder">w</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:30"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#w:37"><span class="id" title="variable">w</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(60, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(61, '0_3_11');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(62, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [[]|[]] <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(63, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">l'</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(64, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> (<span class="id" title="var">l'</span> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(65, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> (<span class="id" title="var">r'</span> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(66, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(67, '0_3_11');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>, <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(68, '0_3_11');
      "><br>
      1: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(69, '0_3_11');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(70, '0_3_11');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(71, '0_3_11');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(72, '0_3_11');
      "><br>
      <span class="id" title="var">etransitivity</span>; [|<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_pp"><span class="id" title="definition">transport_pp</span></a>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(73, '0_3_11');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(74, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(75, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="PO_ind_beta_pp" class="idref" href="#PO_ind_beta_pp"><span class="id" title="definition">PO_ind_beta_pp</span></a> (<a id="P:38" class="idref" href="#P:38"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<a id="l':40" class="idref" href="#l':40"><span class="id" title="binder">l'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="b:39" class="idref" href="#b:39"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:38"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#b:39"><span class="id" title="variable">b</span></a>))<br>
    (<a id="r':42" class="idref" href="#r':42"><span class="id" title="binder">r'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="c:41" class="idref" href="#c:41"><span class="id" title="binder">c</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:38"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#c:41"><span class="id" title="variable">c</span></a>)) (<a id="pp':44" class="idref" href="#pp':44"><span class="id" title="binder">pp'</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:43" class="idref" href="#a:43"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:43"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':40"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:43"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':42"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#a:43"><span class="id" title="variable">a</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:45" class="idref" href="#x:45"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:38"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':40"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':42"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pp':44"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:45"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pp':44"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:45"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(76, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(77, '0_3_11');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(78, '0_3_11');
      "><br>
    <span class="id" title="var">etransitivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(79, '0_3_11');
      "><br>
    1: <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_pp"><span class="id" title="definition">apD_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(80, '0_3_11');
      "><br>
    <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <span class="id" title="var">P</span> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
      (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Diagrams.Span.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(81, '0_3_11');
      "><br>
    { <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(82, '0_3_11');
      "><br>
      <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
      | |- <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
        <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>)<br>
      <span class="id" title="keyword">end</span>. }<br>
    <span class="id" title="tactic">rewrite</span> <span class="id" title="var">X</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">X</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(83, '0_3_11');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_V"><span class="id" title="definition">apD_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(84, '0_3_11');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(85, '0_3_11');
      "><br>
    <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
    | |- <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a><br>
          <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>); <span class="id" title="var">cbn</span><br>
    <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(86, '0_3_11');
      "><br>
    <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
    | |- ?<span class="id" title="var">pp</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">qq</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span><br>
      ⇒ <span class="id" title="tactic">set</span> (<span class="id" title="var">q</span> := <span class="id" title="var">qq</span>); <span class="id" title="tactic">set</span> (<span class="id" title="var">p</span> := <span class="id" title="var">pp</span>) <span class="id" title="tactic">in</span> ×<br>
    <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(87, '0_3_11');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p_V"><span class="id" title="definition">moveR_transport_p_V</span></a>, <a class="idref" href="HoTT.Types.Paths.html#moveR_moveL_transport_p"><span class="id" title="definition">moveR_moveL_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(88, '0_3_11');
      "><br>
    <span class="id" title="tactic">subst</span> <span class="id" title="var">q</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(89, '0_3_11');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(90, '0_3_11');
      "><br>
    <span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(91, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(92, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="PO_rec" class="idref" href="#PO_rec"><span class="id" title="definition">PO_rec</span></a> (<a id="P:46" class="idref" href="#P:46"><span class="id" title="binder">P</span></a>: <span class="id" title="keyword">Type</span>) (<a id="l':47" class="idref" href="#l':47"><span class="id" title="binder">l'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:46"><span class="id" title="variable">P</span></a>) (<a id="r':48" class="idref" href="#r':48"><span class="id" title="binder">r'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:46"><span class="id" title="variable">P</span></a>)<br>
    (<a id="pp':49" class="idref" href="#pp':49"><span class="id" title="binder">pp'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':47"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':48"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:46"><span class="id" title="variable">P</span></a><br>
    := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:46"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':47"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':48"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pp':49"><span class="id" title="variable">pp'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(93, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="PO_rec_beta_pp" class="idref" href="#PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a> (<a id="P:50" class="idref" href="#P:50"><span class="id" title="binder">P</span></a>: <span class="id" title="keyword">Type</span>) (<a id="l':51" class="idref" href="#l':51"><span class="id" title="binder">l'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:50"><span class="id" title="variable">P</span></a>)<br>
    (<a id="r':52" class="idref" href="#r':52"><span class="id" title="binder">r'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:50"><span class="id" title="variable">P</span></a>) (<a id="pp':53" class="idref" href="#pp':53"><span class="id" title="binder">pp'</span></a>: <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':51"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':52"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:54" class="idref" href="#x:54"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#P:50"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#l':51"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#r':52"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pp':53"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:54"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pp':53"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#x:54"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(94, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(95, '0_3_11');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(96, '0_3_11');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">X</span> := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(97, '0_3_11');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">X0</span> := <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(98, '0_3_11');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(99, '0_3_11');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(100, '0_3_11');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">X</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#3b607a272444a2e3acbecfa52b796d2a"><span class="id" title="notation">@@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(101, '0_3_11');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a> <span class="id" title="var">X0</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(102, '0_3_11');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(103, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(104, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
A nice property: the pushout of an equivalence is an equivalence. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(108, '0_3_15');
      ">
  <span class="id" title="keyword">Global Instance</span> <a id="PO_of_equiv" class="idref" href="#PO_of_equiv"><span class="id" title="instance">PO_of_equiv</span></a> (<a id="Hf:55" class="idref" href="#Hf:55"><span class="id" title="binder">Hf</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por"><span class="id" title="definition">por</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(109, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(110, '0_3_15');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(111, '0_3_15');
      "><br>
    - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(112, '0_3_15');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(113, '0_3_15');
      "><br>
      + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(114, '0_3_15');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(115, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="method">eissect</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(116, '0_3_15');
      "><br>
    - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(117, '0_3_15');
      "><br>
      + <span class="id" title="tactic">intro</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(118, '0_3_15');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(119, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#eisretr"><span class="id" title="method">eisretr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(120, '0_3_15');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(121, '0_3_15');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(122, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(123, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(124, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#eisadj"><span class="id" title="method">eisadj</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(125, '0_3_15');
      "><br>
        <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="method">eissect</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">a</span>); <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(126, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(127, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_Vp"><span class="id" title="definition">concat_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(128, '0_3_15');
      "><br>
    - <span class="id" title="var">cbn</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(129, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(131, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
<a id="lab515"></a><h2 class="section">Equivalence with <span class="inlinecode"><span class="id" title="var">pushout</span></span>
</h2>
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(138, '0_3_19');
      ">
<br>
<span class="id" title="keyword">Section</span> <a id="is_PO_pushout" class="idref" href="#is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(139, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Import</span> <span class="id" title="var">Colimits.Pushout</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(140, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> `{<a id="H:56" class="idref" href="#H:56"><span class="id" title="binder">Funext</span></a>} {<a id="A:57" class="idref" href="#A:57"><span class="id" title="binder">A</span></a> <a id="B:58" class="idref" href="#B:58"><span class="id" title="binder">B</span></a> <a id="C:59" class="idref" href="#C:59"><span class="id" title="binder">C</span></a> : <span class="id" title="keyword">Type</span>} {<a id="f:60" class="idref" href="#f:60"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#A:57"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#B:58"><span class="id" title="variable">B</span></a>} {<a id="g:61" class="idref" href="#g:61"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#A:57"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#C:59"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(141, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="is_PO_pushout" class="idref" href="#is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a> : <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO"><span class="id" title="definition">is_PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> (<a class="idref" href="HoTT.Colimits.Pushout.html#Pushout"><span class="id" title="definition">Pushout</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(142, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(143, '0_3_19');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Build_IsColimit"><span class="id" title="constructor">Build_IsColimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(144, '0_3_19');
      "><br>
    - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(145, '0_3_19');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(146, '0_3_19');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(147, '0_3_19');
      "><br>
      + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Colimits.Pushout.html#pglue"><span class="id" title="definition">pglue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(148, '0_3_19');
      "><br>
    - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_UniversalCocone"><span class="id" title="constructor">Build_UniversalCocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(149, '0_3_19');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">Y</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(150, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">Co</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(151, '0_3_19');
      "><br>
        <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Pushout.html#Pushout_rec"><span class="id" title="definition">Pushout_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(152, '0_3_19');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(153, '0_3_19');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#por'"><span class="id" title="definition">por'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(154, '0_3_19');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp'"><span class="id" title="definition">popp'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(155, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intros</span> [<span class="id" title="var">Co</span> <span class="id" title="var">Co'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(156, '0_3_19');
      "><br>
        <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#path_cocone"><span class="id" title="definition">path_cocone</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(157, '0_3_19');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(158, '0_3_19');
      "><br>
          1: <span class="id" title="tactic">apply</span> (<span class="id" title="var">Co'</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(159, '0_3_19');
      "><br>
          <span class="id" title="var">all</span>: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(160, '0_3_19');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] [[]|[]] [] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(161, '0_3_19');
      "><br>
          2: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(162, '0_3_19');
      "><br>
          <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(163, '0_3_19');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Pushout.html#Pushout_rec_beta_pglue"><span class="id" title="definition">Pushout_rec_beta_pglue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(164, '0_3_19');
      "><br>
          <span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(165, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(166, '0_3_19');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(167, '0_3_19');
      "><br>
        <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Pushout.html#Pushout_ind"><span class="id" title="definition">Pushout_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(168, '0_3_19');
      "><br>
        1,2: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(169, '0_3_19');
      "><br>
        <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(170, '0_3_19');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(171, '0_3_19');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Pushout.html#Pushout_rec_beta_pglue"><span class="id" title="definition">Pushout_rec_beta_pglue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(172, '0_3_19');
      "><br>
        <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_Vp"><span class="id" title="definition">moveR_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(173, '0_3_19');
      "><br>
        <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#popp'"><span class="id" title="definition">popp'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(174, '0_3_19');
      "><br>
        <span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> 2 <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(175, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(176, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="equiv_pushout_PO" class="idref" href="#equiv_pushout_PO"><span class="id" title="definition">equiv_pushout_PO</span></a> : <a class="idref" href="HoTT.Colimits.Pushout.html#Pushout"><span class="id" title="definition">Pushout</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(177, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(178, '0_3_19');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#colimit_unicity"><span class="id" title="lemma">colimit_unicity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(179, '0_3_19');
      "><br>
    3: <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(180, '0_3_19');
      "><br>
    <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#iscolimit_colimit"><span class="id" title="instance">iscolimit_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(181, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(182, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Colimit_Pushout.html#is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(183, '0_3_19');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
