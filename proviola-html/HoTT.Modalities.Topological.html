<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "1 goal (ID 19)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  ============================	  Lex O	";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "1 goal (ID 28)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  ooExtendableAlong (acc_lgen O i)	    (fun _ : lgen_codomain (acc_lgen O) i => Type_ O)	";
            responses[i]=data;
          

            i = 32;
            data = "1 goal (ID 46)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  IsEquiv	    (fun g : lgen_codomain (acc_lgen O) i -> Type_ O => g oD acc_lgen O i)	";
            responses[i]=data;
          

            i = 33;
            data = "3 goals (ID 77)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  (acc_ngen O i -> Type_ (modality_subuniv O)) ->	  Unit -> Type_ (modality_subuniv O)		goal 2 (ID 78) is:	 (fun x : acc_ngen O i -> Type_ (modality_subuniv O) =>	  ?Goal x oD (fun _ : acc_ngen O i => tt)) == idmap	goal 3 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  ?Goal (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 34;
            data = "1 goal (ID 77)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  (acc_ngen O i -> Type_ (modality_subuniv O)) ->	  Unit -> Type_ (modality_subuniv O)	1 goal (ID 82)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  ============================	  Type_ (modality_subuniv O)	";
            responses[i]=data;
          

            i = 35;
            data = "1 goal (ID 89)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  ============================	  In (modality_subuniv O) (forall a : acc_ngen O i, B a)	";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 78) is:	 (fun x : acc_ngen O i -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0)))) x	  oD (fun _ : acc_ngen O i => tt)) == idmap	goal 2 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	    (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 37;
            data = "1 goal (ID 78)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  (fun x : acc_ngen O i -> Type_ (modality_subuniv O) =>	   (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	    unit_name	      (forall a : acc_ngen O i, B a;	      inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	        (fun x0 : acc_ngen O i => inO_TypeO (B x0)))) x	   oD (fun _ : acc_ngen O i => tt)) == idmap	1 goal (ID 203)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  ============================	  unit_name	    (forall a : acc_ngen O i, B a;	    inO_forall O (acc_ngen O i) (fun x : acc_ngen O i => B x)	      (fun x : acc_ngen O i => inO_TypeO (B x)))	  oD (fun _ : acc_ngen O i => tt) = B	";
            responses[i]=data;
          

            i = 38;
            data = "1 goal (ID 212)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (unit_name	     (forall a0 : acc_ngen O i, B a0;	     inO_forall O (acc_ngen O i) (fun x : acc_ngen O i => B x)	       (fun x : acc_ngen O i => inO_TypeO (B x)))	   oD (fun _ : acc_ngen O i => tt)) a = B a	";
            responses[i]=data;
          

            i = 39;
            data = "1 goal (ID 221)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  ((unit_name	      (forall a0 : acc_ngen O i, B a0;	      inO_forall O (acc_ngen O i) (fun x : acc_ngen O i => B x)	        (fun x : acc_ngen O i => inO_TypeO (B x)))	    oD (fun _ : acc_ngen O i => tt)) a).1 <~> (B a).1	";
            responses[i]=data;
          

            i = 40;
            data = "1 goal (ID 223)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (forall a0 : acc_ngen O i, B a0) <~> (B a).1	";
            responses[i]=data;
          

            i = 41;
            data = "4 goals (ID 227)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (forall a0 : acc_ngen O i, B a0) -> (B a).1		goal 2 (ID 229) is:	 (B a).1 -> forall a0 : acc_ngen O i, B a0	goal 3 (ID 231) is:	 ?f o ?g == idmap	goal 4 (ID 233) is:	 ?g o ?f == idmap	";
            responses[i]=data;
          

            i = 42;
            data = "1 goal (ID 227)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (forall a0 : acc_ngen O i, B a0) -> (B a).1	1 goal (ID 234)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  f : forall a : acc_ngen O i, B a	  ============================	  (B a).1	";
            responses[i]=data;
          

            i = 43;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 229) is:	 (B a).1 -> forall a0 : acc_ngen O i, B a0	goal 2 (ID 231) is:	 (fun f : forall a0 : acc_ngen O i, B a0 => f a) o ?g == idmap	goal 3 (ID 233) is:	 ?g o (fun f : forall a0 : acc_ngen O i, B a0 => f a) == idmap	goal 4 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	    (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 44;
            data = "1 goal (ID 229)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (B a).1 -> forall a0 : acc_ngen O i, B a0	1 goal (ID 236)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  b : (B a).1	  a' : acc_ngen O i	  ============================	  B a'	";
            responses[i]=data;
          

            i = 45;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 231) is:	 (fun f : forall a0 : acc_ngen O i, B a0 => f a)	 o (fun (b : (B a).1) (a' : acc_ngen O i) =>	    transport (fun x : acc_ngen O i => B x) (path_ishprop a a') b) == idmap	goal 2 (ID 233) is:	 (fun (b : (B a).1) (a' : acc_ngen O i) =>	  transport (fun x : acc_ngen O i => B x) (path_ishprop a a') b)	 o (fun f : forall a0 : acc_ngen O i, B a0 => f a) == idmap	goal 3 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	    (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 46;
            data = "1 goal (ID 231)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (fun f : forall a0 : acc_ngen O i, B a0 => f a)	  o (fun (b : (B a).1) (a' : acc_ngen O i) =>	     transport (fun x : acc_ngen O i => B x) (path_ishprop a a') b) == idmap	1 goal (ID 243)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  b : (B a).1	  ============================	  transport (fun x : acc_ngen O i => B x) (path_ishprop a a) b = b	";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 233) is:	 (fun (b : (B a).1) (a' : acc_ngen O i) =>	  transport (fun x : acc_ngen O i => B x) (path_ishprop a a') b)	 o (fun f : forall a0 : acc_ngen O i, B a0 => f a) == idmap	goal 2 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	    (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 48;
            data = "1 goal (ID 233)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  ============================	  (fun (b : (B a).1) (a' : acc_ngen O i) =>	   transport (fun x : acc_ngen O i => B x) (path_ishprop a a') b)	  o (fun f : forall a0 : acc_ngen O i, B a0 => f a) == idmap	1 goal (ID 261)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  f : forall a : acc_ngen O i, B a	  ============================	  (fun a' : acc_ngen O i =>	   transport (fun x : acc_ngen O i => B x) (path_ishprop a a') (f a)) = f	";
            responses[i]=data;
          

            i = 49;
            data = "1 goal (ID 270)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : acc_ngen O i -> Type_ (modality_subuniv O)	  a : acc_ngen O i	  f : forall a : acc_ngen O i, B a	  a' : acc_ngen O i	  ============================	  transport (fun x : acc_ngen O i => B x) (path_ishprop a a') (f a) = f a'	";
            responses[i]=data;
          

            i = 50;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 79) is:	 (fun x : Unit -> Type_ (modality_subuniv O) =>	  (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	   unit_name	     (forall a : acc_ngen O i, B a;	     inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	       (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	    (x oD (fun _ : acc_ngen O i => tt))) == idmap	";
            responses[i]=data;
          

            i = 51;
            data = "1 goal (ID 79)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  ============================	  (fun x : Unit -> Type_ (modality_subuniv O) =>	   (fun B : acc_ngen O i -> Type_ (modality_subuniv O) =>	    unit_name	      (forall a : acc_ngen O i, B a;	      inO_forall O (acc_ngen O i) (fun x0 : acc_ngen O i => B x0)	        (fun x0 : acc_ngen O i => inO_TypeO (B x0))))	     (x oD (fun _ : acc_ngen O i => tt))) == idmap	1 goal (ID 278)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  ============================	  unit_name	    (forall a : acc_ngen O i, (B oD (fun _ : acc_ngen O i => tt)) a;	    inO_forall O (acc_ngen O i)	      (fun x : acc_ngen O i => (B oD (fun _ : acc_ngen O i => tt)) x)	      (fun x : acc_ngen O i =>	       inO_TypeO ((B oD (fun _ : acc_ngen O i => tt)) x))) = B	";
            responses[i]=data;
          

            i = 52;
            data = "1 goal (ID 289)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  ============================	  (forall a : acc_ngen O i, (B oD (fun _ : acc_ngen O i => tt)) a;	  inO_forall O (acc_ngen O i)	    (fun x : acc_ngen O i => (B oD (fun _ : acc_ngen O i => tt)) x)	    (fun x : acc_ngen O i =>	     inO_TypeO ((B oD (fun _ : acc_ngen O i => tt)) x))) = 	  B tt	";
            responses[i]=data;
          

            i = 53;
            data = "1 goal (ID 298)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  ============================	  (forall a : acc_ngen O i, (B oD (fun _ : acc_ngen O i => tt)) a;	  inO_forall O (acc_ngen O i)	    (fun x : acc_ngen O i => (B oD (fun _ : acc_ngen O i => tt)) x)	    (fun x : acc_ngen O i =>	     inO_TypeO ((B oD (fun _ : acc_ngen O i => tt)) x))).1 <~> 	  (B tt).1	";
            responses[i]=data;
          

            i = 54;
            data = "1 goal (ID 300)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  ============================	  (acc_ngen O i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 55;
            data = "1 goal (ID 315)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  e := isequiv_ooextendable	         (fun _ : lgen_codomain (null_to_local_generators (acc_ngen O)) i =>	          B tt) (null_to_local_generators (acc_ngen O) i)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv	       (fun	          g : forall	              b : lgen_codomain (null_to_local_generators (acc_ngen O)) i,	              (fun	                 _ : lgen_codomain (null_to_local_generators (acc_ngen O)) i	               => TypeO_pr1 (modality_subuniv O) (B tt)) b =>	        g oD null_to_local_generators (acc_ngen O) i)	  ============================	  (acc_ngen O i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 56;
            data = "1 goal (ID 317)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  e := isequiv_ooextendable (unit_name (B tt)) (fun _ : acc_ngen O i => tt)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv (fun (g : Unit -> B tt) (_ : acc_ngen O i) => g tt)	  ============================	  (acc_ngen O i -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 57;
            data = "1 goal (ID 333)	  	  H : Univalence	  O : Modality	  H0 : IsAccModality O	  Topological0 : forall i : ngen_indices (acc_ngen O), IsHProp (acc_ngen O i)	  i : lgen_indices (acc_lgen O)	  B : Unit -> Type_ (modality_subuniv O)	  e := isequiv_ooextendable (unit_name (B tt)) (fun _ : acc_ngen O i => tt)	         (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)	   : IsEquiv (fun (g : Unit -> B tt) (_ : acc_ngen O i) => g tt)	  ============================	  (Unit -> B tt) <~> (B tt).1	";
            responses[i]=data;
          

            i = 58;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "1 goal (ID 25)	  	  H : Univalence	  S : NullGenerators	  H0 : forall i : ngen_indices S, IsHProp (S i)	  ============================	  Lex (Nul S)	";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 35)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "2 goals (ID 44)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}		goal 2 (ID 46) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 90;
            data = "1 goal (ID 44)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	1 goal (ID 49)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  gtr : forall a : ngen_indices B, Contr (B a)	  ============================	  (forall	   c : ngen_indices	         {| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |},	   IsHProp	     ({| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |} c)) *	  (Nul {| ngen_indices := Empty; ngen_type := fun _ : Empty => Unit |} <=>	   Nul B)	";
            responses[i]=data;
          

            i = 91;
            data = "1 goal (ID 76)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  gtr : forall a : ngen_indices B, Contr (B a)	  X : Type	  ============================	  In (Nul B) X	";
            responses[i]=data;
          

            i = 92;
            data = "1 goal (ID 84)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  gtr : forall a : ngen_indices B, Contr (B a)	  X : Type	  i : lgen_indices (null_to_local_generators B)	  ============================	  ooExtendableAlong (null_to_local_generators B i)	    (fun _ : lgen_codomain (null_to_local_generators B) i => X)	";
            responses[i]=data;
          

            i = 93;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 46) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	1 goal (ID 46)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	1 goal (ID 96)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  O := Nul B : Modality	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 94;
            data = "1 goal (ID 97)	  	  H : Funext	  B : NullGenerators	  Olex : Lex (Nul B)	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  O := Nul B : Modality	  OeqB := (reflexive_O_eq O : O <=> Nul B) : O <=> Nul B	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 95;
            data = "1 goal (ID 98)	  	  H : Funext	  B : NullGenerators	  O := Nul B : Modality	  Olex : Lex O	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  OeqB := (reflexive_O_eq O : O <=> Nul B) : O <=> Nul B	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 96;
            data = "1 goal (ID 99)	  	  H : Funext	  B : NullGenerators	  O : Modality	  Olex : Lex O	  n : trunc_index	  gtr : forall a : ngen_indices B, IsTrunc n.+1 (B a)	  OeqB : O <=> Nul B	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 97;
            data = "1 goal (ID 101)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  ============================	  forall B : NullGenerators,	  O <=> Nul B ->	  (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 98;
            data = "2 goals (ID 111)	  	  H : Funext	  O : Modality	  Olex : Lex O	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsHProp (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}		goal 2 (ID 114) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 99;
            data = "1 goal (ID 111)	  	  H : Funext	  O : Modality	  Olex : Lex O	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsHProp (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 114) is:	 {D : NullGenerators &	 (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 114)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	1 goal (ID 132)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 101;
            data = "1 goal (ID 134)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  ============================	  {D : NullGenerators &	  (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	";
            responses[i]=data;
          

            i = 102;
            data = "1 goal (ID 137)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 103;
            data = "2 goals (ID 138)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  ============================	  forall c : C, IsTrunc n.+1 (D c)		goal 2 (ID 139) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 104;
            data = "1 goal (ID 138)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  ============================	  forall c : C, IsTrunc n.+1 (D c)	1 goal (ID 155)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  a : A	  ============================	  IsTrunc n.+1 (Trunc (-1) (B a))	";
            responses[i]=data;
          

            i = 105;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 139) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	1 goal (ID 139)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	2 goals (ID 200)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  O <=> Nul D		goal 2 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 106;
            data = "1 goal (ID 200)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  ============================	  O <=> Nul D	2 goals (ID 206)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  ============================	  In O X -> In (Nul D) X		goal 2 (ID 208) is:	 In (Nul D) X -> In O X	";
            responses[i]=data;
          

            i = 107;
            data = "1 goal (ID 206)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  ============================	  In O X -> In (Nul D) X	1 goal (ID 211)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  ============================	  ooExtendableAlong (null_to_local_generators D c)	    (fun _ : lgen_codomain (null_to_local_generators D) c => X)	";
            responses[i]=data;
          

            i = 108;
            data = "2 goals (ID 212)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  ============================	  forall a : A, IsConnected O (B a)		goal 2 (ID 213) is:	 ooExtendableAlong (null_to_local_generators D c)	   (fun _ : lgen_codomain (null_to_local_generators D) c => X)	";
            responses[i]=data;
          

            i = 109;
            data = "1 goal (ID 212)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  ============================	  forall a : A, IsConnected O (B a)	1 goal (ID 214)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  a : A	  ============================	  IsConnected O (B a)	";
            responses[i]=data;
          

            i = 110;
            data = "1 goal (ID 293)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  a : A	  ============================	  IsConnected (Nul B) (B a)	";
            responses[i]=data;
          

            i = 111;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 213) is:	 ooExtendableAlong (null_to_local_generators D c)	   (fun _ : lgen_codomain (null_to_local_generators D) c => X)	goal 2 (ID 208) is:	 In (Nul D) X -> In O X	goal 3 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 112;
            data = "1 goal (ID 213)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  c : lgen_indices (null_to_local_generators D)	  Bc : forall a : A, IsConnected O (B a)	  ============================	  ooExtendableAlong (null_to_local_generators D c)	    (fun _ : lgen_codomain (null_to_local_generators D) c => X)	2 goals (ID 303)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O (lgen_domain (null_to_local_generators D) (inl a))		goal 2 (ID 317) is:	 IsConnected O (lgen_domain (null_to_local_generators D) (inr (a; (b1, b2))))	";
            responses[i]=data;
          

            i = 113;
            data = "1 goal (ID 303)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O (lgen_domain (null_to_local_generators D) (inl a))	1 goal (ID 318)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  ============================	  NullHomotopy.NullHomotopy	    (to O (lgen_domain (null_to_local_generators D) (inl a)))	";
            responses[i]=data;
          

            i = 114;
            data = "1 goal (ID 336)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (merely (B a)) (tr x0) = x	  ============================	  NullHomotopy.NullHomotopy	    (to O (lgen_domain (null_to_local_generators D) (inl a)))	";
            responses[i]=data;
          

            i = 115;
            data = "1 goal (ID 340)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (merely (B a)) (tr x0) = x	  y : Trunc (-1) (B a)	  ============================	  to O (lgen_domain (null_to_local_generators D) (inl a)) y = x	";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "1 goal (ID 422)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  Bc : forall a : A, IsConnected O (B a)	  x : O (merely (B a))	  h : forall x0 : B a, to O (merely (B a)) (tr x0) = x	  y : B a	  ============================	  to O (lgen_domain (null_to_local_generators D) (inl a)) (tr y) = x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 317) is:	 IsConnected O (lgen_domain (null_to_local_generators D) (inr (a; (b1, b2))))	goal 2 (ID 208) is:	 In (Nul D) X -> In O X	goal 3 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 118;
            data = "1 goal (ID 317)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  b1, b2 : B a	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O	    (lgen_domain (null_to_local_generators D) (inr (a; (b1, b2))))	1 goal (ID 682)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  X_inO : In O X	  a : A	  b1, b2 : B a	  Bc : forall a : A, IsConnected O (B a)	  ============================	  IsConnected O (b1 = b2)	";
            responses[i]=data;
          

            i = 119;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 208) is:	 In (Nul D) X -> In O X	goal 2 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 120;
            data = "1 goal (ID 208)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  ============================	  In (Nul D) X -> In O X	1 goal (ID 808)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  ============================	  In (Nul B) X	";
            responses[i]=data;
          

            i = 121;
            data = "1 goal (ID 812)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  ============================	  ooExtendableAlong (fun _ : B a => tt) (unit_name X)	";
            responses[i]=data;
          

            i = 122;
            data = "1 goal (ID 824)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  ============================	  IsEquiv (fun g : Unit -> X => g oD (fun _ : B a => tt))	";
            responses[i]=data;
          

            i = 123;
            data = "1 goal (ID 830)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  Contr (hfiber (fun g : Unit -> X => g oD (fun _ : B a => tt)) f)	";
            responses[i]=data;
          

            i = 124;
            data = "2 goals (ID 862)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  {x : X & forall u : B a, x = f u} <~>	  hfiber (fun g : Unit -> X => g oD (fun _ : B a => tt)) f		goal 2 (ID 863) is:	 Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 125;
            data = "1 goal (ID 862)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  {x : X & forall u : B a, x = f u} <~>	  hfiber (fun g : Unit -> X => g oD (fun _ : B a => tt)) f	1 goal (ID 871)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  forall a0 : X,	  (forall u : B a, a0 = f u) <~>	  equiv_unit_rec X a0 oD (fun _ : B a => tt) = f	";
            responses[i]=data;
          

            i = 126;
            data = "1 goal (ID 874)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  x : X	  ============================	  (forall u : B a, x = f u) <~> (fun _ : B a => x) = f	";
            responses[i]=data;
          

            i = 127;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 863) is:	 Contr {x : X & forall u : B a, x = f u}	goal 2 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	1 goal (ID 863)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 128;
            data = "2 goals (ID 1441)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  IsConnected (Nul D) (D (inl a))		goal 2 (ID 1442) is:	 D (inl a) -> Contr {x : X & forall u : B a, x = f u}	1 goal (ID 1441)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  IsConnected (Nul D) (D (inl a))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1442) is:	 D (inl a) -> Contr {x : X & forall u : B a, x = f u}	goal 2 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	1 goal (ID 1442)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  ============================	  D (inl a) -> Contr {x : X & forall u : B a, x = f u}	1 goal (ID 1471)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : Trunc (-1) (B a)	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "1 goal (ID 1501)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  Contr {x : X & forall u : B a, x = f u}	2 goals (ID 1737)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  IsConnMap (Nul D) (unit_name b)		goal 2 (ID 1738) is:	 Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 131;
            data = "1 goal (ID 1737)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  ============================	  IsConnMap (Nul D) (unit_name b)	1 goal (ID 1741)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b, x : B a	  ============================	  IsConnected (Nul D) {_ : Unit & b = x}	";
            responses[i]=data;
          

            i = 132;
            data = "1 goal (ID 1762)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b, x : B a	  ============================	  IsConnected (Nul D) (b = x)	";
            responses[i]=data;
          

            i = 133;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1738) is:	 Contr {x : X & forall u : B a, x = f u}	goal 2 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 134;
            data = "1 goal (ID 1738)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  ============================	  Contr {x : X & forall u : B a, x = f u}	1 goal (ID 1821)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  ============================	  Contr {x : X & forall u : B a, x = f u}	";
            responses[i]=data;
          

            i = 135;
            data = "1 goal (ID 1832)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  (f b; p) = (x; q)	";
            responses[i]=data;
          

            i = 136;
            data = "1 goal (ID 1849)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  transport (fun x0 : X => forall u : B a, x0 = f u) (q b)^ p == q	";
            responses[i]=data;
          

            i = 137;
            data = "1 goal (ID 1936)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  transport (fun x0 : X => forall u : B a, x0 = f u) (q b)^ p b = q b	";
            responses[i]=data;
          

            i = 138;
            data = "1 goal (ID 1962)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  q b @ p b = q b	";
            responses[i]=data;
          

            i = 139;
            data = "1 goal (ID 1979)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  X : Type	  Dnull : In (Nul D) X	  a : ngen_indices B	  f : B a -> X	  b : B a	  bc : IsConnMap (Nul D) (unit_name b)	  p := conn_map_elim (Nul D) (unit_name b) (fun u : B a => f b = f u)	         (unit_name 1) : forall b0 : B a, (fun u : B a => f b = f u) b0	  x : X	  q : forall u : B a, x = f u	  ============================	  q b @ 1 = q b	";
            responses[i]=data;
          

            i = 140;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 201) is:	 {D0 : NullGenerators &	 (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	1 goal (ID 201)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : O <=> Nul D	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	1 goal (ID 2007)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : O <=> Nul D	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : Nul E <=> Nul D	  ============================	  {D0 : NullGenerators &	  (forall c : ngen_indices D0, IsHProp (D0 c)) * (Nul D0 <=> Nul B)}	";
            responses[i]=data;
          

            i = 141;
            data = "1 goal (ID 2012)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : O <=> Nul D	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : Nul E <=> Nul D	  ============================	  Nul E <=> Nul B	";
            responses[i]=data;
          

            i = 142;
            data = "1 goal (ID 2030)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : O <=> Nul D	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : Nul E <=> Nul D	  ============================	  Nul D <=> Nul B	";
            responses[i]=data;
          

            i = 143;
            data = "1 goal (ID 2048)	  	  H : Funext	  O : Modality	  Olex : Lex O	  n : trunc_index	  IHn : forall B : NullGenerators,	        O <=> Nul B ->	        (forall a : ngen_indices B, IsTrunc n.+1 (B a)) ->	        {D : NullGenerators &	        (forall c : ngen_indices D, IsHProp (D c)) * (Nul D <=> Nul B)}	  B : NullGenerators	  OeqB : O <=> Nul B	  gtr : forall a : ngen_indices B, IsTrunc n.+2 (B a)	  A := ngen_indices B : Type	  C := A + {a : A & B a * B a} : Type	  D := {|	         ngen_indices := C;	         ngen_type :=	           fun c : C =>	           match c with	           | inl a => merely (B a)	           | inr s =>	               let s0 := s in	               let a := s0.1 in	               let proj2 := s0.2 in	               let proj3 := proj2 in	               let b1 := fst proj3 in let b2 := snd proj3 in b1 = b2	           end	           :	           Type	       |} : NullGenerators	  Dtrunc : forall c : C, IsTrunc n.+1 (D c)	  OeqD : O <=> Nul D	  E : NullGenerators	  HE : forall c : ngen_indices E, IsHProp (E c)	  EeqD : Nul E <=> Nul D	  ============================	  Nul D <=> O	";
            responses[i]=data;
          

            i = 144;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 145;
            data = "";
            responses[i]=data;
          

            i = 146;
            data = "";
            responses[i]=data;
          

            i = 147;
            data = "";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "";
            responses[i]=data;
          

            i = 153;
            data = "";
            responses[i]=data;
          

            i = 154;
            data = "";
            responses[i]=data;
          

            i = 155;
            data = "";
            responses[i]=data;
          

            i = 156;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Modalities.Topological</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Extensions.html#"><span class="id" title="library">Extensions</span></a> <a class="idref" href="HoTT.Truncations.html#"><span class="id" title="library">HoTT.Truncations</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Modality.html#"><span class="id" title="library">Modality</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#"><span class="id" title="library">Accessible</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#"><span class="id" title="library">Lex</span></a> <a class="idref" href="HoTT.Modalities.Nullification.html#"><span class="id" title="library">Nullification</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a id="lab432"></a><h1 class="section">Topological localizations</h1>
<div class="doc" scenenumber="4"> </div>

 A topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Notation</span> <a id="Topological" class="idref" href="#Topological"><span class="id" title="abbreviation">Topological</span></a> <span class="id" title="var">O</span> := (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="i:1" class="idref" href="#i:1"><span class="id" title="binder">i</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#acc_ngen"><span class="id" title="method">acc_ngen</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Modalities.Topological.html#i:1"><span class="id" title="variable">i</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
<a id="lab433"></a><h2 class="section">Topological modalities are lex</h2>
<div class="doc" scenenumber="4"> </div>

 We prove left-exactness by proving that the universe of modal types is modal, using univalence.  It's unclear whether univalence is necessary or not in general; in one special case (open modalities) funext suffices.  But it's plausible that it would be necessary in general, because lex-ness of nullification is a statement about the path-spaces of a HIT, and characterizing those in any way usually requires some amount of univalence. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(29, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a id="lex_topological" class="idref" href="#lex_topological"><span class="id" title="instance">lex_topological</span></a> `{<a id="H:2" class="idref" href="#H:2"><span class="id" title="binder">Univalence</span></a>}<br>
       (<a id="O:3" class="idref" href="#O:3"><span class="id" title="binder">O</span></a> : <a class="idref" href="HoTT.Modalities.Modality.html#Modality"><span class="id" title="record">Modality</span></a>) `{<a id="H0:4" class="idref" href="#H0:4"><span class="id" title="binder">IsAccModality</span></a> <a id="H0:4" class="idref" href="#H0:4"><span class="id" title="binder">O</span></a>} `{<a id="Topological0:5" class="idref" href="#Topological0:5"><span class="id" title="binder">Topological</span></a> <a id="Topological0:5" class="idref" href="#Topological0:5"><span class="id" title="binder">O</span></a>}<br>
  : <a class="idref" href="HoTT.Modalities.Lex.html#Lex"><span class="id" title="abbreviation">Lex</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#O:3"><span class="id" title="variable">O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(30, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(31, '0_3_11');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Modalities.Lex.html#lex_from_inO_typeO"><span class="id" title="definition">lex_from_inO_typeO</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(32, '0_3_11');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Extensions.html#equiv_ooextendable_isequiv"><span class="id" title="definition">equiv_ooextendable_isequiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">)^-1</span></a>%<span class="id" title="var">equiv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(33, '0_3_11');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(34, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      "><br>
      <span class="id" title="tactic">refine</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">((</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:7" class="idref" href="#a:7"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Topological.html#a:6"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
      <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(38, '0_3_11');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(39, '0_3_11');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#path_TypeO"><span class="id" title="definition">path_TypeO</span></a>, <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(40, '0_3_11');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(41, '0_3_11');
      "><br>
      <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(42, '0_3_11');
      "><br>
      + <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
      + <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
      + <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport2"><span class="id" title="definition">transport2</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Basics.Contractible.html#path_contr"><span class="id" title="definition">path_contr</span></a> <span class="id" title="var">_</span> 1) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
      + <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
        <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">f</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#path_TypeO"><span class="id" title="definition">path_TypeO</span></a>, <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
      <span class="id" title="tactic">pose</span> (<span class="id" title="var">e</span> := <a class="idref" href="HoTT.Extensions.html#isequiv_ooextendable"><span class="id" title="definition">isequiv_ooextendable</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br>
                                      (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#inO_iff_isnull"><span class="id" title="method">inO_iff_isnull</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)) (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#inO_TypeO"><span class="id" title="instance">inO_TypeO</span></a> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)) <span class="id" title="var">i</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
      <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Types.Forall.html#equiv_contr_forall"><span class="id" title="definition">equiv_contr_forall</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(60, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="lex_nullification" class="idref" href="#lex_nullification"><span class="id" title="instance">lex_nullification</span></a> `{<a id="H:8" class="idref" href="#H:8"><span class="id" title="binder">Univalence</span></a>}<br>
      (<a id="S:9" class="idref" href="#S:9"><span class="id" title="binder">S</span></a> : <a class="idref" href="HoTT.Modalities.Accessible.html#NullGenerators"><span class="id" title="record">NullGenerators</span></a>) `{<a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">∀</span></a> <a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">i</span></a><a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">,</span></a> <a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">IsHProp</span></a> <a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">(</span></a><a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">S</span></a> <a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">i</span></a><a id="H0:11" class="idref" href="#H0:11"><span class="id" title="binder">)</span></a>}<br>
: <a class="idref" href="HoTT.Modalities.Lex.html#Lex"><span class="id" title="abbreviation">Lex</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#S:9"><span class="id" title="variable">S</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(61, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(62, '0_3_11');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Modalities.Topological.html#lex_topological"><span class="id" title="instance">lex_topological</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(63, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(64, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
<a id="lab434"></a><h2 class="section">Lex modalities generated by n-types are topological</h2>
<div class="doc" scenenumber="4"> </div>

 For <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, nullification at a family of <span class="inlinecode"><span class="id" title="var">n</span></span>-types need not be lex.  For instance, the (-1)-truncation is nullification at <span class="inlinecode"><a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a></span>.  However, if the nullification at a family of <span class="inlinecode"><span class="id" title="var">n</span></span>-types *is* lex, then it is topological. 
<div class="doc" scenenumber="18"> </div>

 This is kind of annoying to prove, not just because the proof is fiddly, but because we have to pass back and forth between different generating families for the "same" modality.  It's a bit easier to prove it about nullifications than about arbitrary accessible lex modalities. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(87, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="topological_lex_trunc_acc" class="idref" href="#topological_lex_trunc_acc"><span class="id" title="definition">topological_lex_trunc_acc</span></a> `{<a id="H:12" class="idref" href="#H:12"><span class="id" title="binder">Funext</span></a>}<br>
             (<a id="B:13" class="idref" href="#B:13"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Modalities.Accessible.html#NullGenerators"><span class="id" title="record">NullGenerators</span></a>) {<a id="Olex:14" class="idref" href="#Olex:14"><span class="id" title="binder">Olex</span></a> : <a class="idref" href="HoTT.Modalities.Lex.html#Lex"><span class="id" title="abbreviation">Lex</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B:13"><span class="id" title="variable">B</span></a>)}<br>
             (<a id="n:15" class="idref" href="#n:15"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#trunc_index"><span class="id" title="inductive">trunc_index</span></a>) (<a id="gtr:17" class="idref" href="#gtr:17"><span class="id" title="binder">gtr</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:16" class="idref" href="#a:16"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#n:15"><span class="id" title="variable">n</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#ngen_type"><span class="id" title="projection">ngen_type</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B:13"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#a:16"><span class="id" title="variable">a</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <a id="D:18" class="idref" href="#D:18"><span class="id" title="binder">D</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#NullGenerators"><span class="id" title="record">NullGenerators</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
            <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="c:19" class="idref" href="#c:19"><span class="id" title="binder">c</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Modalities.Accessible.html#ngen_type"><span class="id" title="projection">ngen_type</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#D:18"><span class="id" title="variable">D</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#c:19"><span class="id" title="variable">c</span></a>)<a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
            <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#D:18"><span class="id" title="variable">D</span></a> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">&lt;=&gt;</span></a> <a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#B:13"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(88, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(89, '0_3_15');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(90, '0_3_15');
      "><br>
    { <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Modalities.Accessible.html#Build_NullGenerators"><span class="id" title="constructor">Build_NullGenerators</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(91, '0_3_15');
      "><br>
      <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">_</span>; [ | <span class="id" title="tactic">intros</span> [] ] ].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(92, '0_3_15');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(93, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Extensions.html#ooextendable_equiv"><span class="id" title="definition">ooextendable_equiv</span></a>, <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_contr_contr"><span class="id" title="instance">isequiv_contr_contr</span></a>. }<br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">O</span> := <a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(94, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">OeqB</span> := <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#reflexive_O_eq"><span class="id" title="instance">reflexive_O_eq</span></a> <span class="id" title="var">O</span> : <span class="id" title="var">O</span> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">&lt;=&gt;</span></a> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(95, '0_3_15');
      "><br>
    <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">O</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Olex</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(96, '0_3_15');
      "><br>
    <span class="id" title="var">clearbody</span> <span class="id" title="var">O</span> <span class="id" title="var">OeqB</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(97, '0_3_15');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(98, '0_3_15');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(99, '0_3_15');
      "><br>
    { <span class="id" title="tactic">∃</span> <span class="id" title="var">B</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">assumption</span> | <span class="id" title="tactic">reflexivity</span> ]. }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(100, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">A</span> := <a class="idref" href="HoTT.Modalities.Accessible.html#ngen_indices"><span class="id" title="projection">ngen_indices</span></a> <span class="id" title="var">B</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(101, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">C</span> := <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <a id="a:21" class="idref" href="#a:21"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a><span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span>(<a class="idref" href="HoTT.Modalities.Topological.html#a:20"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <span class="id" title="var">B</span>(<a class="idref" href="HoTT.Modalities.Topological.html#a:20"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(102, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> (<span class="id" title="var">D</span> := <a class="idref" href="HoTT.Modalities.Accessible.html#Build_NullGenerators"><span class="id" title="constructor">Build_NullGenerators</span></a><br>
                 <span class="id" title="var">C</span> (<span class="id" title="keyword">fun</span> <a id="c:24" class="idref" href="#c:24"><span class="id" title="binder">c</span></a>:<span class="id" title="var">C</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.Modalities.Topological.html#c:22"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br>
                               | <a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Truncations.Core.html#merely"><span class="id" title="definition">merely</span></a> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)<br>
                               | <a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">b1</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">b2</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> ⇒ (<span class="id" title="var">b1</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">b2</span>)<br>
                               <span class="id" title="keyword">end</span> : <span class="id" title="keyword">Type</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(103, '0_3_15');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">Dtrunc</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="c:27" class="idref" href="#c:27"><span class="id" title="binder">c</span></a>:<span class="id" title="var">C</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#b76e54fb8c8bc6b885dddb77bd7d01b8"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">D</span> <a class="idref" href="HoTT.Modalities.Topological.html#c:26"><span class="id" title="variable">c</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(104, '0_3_15');
      "><br>
    { <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> [<span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]]; [ <span class="id" title="var">cbn</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(105, '0_3_15');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">OeqD</span> : <span class="id" title="var">O</span> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">&lt;=&gt;</span></a> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#2985062378df787f21af1f07095e736f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(106, '0_3_15');
      "><br>
    { <span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(107, '0_3_15');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">X_inO</span> <span class="id" title="var">c</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(108, '0_3_15');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">Bc</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="a:29" class="idref" href="#a:29"><span class="id" title="binder">a</span></a>:<span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#IsConnected"><span class="id" title="class">IsConnected</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Topological.html#a:28"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(109, '0_3_15');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(110, '0_3_15');
      "><br>
          <span class="id" title="var">rapply</span> (@<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#isconnected_O_leq"><span class="id" title="definition">isconnected_O_leq</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(111, '0_3_15');
      "><br>
          <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Modalities.Accessible.html#isconnected_acc_ngen"><span class="id" title="instance">isconnected_acc_ngen</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">a</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(112, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ooextendable_const_isconnected_inO"><span class="id" title="definition">ooextendable_const_isconnected_inO</span></a> <span class="id" title="var">O</span>);<br>
          [ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> [<span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]] | <span class="id" title="tactic">exact</span> <span class="id" title="var">X_inO</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(113, '0_3_15');
      "><br>
        + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#isconnected_from_elim_to_O"><span class="id" title="definition">isconnected_from_elim_to_O</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(114, '0_3_15');
      "><br>
          <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">O</span> (<a class="idref" href="HoTT.Truncations.Core.html#merely"><span class="id" title="definition">merely</span></a> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)))<br>
                                     (<span class="id" title="keyword">fun</span> <a id="b:31" class="idref" href="#b:31"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#to"><span class="id" title="method">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#b:30"><span class="id" title="variable">b</span></a>)))<br>
            <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(115, '0_3_15');
      "><br>
          <span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(116, '0_3_15');
      "><br>
          <span class="id" title="var">strip_truncations</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(117, '0_3_15');
      "><br>
          <span class="id" title="tactic">exact</span> (<span class="id" title="var">h</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(118, '0_3_15');
      "><br>
        + <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(119, '0_3_15');
      "><span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Modalities.Lex.html#isconnected_paths"><span class="id" title="definition">isconnected_paths</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(120, '0_3_15');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">Dnull</span>; <span class="id" title="var">rapply</span> (@<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#inO_leq"><span class="id" title="definition">inO_leq</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">O</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(121, '0_3_15');
      "><br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(122, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Extensions.html#equiv_ooextendable_isequiv"><span class="id" title="definition">equiv_ooextendable_isequiv</span></a><br>
                  (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">X</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(123, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Equiv.html#isequiv_contr_map"><span class="id" title="definition">isequiv_contr_map</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(124, '0_3_15');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <a id="x:34" class="idref" href="#x:34"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a><span class="id" title="var">X</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u:35" class="idref" href="#u:35"><span class="id" title="binder">u</span></a>:<span class="id" title="var">B</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Modalities.Topological.html#x:32"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u:33"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(125, '0_3_15');
      "><br>
        { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> (<a class="idref" href="HoTT.Types.Unit.html#equiv_unit_rec"><span class="id" title="definition">equiv_unit_rec</span></a> <span class="id" title="var">X</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(126, '0_3_15');
      "><br>
          <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#composeD"><span class="id" title="definition">composeD</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(127, '0_3_15');
      "><br>
          <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#equiv_path_arrow"><span class="id" title="definition">equiv_path_arrow</span></a>. }<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<span class="id" title="var">A</span> := <span class="id" title="var">D</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(128, '0_3_15');
      "><br>
        { <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Modalities.Accessible.html#isconnected_acc_ngen"><span class="id" title="instance">isconnected_acc_ngen</span></a>. }<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(129, '0_3_15');
      "><span class="id" title="var">strip_truncations</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">bc</span> : <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#IsConnMap"><span class="id" title="class">IsConnMap</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(131, '0_3_15');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(132, '0_3_15');
      "><br>
          <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)<br>
                                   <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Sigma.html#equiv_contr_sigma"><span class="id" title="definition">equiv_contr_sigma</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(133, '0_3_15');
      "><br>
          <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Modalities.Accessible.html#isconnected_acc_ngen"><span class="id" title="instance">isconnected_acc_ngen</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(134, '0_3_15');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">p</span> := <a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)<br>
                                 (<span class="id" title="keyword">fun</span> <a id="u:37" class="idref" href="#u:37"><span class="id" title="binder">u</span></a> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u:36"><span class="id" title="variable">u</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ 1)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(135, '0_3_15');
      "><br>
        <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(136, '0_3_15');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma'"><span class="id" title="definition">path_sigma'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><span class="id" title="var">q</span> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(137, '0_3_15');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(138, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Forall.html#transport_forall_constant"><span class="id" title="definition">transport_forall_constant</span></a>, <a class="idref" href="HoTT.Types.Paths.html#transport_paths_l"><span class="id" title="definition">transport_paths_l</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(139, '0_3_15');
      "><br>
        <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#conn_map_comp"><span class="id" title="definition">conn_map_comp</span></a> (<a class="idref" href="HoTT.Modalities.Nullification.html#Nul"><span class="id" title="definition">Nul</span></a> <span class="id" title="var">D</span>) (<a class="idref" href="HoTT.Types.Unit.html#unit_name"><span class="id" title="abbreviation">unit_name</span></a> <span class="id" title="var">b</span>)<br>
                               (<span class="id" title="keyword">fun</span> <a id="u:40" class="idref" href="#u:40"><span class="id" title="binder">u</span></a>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">f</span> <a class="idref" href="HoTT.Modalities.Topological.html#u:38"><span class="id" title="variable">u</span></a>)<br>
                               (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ 1) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> : <span class="id" title="var">p</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(140, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. }<br>
    <span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHn</span> <span class="id" title="var">D</span> <span class="id" title="var">OeqD</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">E</span> [<span class="id" title="var">HE</span> <span class="id" title="var">EeqD</span>]].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(141, '0_3_15');
      "><br>
    <span class="id" title="tactic">∃</span> <span class="id" title="var">E</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">HE</span> | ].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(142, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">EeqD</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(143, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">_</span> <span class="id" title="var">OeqB</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(144, '0_3_15');
      "><br>
    <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(145, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(146, '0_3_15');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
