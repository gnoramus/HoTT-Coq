<html>
<head>
<title>Core.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Core.v</h1>

<div class="code" title="File: Core.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(** * Definition of pseudonatural transformation *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 1
Time: 0.016s">
<div class="time" style="width: 16.161616161616%"></div>
<pre>Require Import Category.Core Functor.Core NaturalTransformation.Core.</pre>
</div>
<div class="code" title="File: Core.v
Line: 1
Time: 0.031s">
<div class="time" style="width: 31.313131313131%"></div>
<pre>
Require Import Pseudofunctor.Core.</pre>
</div>
<div class="code" title="File: Core.v
Line: 2
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import Category.Pi.</pre>
</div>
<div class="code" title="File: Core.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import FunctorCategory.Core.</pre>
</div>
<div class="code" title="File: Core.v
Line: 4
Time: 0.001s">
<div class="time" style="width: 1.010101010101%"></div>
<pre>
Require Import Category.Morphisms FunctorCategory.Morphisms.</pre>
</div>
<div class="code" title="File: Core.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import Functor.Composition.Core Functor.Identity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import NaturalTransformation.Composition.Core NaturalTransformation.Composition.Laws.</pre>
</div>
<div class="code" title="File: Core.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import NaturalTransformation.Identity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import NaturalTransformation.Isomorphisms.</pre>
</div>
<div class="code" title="File: Core.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import NaturalTransformation.Paths.</pre>
</div>
<div class="code" title="File: Core.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import FunctorCategory.Core.</pre>
</div>
<div class="code" title="File: Core.v
Line: 11
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Core.v
Line: 12
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Set Universe Polymorphism.</pre>
</div>
<div class="code" title="File: Core.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Core.v
Line: 15
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable All Variables.</pre>
</div>
<div class="code" title="File: Core.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Asymmetric Patterns.</pre>
</div>
<div class="code" title="File: Core.v
Line: 17
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Declare Scope pseudonatural_transformation_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Delimit Scope pseudonatural_transformation_scope with pseudonatural_transformation.</pre>
</div>
<div class="code" title="File: Core.v
Line: 20
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope natural_transformation_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 22
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope functor_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope morphism_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope pseudonatural_transformation_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Quoting Michael Shulman from an email:

    The 2-limit in question is sometimes called a "descent object", or
    the totalization of a truncated cosimplicial object.  It's a
    generalization of an equalizer.  The set of natural
    transformations between two ordinary functors [F],[G : C → D] is
    the equalizer of

    [Π_x D(Fx,Gx) ⇉ Π_{x→y} D(Fx,Gy)]

    The category of pseudonatural transformations between two
    2-functors is the descent object of

    [Π_x D(Fx,Gx) ⇉ Π_{x→y} D(Fx,Gy) ⇛ Π_{x→y→z} D(Fx,Gz)]

    where there are three maps from the second product to the third,
    corresponding to picking out [x→y], [y→z], and [x→z].

    In general, the descent object of

    [A ⇉ B ⇛ C]

    is the category of objects [a∈A] equipped with an isomorphism
    between their two images in [B] which results in a commutative
    triangle between their three images in [C]. *)

(** Later, he said (https://github.com/HoTT/HoTT/pull/382##issuecomment-41240787):

    The "naturality" axiom is only necessary if the domain is a
    2-category rather than a 1-category. However, the respect for
    units axiom really is necessary; I guess I forgot to mention that
    in the email. The way it comes up in the descent object is that
    there's a map from [B] to [A] given by projecting the components
    of identities, and the coherence cell has to become an identity
    when composed with that map. *)

(** We construct the parts as above, but inline the resulting definitions for speed.
&lt;&lt;
Module PseudonaturalTransformationParts.
  Section PseudonaturalTransformation.
    Context `{Funext}.

    Variable X : PreCategory.

    Variables F G : Pseudofunctor X.


    Definition A : PreCategory
      := (forall x : X, F x -&gt; G x)%category.
    Definition B : PreCategory
      := (forall x y (m : morphism X x y), F x -&gt; G y)%category.
    Definition C : PreCategory
      := (forall x y z (m1 : morphism X y z) (m2 : morphism X x y), F x -&gt; G z)%category.

    Definition a_part := Eval simpl in object A.

    Definition A_to_B_1 : Functor A B.
    Proof.
      refine (Build_Functor
                A B
                (fun x__Fx_to_Gx =&gt; fun x y m =&gt; x__Fx_to_Gx y o p_morphism_of F m)%functor
                (fun x__s x__d x__m =&gt; fun x y m =&gt; x__m y oR p_morphism_of F m)
                _
                _);
      simpl; repeat (intro || apply path_forall);
      [ apply composition_of_whisker_r
      | apply whisker_r_left_identity ].
    Defined.

    Definition A_to_B_2 : Functor A B.
    Proof.
      refine (Build_Functor
                A B
                (fun x__Fx_to_Gx =&gt; fun x y m =&gt; p_morphism_of G m o x__Fx_to_Gx x)%functor
                (fun x__s x__d x__m =&gt; fun x y m =&gt; p_morphism_of G m oL x__m x)
                _
                _);
      simpl; repeat (intro || apply path_forall);
      [ apply composition_of_whisker_l
      | apply whisker_l_right_identity ].
    Defined.

    Definition b_part (a : a_part)
      := Eval simpl in forall x y m, (A_to_B_1 a x y m &lt;~=~&gt; A_to_B_2 a x y m).

    Definition B_to_A : Functor B A
      := Build_Functor
           B A
           (fun xym__Fx_to_Gy =&gt; fun x =&gt; xym__Fx_to_Gy x x 1)
           (fun x__s x__d x__m =&gt; fun x =&gt; x__m x x 1)
           (fun _ _ _ _ _ =&gt; idpath)
           (fun _ =&gt; idpath).

    Definition b_id_part (a : a_part) (b : b_part a)
      := Eval simpl in
          forall x,
            (((left_identity_natural_transformation_1 _)
                o (p_identity_of G _ oR _)
                o (B_to_A _1 b x)
                o (_ oL (p_identity_of F _)^-1)
                o (left_identity_natural_transformation_2 _))
             = 1)%natural_transformation.

    Definition B_to_C_1 : Functor B C.
    Proof.
      refine (Build_Functor
                B C
                (fun xym__Fx_to_Gy =&gt; fun x y z m1 m2 =&gt; xym__Fx_to_Gy y z m1 o p_morphism_of F m2)%functor
                (fun xym__s xym__d xym__m =&gt; fun x y z m1 m2 =&gt; xym__m y z m1 oR p_morphism_of F m2)
                _
                _);
      simpl; repeat (intro || apply path_forall);
      [ apply composition_of_whisker_r
      | apply whisker_r_left_identity ].
    Defined.

    Definition B_to_C_2 : Functor B C.
    Proof.
      refine (Build_Functor
                B C
                (fun xym__Fx_to_Gy =&gt; fun x y z m1 m2 =&gt; p_morphism_of G m1 o xym__Fx_to_Gy x y m2)%functor
                (fun xym__s xym__d xym__m =&gt; fun x y z m1 m2 =&gt; p_morphism_of G m1 oL xym__m x y m2)
                _
                _);
      simpl; repeat (intro || apply path_forall);
      [ apply composition_of_whisker_l
      | apply whisker_l_right_identity ].
    Defined.

    Definition B_to_C_3 : Functor B C
      := Build_Functor
           B C
           (fun xym__Fx_to_Gy =&gt; fun x y z m1 m2 =&gt; xym__Fx_to_Gy x z (m1 o m2))
           (fun xym__s xym__d xym__m =&gt; fun x y z m1 m2 =&gt; xym__m x z (m1 o m2))
           (fun _ _ _ _ _ =&gt; idpath)
           (fun _ =&gt; idpath).

    Definition c_part' (a : a_part) (b : b_part a)
    : forall (x y z : X) (m1 : morphism X y z) (m2 : morphism X x y), Type.
    Proof.
      hnf in a, b.
      pose (fun x y m =&gt; (b x y m : morphism _ _ _)) as bB; simpl in *.
      intros x y z m1 m2.
      exact (((associator_2 _ _ _)
                o (B_to_C_2 _1 bB x y z m1 m2)
                o (associator_1 _ _ _)
                o (B_to_C_1 _1 bB x y z m1 m2)
                o (associator_2 _ _ _))
             = ((p_composition_of G _ _ _ m1 m2 oR _)
                  o (B_to_C_3 _1 bB x y z m1 m2)
                  o (_ oL (p_composition_of F _ _ _ m1 m2)^-1)))%natural_transformation.
    Defined.

    Arguments c_part' / .

    Definition c_part (a : a_part) (b : b_part a)
      := Eval simpl in forall x y z m1 m2, @c_part' a b x y z m1 m2.

    (** We would like to define [PseudonaturalTransformation] here, then our types are η-expanded. *)
  (*Record PseudonaturalTransformation :=
      { p_components_of :&gt; a_part;
        p_commutes : b_part p_components_of;
        p_commutes_coherent : c_part p_commutes }.*)
  End PseudonaturalTransformation.
End PseudonaturalTransformationParts.

Print PseudonaturalTransformationParts.a_part.
Print PseudonaturalTransformationParts.b_part.
Print PseudonaturalTransformationParts.b_id_part.
Print PseudonaturalTransformationParts.c_part.
&gt;&gt; *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 198
Time: 0.099s">
<div class="time" style="width: 100%"></div>
<pre>Record PseudonaturalTransformation `{Funext} (X : PreCategory)
       (F G : Pseudofunctor X) :=
  { p_components_of
      :&gt; forall a : X, Functor (F a) (G a);
    p_commutes
    : forall (x y : X) (m : morphism X x y),
        ((p_components_of y o p_morphism_of F m)%functor &lt;~=~&gt; (p_morphism_of G m o p_components_of x)%functor)%natural_transformation;
    p_commutes_respects_identity
    : forall x : X,
        ((left_identity_natural_transformation_1 (p_components_of x))
           o (p_identity_of G x oR p_components_of x)
           o (p_commutes x x 1%morphism)
           o (p_components_of x oL (p_identity_of F x) ^-1)
           o (right_identity_natural_transformation_2 (p_components_of x))
         = 1)%natural_transformation;
    p_commutes_respects_composition
    : forall (x y z : X) (m1 : morphism X y z) (m2 : morphism X x y),
        (((associator_2 (p_morphism_of G m1) (p_morphism_of G m2) (p_components_of x))
            o (p_morphism_of G m1 oL p_commutes x y m2)
            o (associator_1 (p_morphism_of G m1) (p_components_of y) (p_morphism_of F m2))
            o (p_commutes y z m1 oR p_morphism_of F m2)
            o (associator_2 (p_components_of z) (p_morphism_of F m1) (p_morphism_of F m2)))
         = ((p_composition_of G x y z m1 m2 oR p_components_of x o p_commutes x z (m1 o m2)%morphism)
              o (p_components_of z oL (p_composition_of F x y z m1 m2) ^-1)))%natural_transformation }.</pre>
</div>
<div class="code" title="File: Core.v
Line: 221
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Bind Scope pseudonatural_transformation_scope with PseudonaturalTransformation.</pre>
</div>
<div class="code" title="File: Core.v
Line: 223
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Create HintDb pseuodnatural_transformation discriminated.</pre>
</div>
<div class="code" title="File: Core.v
Line: 225
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments p_components_of {_} {X}%category {F G}%pseudofunctor T%pseudonatural_transformation
          a%object : rename, simpl nomatch.</pre>
</div>
<div class="code" title="File: Core.v
Line: 228
Time: 0.011s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>

#[export]
Hint Resolve p_commutes_respects_identity p_commutes_respects_composition : category pseudonatural_transformation.</pre>
</div>
<div class="code" title="File: Core.v
Line: 232
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

