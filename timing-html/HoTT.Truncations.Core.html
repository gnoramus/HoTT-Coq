<html>
<head>
<title>Core.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Core.v</h1>

<div class="code" title="File: Core.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 2
Time: 0.031s">
<div class="time" style="width: 19.496855345912%"></div>
<pre>Require Import Basics Types.</pre>
</div>
<div class="code" title="File: Core.v
Line: 2
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
Require Import TruncType HProp.</pre>
</div>
<div class="code" title="File: Core.v
Line: 3
Time: 0.032s">
<div class="time" style="width: 20.125786163522%"></div>
<pre>
Require Import Modalities.Modality Modalities.Descent.</pre>
</div>
<div class="code" title="File: Core.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Truncations of types, in all dimensions. *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable Variables A X n.</pre>
</div>
<div class="code" title="File: Core.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Definition. *)

(** The definition of [Trunc n], the n-truncation of a type.

If Coq supported higher inductive types natively, we would construct this as somthing like:

   Inductive Trunc n (A : Type) : Type :=
   | tr : A -&gt; Trunc n A
   | istrunc_truncation : forall (f : Sphere n.+1 -&gt; Trunc n A)
       (x : Sphere n.+1), f x = f North.

However, while we are faking our higher-inductives anyway, we can take some shortcuts, rather than translating the definition above.  Firstly, we directly posit a “constructor” giving truncatedness, rather than rephrasing it in terms of maps of spheres.  Secondly, we omit the “computation rule” for this constructor, since it is implied by truncatedness of the result type (and, for essentially that reason, is never wanted in practice anyway).
*)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Export Trunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Delimit Scope trunc_scope with trunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Cumulative Private Inductive Trunc (n : trunc_index) (A :Type) : Type :=
  tr : A -&gt; Trunc n A.</pre>
</div>
<div class="code" title="File: Core.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Bind Scope trunc_scope with Trunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments tr {n A} a.</pre>
</div>
<div class="code" title="File: Core.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Without explicit universe parameters, this instance is insufficiently polymorphic. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance istrunc_truncation (n : trunc_index) (A : Type@{i})
: IsTrunc@{j} n (Trunc@{i} n A).</pre>
</div>
<div class="code" title="File: Core.v
Line: 32
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Admitted.</pre>
</div>
<div class="code" title="File: Core.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition Trunc_ind {n A}
  (P : Trunc n A -&gt; Type) {Pt : forall aa, IsTrunc n (P aa)}
  : (forall a, P (tr a)) -&gt; (forall aa, P aa)
:= (fun f aa =&gt; match aa with tr a =&gt; fun _ =&gt; f a end Pt).</pre>
</div>
<div class="code" title="File: Core.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Trunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 40
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The non-dependent version of the eliminator. *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 43
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>Definition Trunc_rec {n A X} `{IsTrunc n X}
  : (A -&gt; X) -&gt; (Trunc n A -&gt; X)
:= Trunc_ind (fun _ =&gt; X).</pre>
</div>
<div class="code" title="File: Core.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** [Trunc] is a modality *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition Tr (n : trunc_index) : Modality.</pre>
</div>
<div class="code" title="File: Core.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 49
Time: 0.039s">
<div class="time" style="width: 24.528301886792%"></div>
<pre>
  srapply (Build_Modality (IsTrunc n)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 50
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B ? f ?; apply (trunc_equiv A f).</pre>
</div>
<div class="code" title="File: Core.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (Trunc n).</pre>
</div>
<div class="code" title="File: Core.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros; apply istrunc_truncation.</pre>
</div>
<div class="code" title="File: Core.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A; apply tr.</pre>
</div>
<div class="code" title="File: Core.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 55
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B ? f oa; cbn in *.</pre>
</div>
<div class="code" title="File: Core.v
Line: 55
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exact (Trunc_ind B f oa).</pre>
</div>
<div class="code" title="File: Core.v
Line: 56
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros; reflexivity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We don't usually declare modalities as coercions, but this particular one is convenient so that lemmas about (for instance) connected maps can be applied to truncation modalities without the user/reader needing to be (particularly) aware of the general notion of modality. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Coercion Tr : trunc_index &gt;-&gt; Modality.</pre>
</div>
<div class="code" title="File: Core.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
(** However, if the coercion is not printed, then we get things like [Tr (-1) X] being printed as [(-1) X], which is terribly confusing.  So we tell Coq to always print this coercion.  This does mean that although the user can type things like [IsConnected n X], it will always be displayed back as [IsConnected (Tr n) X]. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Add Printing Coercion Tr.</pre>
</div>
<div class="code" title="File: Core.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section TruncationModality.</pre>
</div>
<div class="code" title="File: Core.v
Line: 63
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context (n : trunc_index).</pre>
</div>
<div class="code" title="File: Core.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition trunc_iff_isequiv_truncation (A : Type)
    : IsTrunc n A &lt;-&gt; IsEquiv (@tr n A)
    := inO_iff_isequiv_to_O (Tr n) A.</pre>
</div>
<div class="code" title="File: Core.v
Line: 68
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Instance isequiv_tr A `{IsTrunc n A} : IsEquiv (@tr n A)
    := fst (trunc_iff_isequiv_truncation A) _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 71
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

  Definition equiv_tr (A : Type) `{IsTrunc n A}
    : A &lt;~&gt; Tr n A
  := Build_Equiv _ _ (@tr n A) _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 75
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

  Definition untrunc_istrunc {A : Type} `{IsTrunc n A}
    : Tr n A -&gt; A
    := (@tr n A)^-1.</pre>
</div>
<div class="code" title="File: Core.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Functoriality *)

  (** Since a modality lives on a single universe, by default if we simply define [Trunc_functor] to be [O_functor] then it would force [X] and [Y] to live in the same universe.  But since we defined [Trunc] as a cumulative inductive, if we add universe annotations we can make [Trunc_functor] more universe-polymorphic than [O_functor] is.  This is sometimes useful.  *)
 </pre>
</div>
<div class="code" title="File: Core.v
Line: 84
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition Trunc_functor@{i j k} {X : Type@{i}} {Y : Type@{j}} (f : X -&gt; Y)
    : Tr@{i} n X -&gt; Tr@{j} n Y
    := O_functor@{k k k} (Tr n) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 86
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

  Global Instance Trunc_functor_isequiv {X Y : Type}
    (f : X -&gt; Y) `{IsEquiv _ _ f}
    : IsEquiv (Trunc_functor f)
    := isequiv_O_functor (Tr n) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition Trunc_functor_equiv {X Y : Type} (f : X &lt;~&gt; Y)
    : Tr n X &lt;~&gt; Tr n Y
    := equiv_O_functor (Tr n) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 95
Time: 0.003s">
<div class="time" style="width: 1.8867924528302%"></div>
<pre>

  Definition Trunc_functor_compose {X Y Z} (f : X -&gt; Y) (g : Y -&gt; Z)
    : Trunc_functor (g o f) == Trunc_functor g o Trunc_functor f
    := O_functor_compose (Tr n) f g.</pre>
</div>
<div class="code" title="File: Core.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition Trunc_functor_idmap (X : Type)
    : @Trunc_functor X X idmap == idmap
    := O_functor_idmap (Tr n) X.</pre>
</div>
<div class="code" title="File: Core.v
Line: 103
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

  Definition isequiv_Trunc_functor {X Y} (f : X -&gt; Y) `{IsEquiv _ _ f}
    : IsEquiv (Trunc_functor f)
    := isequiv_O_functor (Tr n) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition equiv_Trunc_prod_cmp `{Funext} {X Y}
    : Tr n (X * Y) &lt;~&gt; Tr n X * Tr n Y
    := equiv_O_prod_cmp (Tr n) X Y.</pre>
</div>
<div class="code" title="File: Core.v
Line: 111
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End TruncationModality.</pre>
</div>
<div class="code" title="File: Core.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We have to teach Coq to translate back and forth between [IsTrunc n] and [In (Tr n)]. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance inO_tr_istrunc {n : trunc_index} (A : Type) `{IsTrunc n A}
  : In (Tr n) A.</pre>
</div>
<div class="code" title="File: Core.v
Line: 116
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 119
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Having both of these as [Instance]s would cause infinite loops. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition istrunc_inO_tr {n : trunc_index} (A : Type) `{In (Tr n) A}
  : IsTrunc n A.</pre>
</div>
<div class="code" title="File: Core.v
Line: 122
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 124
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Instead, we make the latter an immediate instance, but with high cost (i.e. low priority) so that it doesn't override the ordinary lemmas about truncation.  Unfortunately, [Hint Immediate] doesn't allow specifying a cost, so we use [Hint Extern] instead. *)
(** Hint Immediate istrunc_inO_tr : typeclass_instances. *)
(** See https://github.com/coq/coq/issues/11697 *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>#[export]
Hint Extern 1000 (IsTrunc _ _) =&gt; simple apply istrunc_inO_tr; solve [ trivial ] : typeclass_instances.</pre>
</div>
<div class="code" title="File: Core.v
Line: 130
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
(** This doesn't seem to be quite the same as [Hint Immediate] with a different cost either, though; see the comment in the proof of [Trunc_min] below.  *)

(** Unfortunately, this isn't perfect; Coq still can't always find [In n] hypotheses in the context when it wants [IsTrunc].  You can always apply [istrunc_inO_tr] explicitly, but sometimes it also works to just [pose] it into the context. *)

(** We do the same for [IsTruncMap n] and [MapIn (Tr n)]. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 135
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance mapinO_tr_istruncmap {n : trunc_index} {A B : Type}
  (f : A -&gt; B) `{IsTruncMap n A B f}
  : MapIn (Tr n) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 138
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 139
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 140
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition istruncmap_mapinO_tr {n : trunc_index} {A B : Type}
  (f : A -&gt; B) `{MapIn (Tr n) _ _ f}
  : IsTruncMap n f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

#[export]
Hint Immediate istruncmap_mapinO_tr : typeclass_instances.</pre>
</div>
<div class="code" title="File: Core.v
Line: 150
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** A few special things about the (-1)-truncation. *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Open Scope trunc_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We define [merely A] to be an inhabitant of the universe [hProp] of hprops, rather than a type.  We can always treat it as a type because there is a coercion, but this means that if we need an element of [hProp] then we don't need a separate name for it. *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition merely (A : Type@{i}) : hProp@{i} := BuildhProp (Tr (-1) A).</pre>
</div>
<div class="code" title="File: Core.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition hexists {X} (P : X -&gt; Type) : hProp := merely (sigT P).</pre>
</div>
<div class="code" title="File: Core.v
Line: 158
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition hor (P Q : Type) : hProp := merely (P + Q).</pre>
</div>
<div class="code" title="File: Core.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation "A \/ B" := (hor A B) : type_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition himage {X Y} (f : X -&gt; Y) := image (Tr (-1)) f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition contr_inhab_prop {A} `{IsHProp A} (ma : merely A) : Contr A.</pre>
</div>
<div class="code" title="File: Core.v
Line: 166
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 167
Time: 0.006s">
<div class="time" style="width: 3.7735849056604%"></div>
<pre>
  refine (@contr_trunc_conn (Tr (-1)) A _ _); try assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (contr_inhabited_hprop _ ma).</pre>
</div>
<div class="code" title="File: Core.v
Line: 169
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 170
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Surjections are the (-1)-connected maps, but they can be characterized more simply since an inhabited hprop is automatically contractible. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation IsSurjection := (IsConnMap (Tr (-1))).</pre>
</div>
<div class="code" title="File: Core.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition BuildIsSurjection {A B} (f : A -&gt; B)
  : (forall b, merely (hfiber f b)) -&gt; IsSurjection f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 175
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 176
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros H b; refine (contr_inhabited_hprop _ _).</pre>
</div>
<div class="code" title="File: Core.v
Line: 177
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply H.</pre>
</div>
<div class="code" title="File: Core.v
Line: 178
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 179
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A family of types is pointwise merely inhabited if and only if the corresponding fibration is surjective. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 181
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>Lemma iff_merely_issurjection {X : Type} (P : X -&gt; Type)
  : (forall x, merely (P x)) &lt;-&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</pre>
</div>
<div class="code" title="File: Core.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (iff_compose _ (iff_forall_inO_mapinO_pr1 (Conn _) P)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 184
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
  apply iff_functor_forall; intro a.</pre>
</div>
<div class="code" title="File: Core.v
Line: 185
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
  symmetry; apply (iff_contr_hprop (Tr (-1) (P a))).</pre>
</div>
<div class="code" title="File: Core.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 187
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Lemma equiv_merely_issurjection `{Funext} {X : Type} (P : X -&gt; Type)
  : (forall x, merely (P x)) &lt;~&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</pre>
</div>
<div class="code" title="File: Core.v
Line: 190
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* Can also be proved from equiv_forall_inO_mapinO_pr1. *)
 </pre>
</div>
<div class="code" title="File: Core.v
Line: 192
Time: 0.005s">
<div class="time" style="width: 3.1446540880503%"></div>
<pre>exact (equiv_iff_hprop_uncurried (iff_merely_issurjection P)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 193
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition isequiv_surj_emb {A B} (f : A -&gt; B)
  `{IsSurjection f} `{IsEmbedding f}
  : IsEquiv f.</pre>
</div>
<div class="code" title="File: Core.v
Line: 197
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 198
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (@isequiv_conn_ino_map (Tr (-1))); assumption.</pre>
</div>
<div class="code" title="File: Core.v
Line: 199
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 200
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Tactic to remove truncations in hypotheses if possible. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 202
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac strip_truncations :=
  (** search for truncated hypotheses *)
  progress repeat match goal with
                    | [ T : _ |- _ ]
                      =&gt; revert_opaque T;
                        refine (@Trunc_ind _ _ _ _ _);
                        (** ensure that we didn't generate more than one subgoal, i.e. that the goal was appropriately truncated *)
                        [];
                        intro T
                  end.</pre>
</div>
<div class="code" title="File: Core.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Iterated truncations *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 214
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition Trunc_min n m X : Tr n (Tr m X) &lt;~&gt; Tr (trunc_index_min n m) X.</pre>
</div>
<div class="code" title="File: Core.v
Line: 214
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 215
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct (trunc_index_min_path n m) as [p|q].</pre>
</div>
<div class="code" title="File: Core.v
Line: 216
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  +</pre>
</div>
<div class="code" title="File: Core.v
Line: 217
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> assert (l := trunc_index_min_leq_right n m).</pre>
</div>
<div class="code" title="File: Core.v
Line: 217
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    destruct p^; clear p.</pre>
</div>
<div class="code" title="File: Core.v
Line: 218
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    symmetry.</pre>
</div>
<div class="code" title="File: Core.v
Line: 219
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    srapply equiv_adjointify.</pre>
</div>
<div class="code" title="File: Core.v
Line: 220
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Core.v
Line: 221
Time: 0.004s">
<div class="time" style="width: 2.5157232704403%"></div>
<pre> srapply Trunc_rec.</pre>
</div>
<div class="code" title="File: Core.v
Line: 221
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact (fun x =&gt; tr (tr x)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 222
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Core.v
Line: 222
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Core.v
Line: 223
Time: 0.004s">
<div class="time" style="width: 2.5157232704403%"></div>
<pre> srapply Trunc_rec.</pre>
</div>
<div class="code" title="File: Core.v
Line: 223
Time: 0.007s">
<div class="time" style="width: 4.4025157232704%"></div>
<pre>
      srapply Trunc_rec.</pre>
</div>
<div class="code" title="File: Core.v
Line: 224
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
      1: srapply trunc_leq.</pre>
</div>
<div class="code" title="File: Core.v
Line: 225
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact tr.</pre>
</div>
<div class="code" title="File: Core.v
Line: 226
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Core.v
Line: 226
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Core.v
Line: 227
Time: 0.016s">
<div class="time" style="width: 10.062893081761%"></div>
<pre> srapply Trunc_ind.</pre>
</div>
<div class="code" title="File: Core.v
Line: 227
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      simpl.</pre>
</div>
<div class="code" title="File: Core.v
Line: 228
Time: 0.032s">
<div class="time" style="width: 20.125786163522%"></div>
<pre>
      srapply (Trunc_ind (n:=m)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 229
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      2: reflexivity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 230
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      intro.</pre>
</div>
<div class="code" title="File: Core.v
Line: 231
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply istrunc_paths.</pre>
</div>
<div class="code" title="File: Core.v
Line: 232
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre>
      srapply (trunc_leq (m:=n)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 233
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      by apply trunc_index_leq_succ'.</pre>
</div>
<div class="code" title="File: Core.v
Line: 234
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Core.v
Line: 234
Time: 0.038s">
<div class="time" style="width: 23.899371069182%"></div>
<pre>
    srapply Trunc_ind; reflexivity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 235
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  +</pre>
</div>
<div class="code" title="File: Core.v
Line: 236
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> set (min := trunc_index_min n m).</pre>
</div>
<div class="code" title="File: Core.v
Line: 236
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (paths_ind _
      (fun m _ =&gt; Tr n (Tr m X) &lt;~&gt; Tr min X) _ m q).</pre>
</div>
<div class="code" title="File: Core.v
Line: 238
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold min; clear min.</pre>
</div>
<div class="code" title="File: Core.v
Line: 239
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    symmetry.</pre>
</div>
<div class="code" title="File: Core.v
Line: 240
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
    srapply equiv_tr.</pre>
</div>
<div class="code" title="File: Core.v
Line: 241
Time: 0.008s">
<div class="time" style="width: 5.0314465408805%"></div>
<pre>
    srapply trunc_leq.</pre>
</div>
<div class="code" title="File: Core.v
Line: 242
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    3:{</pre>
</div>
<div class="code" title="File: Core.v
Line: 243
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (** Strangely, if [istrunc_inO_tr] were a [Hint Immediate], rather than our [Hint Extern], then typeclass inference would be able to find this all on its own, although the documentation for [Hint Immediate] suggests that it shouldn't because the following tactic doesn't solve it completely. *)
       </pre>
</div>
<div class="code" title="File: Core.v
Line: 244
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>simple apply istrunc_inO_tr; trivial.</pre>
</div>
<div class="code" title="File: Core.v
Line: 244
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        exact _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 245
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Core.v
Line: 245
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply trunc_index_min_leq_left.</pre>
</div>
<div class="code" title="File: Core.v
Line: 246
Time: 0.005s">
<div class="time" style="width: 3.1446540880503%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 247
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition Trunc_swap n m X : Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X).</pre>
</div>
<div class="code" title="File: Core.v
Line: 249
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 250
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (_ oE equiv_transport (fun x =&gt; Tr x _) _ _ _ oE Trunc_min n m _).</pre>
</div>
<div class="code" title="File: Core.v
Line: 251
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  2: apply trunc_index_min_swap.</pre>
</div>
<div class="code" title="File: Core.v
Line: 252
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  symmetry.</pre>
</div>
<div class="code" title="File: Core.v
Line: 253
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply Trunc_min.</pre>
</div>
<div class="code" title="File: Core.v
Line: 254
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 255
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Separatedness and path-spaces of truncations *)

</pre>
</div>
<div class="code" title="File: Core.v
Line: 258
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section SeparatedTrunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 258
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope subuniverse_scope.</pre>
</div>
<div class="code" title="File: Core.v
Line: 260
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The [n.+1]-truncation modality consists of the separated types for the [n]-truncation modality. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 262
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance O_eq_Tr (n : trunc_index)
  : Tr n.+1 &lt;=&gt; Sep (Tr n).</pre>
</div>
<div class="code" title="File: Core.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 264
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  split; intros A A_inO.</pre>
</div>
<div class="code" title="File: Core.v
Line: 265
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 266
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre> intros x y; exact _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 266
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 267
Time: 0.132s">
<div class="time" style="width: 83.018867924528%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 267
Time: 0.159s">
<div class="time" style="width: 100%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 268
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** It follows that [Tr n &lt;&lt;&lt; Tr n.+1].  However, it is easier to prove this directly than to go through separatedness. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 270
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance O_leq_Tr (n : trunc_index)
  : Tr n &lt;= Tr n.+1.</pre>
</div>
<div class="code" title="File: Core.v
Line: 271
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 272
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre>
  intros A ?; exact _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 273
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 274
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Global Instance O_strong_leq_Tr (n : trunc_index)
  : Tr n &lt;&lt; Tr n.+1.</pre>
</div>
<div class="code" title="File: Core.v
Line: 277
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 278
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>
  srapply O_strong_leq_trans_l.</pre>
</div>
<div class="code" title="File: Core.v
Line: 279
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 280
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** For some reason, this causes typeclass search to spin. *)</pre>
</div>
<div class="code" title="File: Core.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Instance O_lex_leq_Tr `{Univalence} (n : trunc_index)
  : Tr n &lt;&lt;&lt; Tr n.+1.</pre>
</div>
<div class="code" title="File: Core.v
Line: 283
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Core.v
Line: 284
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre>
  intros A; unshelve econstructor; intros P' P_inO; pose (P := fun x =&gt; BuildTruncType n (P' x)).</pre>
</div>
<div class="code" title="File: Core.v
Line: 285
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> refine (Trunc_rec P).</pre>
</div>
<div class="code" title="File: Core.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 287
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre> intros; exact _.</pre>
</div>
<div class="code" title="File: Core.v
Line: 287
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Core.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros; cbn.</pre>
</div>
<div class="code" title="File: Core.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Core.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Core.v
Line: 289
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

Definition path_Tr {n A} (x y : A)
  : Tr n (x = y) -&gt; (tr x = tr y :&gt; Tr n.+1 A)
  := path_OO (Tr n.+1) (Tr n) x y.</pre>
</div>
<div class="code" title="File: Core.v
Line: 293
Time: 0.002s">
<div class="time" style="width: 1.2578616352201%"></div>
<pre>

Definition equiv_path_Tr `{Univalence} {n A} (x y : A)
  : Tr n (x = y) &lt;~&gt; (tr x = tr y :&gt; Tr n.+1 A)
  := equiv_path_OO (Tr n.+1) (Tr n) x y.</pre>
</div>
<div class="code" title="File: Core.v
Line: 297
Time: 0.001s">
<div class="time" style="width: 0.62893081761006%"></div>
<pre>

End SeparatedTrunc.</pre>
</div>
<div class="code" title="File: Core.v
Line: 300
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** If you are looking for a theorem about truncation, you may want to read the note "Finding Theorems" in "STYLE.md". *)

</pre>
</div>
</body>
</html>

