<html>
<head>
<title>PathAny.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for PathAny.v</h1>

<div class="code" title="File: PathAny.v
Line: 1
Time: 0.033s">
<div class="time" style="width: 100%"></div>
<pre>Require Import Basics Types.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A nice method for proving characterizations of path-types of nested sigma-types, due to Rijke. *)

(** To show that the based path-type of [A] is equivalent to some specified family [P], it suffices to show that [P] is reflexive and its total space is contractible. This is part of Theorem 5.8.2, namely (iv) implies (iii). *)</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_from_contr {A : Type} (a : A) (P : A -&gt; Type)
           (Prefl : P a)
           (cp : Contr {y:A &amp; P y} )
           (b : A)
  : P b &lt;~&gt; a = b.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply equiv_inverse.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 11
Time: 0.007s">
<div class="time" style="width: 21.212121212121%"></div>
<pre>
  srefine (Build_Equiv _ _ _ _).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 12
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  {</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros []; apply Prefl.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  revert b; apply isequiv_from_functor_sigma.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (* For some reason, typeclass search can't find the Contr instances unless we give the types explicitly. *)
 </pre>
</div>
<div class="code" title="File: PathAny.v
Line: 16
Time: 0.002s">
<div class="time" style="width: 6.0606060606061%"></div>
<pre>refine (@isequiv_contr_contr {x:A &amp; a=x} {x:A &amp; P x} _ _ _).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 16
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 17
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This is another result for characterizing the path type of [A] when given an equivalence [e : B &lt;~&gt; A], such as an [issig] lemma for [A]. It can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_along_equiv {A B : Type} {P : A -&gt; A -&gt; Type}
           (e : B &lt;~&gt; A)
           (K : forall b0 b1 : B, P (e b0) (e b1) &lt;~&gt; b0 = b1)
  : forall a0 a1 : A, P a0 a1 &lt;~&gt; a0 = a1.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 22
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 23
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>
  equiv_intros e b0 b1.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (_ oE K b0 b1).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply equiv_ap'.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This simply combines the two previous results, a common idiom. Again, it can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_issig_contr {A B : Type} {P : A -&gt; A -&gt; Type}
           (e : B &lt;~&gt; A)
           (Prefl : forall b, P (e b) (e b))
           (cp : forall b1, Contr {b2 : B &amp; P (e b1) (e b2)})
  : forall a0 a1 : A, P a0 a1 &lt;~&gt; a0 = a1.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (equiv_path_along_equiv e).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 35
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro a0.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 36
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>
  srapply equiv_path_from_contr.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 37
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply Prefl.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** After [equiv_path_issig_contr], we are left showing the contractibility of a sigma-type whose base and fibers are large nested sigma-types of the same depth.  Moreover, we expect that the types appearing in those two large nested sigma-types "pair up" to form contractible based "path-types".  The following lemma "peels off" the first such pair, whose contractibility can often be found with typeclass search.  The remaining contractibility goal is then simplified by substituting the center of contraction of that first based "path-type", or more precisely a *specific* center that may or may not be the one given by the contractibility instance; the latter freedom sometimes makes things faster and simpler. *)</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 41
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>Definition contr_sigma_sigma (A : Type) (B : A -&gt; Type)
           (C : A -&gt; Type) (D : forall a, B a -&gt; C a -&gt; Type)
           {cac : Contr {x:A &amp; C x} }
           (a : A) (c : C a)
           {ccd : Contr {y:B a &amp; D a y c } }
  : Contr {ab : {x:A &amp; B x} &amp; {y:C ab.1 &amp; D ab.1 ab.2 y} }.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (d := (center {y:B a &amp; D a y c}).2).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 48
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>
  set (b := (center {y:B a &amp; D a y c}).1) in *.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 49
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  exists ((a;b);(c;d)).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 50
Time: 0.003s">
<div class="time" style="width: 9.0909090909091%"></div>
<pre>
  intros [[a' b'] [c' d']]; cbn in *.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (ac' := (a';c')).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (bd' := (b';d') : {y:B ac'.1 &amp; D ac'.1 y ac'.2}).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 53
Time: 0.002s">
<div class="time" style="width: 6.0606060606061%"></div>
<pre>
  change (((a;b);(c;d)) = ((ac'.1;bd'.1);(ac'.2;bd'.2))
          :&gt; {ab : {x:A &amp; B x} &amp; {y:C ab.1 &amp; D ab.1 ab.2 y} }).</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 55
Time: 0.001s">
<div class="time" style="width: 3.030303030303%"></div>
<pre>
  clearbody ac' bd'; clear a' b' c' d'.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 56
Time: 0.006s">
<div class="time" style="width: 18.181818181818%"></div>
<pre>
  destruct (@path_contr {x:A &amp; C x} _ (a;c) ac').</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 57
Time: 0.009s">
<div class="time" style="width: 27.272727272727%"></div>
<pre>
  destruct (@path_contr {y:B a &amp; D a y c} _ (b;d) bd').</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 59
Time: 0.003s">
<div class="time" style="width: 9.0909090909091%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This tactic just applies the previous lemma, using a match to figure out the appropriate type families so the user doesn't have to specify them. *)</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac contr_sigsig a c :=
  match goal with
  | [ |- Contr (@sig (@sig ?A ?B) (fun ab =&gt; @sig (@?C ab) (@?D ab))) ] =&gt;
    (* The lemma only applies when C depends only on the first component of ab, so we need to factor it somehow through pr1. *)
    let C' := fresh in
    transparent assert (C' : {C' : A -&gt; Type &amp; forall ab, C' ab.1 = C ab});
    [ eexists; intros ab; reflexivity
    | nrefine (contr_sigma_sigma A B C'.1 (fun a b c =&gt; D (a;b) c) a c);
      (** In practice, usually the first [Contr] hypothesis can be found by typeclass search, so we try that.  But we don't try on the second one, since often it can't be, and trying can be slow. *)
      [ try exact _ | subst C' ] ]
  end.</pre>
</div>
<div class="code" title="File: PathAny.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** For examples of the use of this tactic, see for instance [Factorization] and [Idempotents]. *)

</pre>
</div>
</body>
</html>

