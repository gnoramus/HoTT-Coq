<html>
<head>
<title>Specif.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Specif.v</h1>

<div class="code" title="File: Specif.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* &lt;O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)

(************************************************************************)
(*   This file has been modified for the purposes of the HoTT library.  *)
(************************************************************************)

(** Basic specifications : sets that may contain logical information *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 14
Time: 0.009s">
<div class="time" style="width: 100%"></div>
<pre>

Require Import Notations.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import Datatypes.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 17
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope identity_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 18
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
Require Import Logic.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Unset Elimination Schemes.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 20
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** [(sig A P)], or more suggestively [{x:A &amp; (P x)}] is a Sigma-type.
    Similarly for [(sig2 A P Q)], also written [{x:A &amp; (P x) &amp; (Q x)}]. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Record sig {A} (P : A -&gt; Type) := exist { proj1_sig : A ; proj2_sig : P proj1_sig }.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Scheme sig_rect := Induction for sig Sort Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We make the parameters maximally inserted so that we can pass around [pr1] as a function and have it actually mean "first projection" in, e.g., [ap]. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Arguments exist {A}%type P%type _ _.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments proj1_sig {A P} _ / .</pre>
</div>
<div class="code" title="File: Specif.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments proj2_sig {A P} _ / .</pre>
</div>
<div class="code" title="File: Specif.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Inductive sig2 (A:Type) (P Q:A -&gt; Type) : Type :=
    exist2 : forall x:A, P x -&gt; Q x -&gt; sig2 P Q.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Scheme sig2_rect := Induction for sig2 Sort Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments sig (A P)%type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments sig2 (A P Q)%type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** *** Notations *)

(** In standard Coq, [sig] and [sig2] are defined as "subset types" which sum over predicates [P:A-&gt;Prop], while [sigT] and [sigT2] are the [Type] variants.  Because we don't use [Prop], we combine the two versions, and make [sigT] a notation for [sig].  Note that some parts of Coq (like [Program Definition]) expect [sig] to be present. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation sigT := sig (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation existT := exist (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT_rect := sig_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT_rec := sig_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT_ind := sig_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT2 := sig2 (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 49
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation existT2 := exist2 (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 50
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT2_rect := sig2_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT2_rec := sig2_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation sigT2_ind := sig2_rect (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation  ex_intro := existT (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 55
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation "{ x | P }" := (sigT (fun x =&gt; P)) : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation "{ x | P &amp; Q }" := (sigT2 (fun x =&gt; P) (fun x =&gt; Q)) : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation "{ x : A | P }" := (sigT (A := A) (fun x =&gt; P)) : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 59
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation "{ x : A | P &amp; Q }" := (sigT2 (A := A) (fun x =&gt; P) (fun x =&gt; Q)) :
  type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation "'exists' x .. y , p" := (sigT (fun x =&gt; .. (sigT (fun y =&gt; p)) ..))
  (at level 200, x binder, right associativity,
   format "'[' 'exists'  '/  ' x  ..  y ,  '/  ' p ']'")
  : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 66
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation "'exists2' x , p &amp; q" := (sigT2 (fun x =&gt; p) (fun x =&gt; q))
  (at level 200, x name, p at level 200, right associativity) : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 69
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation "'exists2' x : t , p &amp; q" := (sigT2 (fun x:t =&gt; p) (fun x:t =&gt; q))
  (at level 200, x name, t at level 200, p at level 200, right associativity,
    format "'[' 'exists2'  '/  ' x  :  t ,  '/  ' '[' p  &amp;  '/' q ']' ']'")
  : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Definition exist := existT.  (* (only parsing). *) *)
(* Definition sig := sigT.  (* (only parsing). *) *)
(* Notation sig2 := (@sigT2 _) (only parsing). *)
(* Notation exist2 := (@existT2 _) (only parsing). *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation "{ x : A  &amp; P }" := (sigT (fun x:A =&gt; P)) : type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation "{ x : A  &amp; P  &amp; Q }" := (sigT2 (fun x:A =&gt; P) (fun x:A =&gt; Q)) :
  type_scope.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
(* Notation "{ x &amp; P }" := (sigT (fun x:_ =&gt; P)) : type_scope. *)
(* Notation "{ x &amp; P  &amp; Q }" := (sigT2 (fun x:_ =&gt; P) (fun x:A =&gt; Q)) : *)
(*   type_scope. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Add Printing Let sig.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Add Printing Let sig2.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 86
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** Projections of [sigT]

    An element [x] of a sigma-type [{y:A &amp; P y}] is a dependent pair
    made of an [a] of type [A] and an [h] of type [P a].  Then,
    [(proj1 x)] is the first projection and [(proj2 x)] is the
    second projection, the type of which depends on the [proj1]. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation projT1 := proj1_sig (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Notation projT2 := proj2_sig (only parsing).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** Various forms of the axiom of choice for specifications *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section Choice_lemmas.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Variables S S' : Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 102
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable R : S -&gt; S' -&gt; Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable R' : S -&gt; S' -&gt; Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variables R1 R2 : S -&gt; Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Lemma Choice :
   (forall x:S, {y:S' &amp; R' x y}) -&gt; {f:S -&gt; S' &amp; forall z:S, R' z (f z)}.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 108
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 109
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intro H.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 110
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exists (fun z =&gt; projT1 (H z)).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 111
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
    intro z; destruct (H z); assumption.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(*
  Lemma bool_choice :
   (forall x:S, (R1 x) + (R2 x)) -&gt;
     {f:S -&gt; bool &amp; forall x:S, (f x = true) * (R1 x) + (f x = false) * R2 x}.
  Proof.
    intro H.
    exists (fun z:S =&gt; if H z then true else false).
    intro z; destruct (H z); auto.
  Defined.
*)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>End Choice_lemmas.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section Dependent_choice_lemmas.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 127
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Variables X : Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable R : X -&gt; X -&gt; Type.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 130
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Lemma dependent_choice :
    (forall x:X, {y : _ &amp; R x y}) -&gt;
    forall x0, {f : nat -&gt; X &amp; (f O = x0) * (forall n, R (f n) (f (S n)))}.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 134
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 135
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros H x0.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 136
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    set (f:=fix f n := match n with O =&gt; x0 | S n' =&gt; projT1 (H (f n')) end).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exists f.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 138
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    split.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 139
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 139
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
    induction n; simpl; apply projT2.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 140
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 141
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Dependent_choice_lemmas.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 143
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


 (** A result of type [(Exc A)] is either a normal value of type [A] or
     an [error] :

     [Inductive Exc [A:Type] : Type := value : A-&gt;(Exc A) | error : (Exc A)].

     It is implemented using the option type. *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 152
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition Exc := option.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 152
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Definition value := @Some.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Definition error := @None.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 154
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments value {A} a.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments error {A}.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 157
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition except := False_rec.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 159
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* for compatibility with previous versions *)

</pre>
</div>
<div class="code" title="File: Specif.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Arguments except [P] _.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Theorem absurd_set : forall (A:Prop) (C:Set), A -&gt; not A -&gt; C.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 163
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros A C h1 h2.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply False_rec.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (h2 h1).</pre>
</div>
<div class="code" title="File: Specif.v
Line: 166
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 167
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

#[export] Hint Resolve existT existT2: core.</pre>
</div>
<div class="code" title="File: Specif.v
Line: 170
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

