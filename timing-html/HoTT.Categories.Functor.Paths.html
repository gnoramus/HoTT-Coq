<html>
<head>
<title>Paths.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Paths.v</h1>

<div class="code" title="File: Paths.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(** * Classification of path spaces of functors *)</pre>
</div>
<div class="code" title="File: Paths.v
Line: 1
Time: 0.015s">
<div class="time" style="width: 15.463917525773%"></div>
<pre>Require Import Category.Core Functor.Core.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 1
Time: 0.033s">
<div class="time" style="width: 34.020618556701%"></div>
<pre>
Require Import HoTT.Basics HoTT.Types HoTT.Tactics Equivalences HProp.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 2
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Set Universe Polymorphism.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable All Variables.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Asymmetric Patterns.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope morphism_scope.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope functor_scope.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 11
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section path_functor.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Variables C D : PreCategory.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>



  Local Notation functor_sig_T :=
    { OO : C -&gt; D
    | { MO : forall s d, morphism C s d -&gt; morphism D (OO s) (OO d)
      | { FCO : forall s d d' (m1 : morphism C s d) (m2 : morphism C d d'),
                  MO _ _ (m2 o m1) = MO d d' m2 o MO s d m1
        | forall x,
            MO x x (identity x) = identity (OO x) } } }
      (only parsing).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Equivalence between the record and sigma-type versions of a functor *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 30
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>Lemma equiv_sig_functor
  : functor_sig_T &lt;~&gt; Functor C D.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 32
Time: 0.097s">
<div class="time" style="width: 100%"></div>
<pre>
    issig.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 33
Time: 0.02s">
<div class="time" style="width: 20.618556701031%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We could leave it at that and be done with it, but we want a more convenient form for actually constructing paths between functors.  For this, we write a trimmed down version of something equivalent to the type of paths between functors. *)

 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Notation path_functor'_T F G
    := { HO : object_of F = object_of G
       | transport (fun GO =&gt; forall s d, morphism C s d -&gt; morphism D (GO s) (GO d))
                   HO
                   (morphism_of F)
         = morphism_of G }
         (only parsing).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We could just go prove that the path space of [functor_sig_T] is equivalent to [path_functor'_T], but unification is far too slow to do this effectively.  So instead we explicitly classify [path_functor'_T], and provide an equivalence between it and the path space of [Functor C D]. *)

  (**
&lt;&lt;
  Definition equiv_path_functor_uncurried_sig (F G : Functor C D)
  : path_functor'_T F G &lt;~&gt; (@equiv_inv _ _ _ equiv_sig_functor F
                              = @equiv_inv _ _ _ equiv_sig_functor G).
  Proof.
    etransitivity; [ | by apply equiv_path_sigma ].
    eapply @equiv_functor_sigma.
    repeat match goal with
             | [ |- context[(@equiv_inv ?A ?B ?f ?H ?F).1] ]
               =&gt; change ((@equiv_inv A B f H F).1) with (object_of F)
           end.
    Time exact (isequiv_idmap (object_of F = object_of G)). (* 13.411 secs *)
  Abort.
&gt;&gt;
   *)

  (** ** Classify sufficient conditions to prove functors equal *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 66
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>Definition path_functor_uncurried (F G : Functor C D) : path_functor'_T F G -&gt; F = G.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 66
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros [? ?].</pre>
</div>
<div class="code" title="File: Paths.v
Line: 68
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>
    destruct F, G; simpl in *.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 69
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>
    path_induction; simpl.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 70
Time: 0.072s">
<div class="time" style="width: 74.226804123711%"></div>
<pre>
    f_ap;
      eapply @center; abstract exact _.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 72
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** *** Said proof respects [object_of] *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 76
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>Lemma path_functor_uncurried_fst F G HO HM
  : ap object_of (@path_functor_uncurried F G (HO; HM)) = HO.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 77
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 78
Time: 0.004s">
<div class="time" style="width: 4.1237113402062%"></div>
<pre>
    destruct F, G; simpl in *.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 79
Time: 0.041s">
<div class="time" style="width: 42.268041237113%"></div>
<pre>
    path_induction_hammer.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 80
Time: 0.013s">
<div class="time" style="width: 13.40206185567%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** *** Said proof respects [idpath] *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 84
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>Lemma path_functor_uncurried_idpath F
  : @path_functor_uncurried F F (idpath; idpath) = idpath.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 86
Time: 0.002s">
<div class="time" style="width: 2.0618556701031%"></div>
<pre>
    destruct F; simpl in *.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 87
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>
    rewrite !(contr idpath).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 88
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    reflexivity.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 89
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 90
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Equality of functors gives rise to an inhabitant of the path-classifying-type *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 93
Time: 0.005s">
<div class="time" style="width: 5.1546391752577%"></div>
<pre>Definition path_functor_uncurried_inv (F G : Functor C D) : F = G -&gt; path_functor'_T F G
    := fun H'
       =&gt; (ap object_of H';
           (transport_compose _ object_of _ _) ^ @ apD (@morphism_of _ _) H')%path.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Curried version of path classifying lemma *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 99
Time: 0.002s">
<div class="time" style="width: 2.0618556701031%"></div>
<pre>Definition path_functor (F G : Functor C D)
        (HO : object_of F = object_of G)
        (HM : transport (fun GO =&gt; forall s d, morphism C s d -&gt; morphism D (GO s) (GO d)) HO (morphism_of F) = morphism_of G)
  : F = G
    := path_functor_uncurried F G (HO; HM).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Curried version of path classifying lemma, using [forall] in place of equality of functions *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 106
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>Definition path_functor_pointwise (F G : Functor C D)
        (HO : object_of F == object_of G)
        (HM : forall s d m,
                transport (fun GO =&gt; forall s d, morphism C s d -&gt; morphism D (GO s) (GO d))
                          (path_forall _ _ HO)
                          (morphism_of F)
                          s d m
                = G _1 m)
  : F = G.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (path_functor F G (path_forall _ _ HO) _).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 116
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>
    repeat (apply path_forall; intro); apply HM.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 117
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Classify equality of functors up to equivalence *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance isequiv_path_functor_uncurried (F G : Functor C D)
  : IsEquiv (@path_functor_uncurried F G).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 122
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (isequiv_adjointify (@path_functor_uncurried F G)
                              (@path_functor_uncurried_inv F G)).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Paths.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> hnf.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      intros [].</pre>
</div>
<div class="code" title="File: Paths.v
Line: 127
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply path_functor_uncurried_idpath.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 128
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Paths.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> hnf.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      intros [? ?].</pre>
</div>
<div class="code" title="File: Paths.v
Line: 130
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply path_sigma_uncurried.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 131
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>
      exists (path_functor_uncurried_fst _ _ _).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 132
Time: 0.017s">
<div class="time" style="width: 17.525773195876%"></div>
<pre>
      exact (center _).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 133
Time: 0.005s">
<div class="time" style="width: 5.1546391752577%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 134
Time: 0.003s">
<div class="time" style="width: 3.0927835051546%"></div>
<pre>

  Definition equiv_path_functor_uncurried (F G : Functor C D)
  : path_functor'_T F G &lt;~&gt; F = G
    := Build_Equiv _ _ (@path_functor_uncurried F G) _.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 138
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Open Scope function_scope.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 140
Time: 0.001s">
<div class="time" style="width: 1.0309278350515%"></div>
<pre>

  Definition path_path_functor_uncurried (F G : Functor C D) (p q : F = G)
  : ap object_of p = ap object_of q -&gt; p = q.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 143
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 144
Time: 0.036s">
<div class="time" style="width: 37.113402061856%"></div>
<pre>
    refine ((ap (@path_functor_uncurried F G)^-1)^-1 o _).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 145
Time: 0.05s">
<div class="time" style="width: 51.546391752577%"></div>
<pre>
    refine ((path_sigma_uncurried _ _ _) o _); simpl.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 146
Time: 0.026s">
<div class="time" style="width: 26.80412371134%"></div>
<pre>
    refine (pr1^-1).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 147
Time: 0.006s">
<div class="time" style="width: 6.1855670103093%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 148
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Instance isequiv_path_path_functor_uncurried F G p q
  : IsEquiv (@path_path_functor_uncurried F G p q).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 151
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 152
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold path_path_functor_uncurried.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** N.B. [exact _] is super-slow here.  Not sure why. *)
   </pre>
</div>
<div class="code" title="File: Paths.v
Line: 155
Time: 0.013s">
<div class="time" style="width: 13.40206185567%"></div>
<pre>repeat match goal with
             | [ |- IsEquiv (_ o _) ] =&gt; eapply @isequiv_compose
             | [ |- IsEquiv (_^-1) ] =&gt; eapply @isequiv_inverse
             | [ |- IsEquiv (path_sigma_uncurried _ _ _) ] =&gt; eapply @isequiv_path_sigma
             | _ =&gt; apply @isequiv_compose
           end.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 160
Time: 0.023s">
<div class="time" style="width: 23.711340206186%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 161
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** If the objects in [D] are n-truncated, then so is the type of functors [C → D] *)
 </pre>
</div>
<div class="code" title="File: Paths.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance trunc_functor `{IsTrunc n D} `{forall s d, IsTrunc n (morphism D s d)}
  : IsTrunc n (Functor C D).</pre>
</div>
<div class="code" title="File: Paths.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 166
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    eapply trunc_equiv'; [ exact equiv_sig_functor | ].</pre>
</div>
<div class="code" title="File: Paths.v
Line: 167
Time: 0.088s">
<div class="time" style="width: 90.721649484536%"></div>
<pre>
    induction n;
    simpl; intros;
    typeclasses eauto.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 170
Time: 0.005s">
<div class="time" style="width: 5.1546391752577%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 171
Time: 0.03s">
<div class="time" style="width: 30.927835051546%"></div>
<pre>
End path_functor.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Tactic for proving equality of functors *)</pre>
</div>
<div class="code" title="File: Paths.v
Line: 174
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac path_functor :=
  repeat match goal with
           | _ =&gt; intro
           | _ =&gt; reflexivity
           | _ =&gt; apply path_functor_uncurried; simpl
           | _ =&gt; (exists idpath)
         end.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Global Arguments path_functor_uncurried : simpl never.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Tactic for pushing [ap object_of] through other [ap]s.

    This allows lemmas like [path_functor_uncurried_fst] to apply more
    easily. *)</pre>
</div>
<div class="code" title="File: Paths.v
Line: 187
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac push_ap_object_of' :=
  idtac;
  match goal with
    | [ |- context[ap object_of (ap ?f ?p)] ]
      =&gt; rewrite &lt;- (ap_compose' f object_of p); simpl
    | [ |- context G[ap (fun F' x =&gt; object_of F' (@?f x)) ?p] ]
      =&gt; let P := context_to_lambda G in
         refine (transport P (ap_compose' object_of (fun F' x =&gt; F' (f x)) p)^ _)
    | [ |- context G[ap (fun F' x =&gt; ?f (object_of F' x)) ?p] ]
      =&gt; let P := context_to_lambda G in
         refine (transport P (ap_compose' object_of (fun F' x =&gt; f (F' x)) p)^ _)
  end.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 198
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac push_ap_object_of := repeat push_ap_object_of'.</pre>
</div>
<div class="code" title="File: Paths.v
Line: 200
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

